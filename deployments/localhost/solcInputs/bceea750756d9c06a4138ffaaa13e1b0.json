{
  "language": "Solidity",
  "sources": {
    "packages/protocol/contracts/CollateralLocker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/// @title CollateralLocker holds custody of Collateral Asset for Loans.\ncontract CollateralLocker {\n\n    using SafeERC20 for IERC20;\n\n    IERC20  public immutable collateralAsset;  // Address the Collateral Asset the Loan is collateralized with.\n    address public immutable loan;             // Loan contract address this CollateralLocker is attached to.\n\n    constructor(address _collateralAsset, address _loan) public {\n        collateralAsset = IERC20(_collateralAsset);\n        loan            = _loan;\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Loan.\n    */\n    modifier isLoan() {\n        require(msg.sender == loan, \"CL:NOT_L\");\n        _;\n    }\n\n    /**\n        @dev   Transfers amount of Collateral Asset to a destination account. Only the Loan can call this function.\n        @param dst Destination to transfer Collateral Asset to.\n        @param amt Amount of Collateral Asset to transfer.\n    */\n    function pull(address dst, uint256 amt) isLoan external {\n        collateralAsset.safeTransfer(dst, amt);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "packages/protocol/contracts/CollateralLockerFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./interfaces/ILoanFactory.sol\";\n\nimport \"./CollateralLocker.sol\";\n\n/// @title CollateralLockerFactory instantiates CollateralLockers.\ncontract CollateralLockerFactory {\n\n    mapping(address => address) public owner;     // Mapping of CollateralLocker addresses to their owner (i.e owner[locker] = Owner of the CollateralLocker).\n    mapping(address => bool)    public isLocker;  // True only if a CollateralLocker was created by this factory.\n\n    uint8 public constant factoryType = 0;  // i.e FactoryType::COLLATERAL_LOCKER_FACTORY\n\n    event CollateralLockerCreated(address indexed owner, address collateralLocker, address collateralAsset);\n\n    /**\n        @dev    Instantiates a CollateralLocker.\n        @dev    It emits a `CollateralLockerCreated` event.\n        @param  collateralAsset  The Collateral Asset this CollateralLocker will escrow.\n        @return collateralLocker Address of the instantiated CollateralLocker.\n    */\n    function newLocker(address collateralAsset) external returns (address collateralLocker) {\n        collateralLocker           = address(new CollateralLocker(collateralAsset, msg.sender));\n        owner[collateralLocker]    = msg.sender;\n        isLocker[collateralLocker] = true;\n\n        emit CollateralLockerCreated(msg.sender, collateralLocker, collateralAsset);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/ILoanFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface ILoanFactory {\n\n    function CL_FACTORY() external view returns (uint8);\n\n    function FL_FACTORY() external view returns (uint8);\n\n    function INTEREST_CALC_TYPE() external view returns (uint8);\n\n    function LATEFEE_CALC_TYPE() external view returns (uint8);\n\n    function PREMIUM_CALC_TYPE() external view returns (uint8);\n\n    function globals() external view returns (address);\n\n    function loansCreated() external view returns (uint256);\n\n    function loans(uint256) external view returns (address);\n\n    function isLoan(address) external view returns (bool);\n\n    function loanFactoryAdmins(address) external view returns (bool);\n\n    function setGlobals(address) external;\n    \n    function createLoan(address, address, address, address, uint256[5] memory, address[3] memory) external returns (address);\n\n    function setLoanFactoryAdmin(address, bool) external;\n\n    function pause() external;\n\n    function unpause() external;\n\n}\n"
    },
    "packages/protocol/contracts/test/TestUtil.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./user/Borrower.sol\";\nimport \"./user/Commoner.sol\";\nimport \"./user/Farmer.sol\";\nimport \"./user/Holder.sol\";\nimport \"./user/LP.sol\";\nimport \"./user/PoolDelegate.sol\";\nimport \"./user/Staker.sol\";\n\nimport \"./user/Governor.sol\";\nimport \"./user/SecurityAdmin.sol\";\nimport \"./user/EmergencyAdmin.sol\";\n\nimport \"../MapleGlobals.sol\";\nimport \"../MapleTreasury.sol\";\nimport \"../../../token/contracts/MapleToken.sol\";\n\nimport \"../CollateralLockerFactory.sol\";\nimport \"../DebtLockerFactory.sol\";\nimport \"../FundingLockerFactory.sol\";\nimport \"../LiquidityLockerFactory.sol\";\nimport \"../LoanFactory.sol\";\nimport \"../MplRewardsFactory.sol\";\nimport \"../PoolFactory.sol\";\nimport \"../StakeLockerFactory.sol\";\n\nimport \"./interfaces/IUniswapV2Factory.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IUniswapV2Router02.sol\";\n\nimport \"../LateFeeCalc.sol\";\nimport \"../PremiumCalc.sol\";\nimport \"../RepaymentCalc.sol\";\n\nimport \"../oracles/ChainlinkOracle.sol\";\nimport \"../oracles/UsdOracle.sol\";\n\nimport \"../interfaces/IBPool.sol\";\nimport \"../interfaces/IBFactory.sol\";\n\nimport \"../../../ds-test/contracts/test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface Hevm {\n    function warp(uint256) external;\n    function store(address,bytes32,bytes32) external;\n}\n\ninterface User {\n    function approve(address, uint256) external;\n}\n\ncontract TestUtil is DSTest {\n\n    using SafeMath for uint256;\n\n    Hevm hevm;\n\n    /***********************/\n    /*** Protocol Actors ***/\n    /***********************/\n    Borrower      bob;\n    Borrower      ben;\n    Borrower      bud;\n\n    Commoner      cam;\n\n    Farmer        fay;\n    Farmer        fez;\n    Farmer        fox;\n\n    Holder        hal;\n    Holder        hue;\n\n    LP            leo;\n    LP            liz;\n    LP            lex;\n    LP            lee;\n\n    PoolDelegate  pat;\n    PoolDelegate  pam;\n\n    Staker        sam;\n    Staker        sid;\n    Staker        sue;\n\n    /**************************/\n    /*** Multisig Addresses ***/\n    /**************************/\n    Governor                   gov;\n    Governor               fakeGov;\n    SecurityAdmin    securityAdmin;\n    EmergencyAdmin  emergencyAdmin;\n\n    /*******************/\n    /*** Calculators ***/\n    /*******************/\n    LateFeeCalc      lateFeeCalc;\n    PremiumCalc      premiumCalc;\n    RepaymentCalc  repaymentCalc;\n    address[3]             calcs;\n\n    /*****************/\n    /*** Factories ***/\n    /*****************/\n    CollateralLockerFactory          clFactory;\n    DebtLockerFactory                dlFactory;\n    DebtLockerFactory               dlFactory2;\n    FundingLockerFactory             flFactory;\n    LiquidityLockerFactory           llFactory;\n    LoanFactory                    loanFactory;\n    PoolFactory                    poolFactory;\n    StakeLockerFactory               slFactory;\n    MplRewardsFactory        mplRewardsFactory;\n\n    /***********************/\n    /*** Maple Contracts ***/\n    /***********************/\n    MapleGlobals       globals;\n    MapleToken             mpl;\n    MapleTreasury     treasury;\n    IBPool               bPool;\n    MplRewards      mplRewards;\n    IUniswapV2Pair uniswapPair;\n\n    /***************/\n    /*** Oracles ***/\n    /***************/\n    ChainlinkOracle  wethOracle;\n    ChainlinkOracle  wbtcOracle;\n    ChainlinkOracle   daiOracle;\n    UsdOracle         usdOracle;\n\n    /*************/\n    /*** Loans ***/\n    /*************/\n    Loan   loan;\n    Loan  loan2;\n    Loan  loan3;\n    Loan  loan4;\n\n    /*************/\n    /*** Pools ***/\n    /*************/\n    Pool   pool;\n    Pool  pool2;\n    Pool  pool3;\n\n    /***************/\n    /*** Lockers ***/\n    /***************/\n    StakeLocker stakeLocker;\n    StakeLocker stakeLocker2;\n\n    /**********************************/\n    /*** Mainnet Contract Addresses ***/\n    /**********************************/\n    address constant DAI   = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address constant USDC  = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address constant WETH  = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant WBTC  = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    address constant CDAI  = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n\n    IERC20 constant dai  = IERC20(DAI);\n    IERC20 constant usdc = IERC20(USDC);\n    IERC20 constant weth = IERC20(WETH);\n    IERC20 constant wbtc = IERC20(WBTC);\n\n    address constant BPOOL_FACTORY        = 0x9424B1412450D0f8Fc2255FAf6046b98213B76Bd; // Balancer pool factory\n    address constant UNISWAP_V2_ROUTER_02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // Uniswap V2 Router\n    address constant UNISWAP_V2_FACTORY   = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // Uniswap V2 factory.\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n    uint8 public constant CL_FACTORY = 0;  // Factory type of `CollateralLockerFactory`.\n    uint8 public constant DL_FACTORY = 1;  // Factory type of `DebtLockerFactory`.\n    uint8 public constant FL_FACTORY = 2;  // Factory type of `FundingLockerFactory`.\n    uint8 public constant LL_FACTORY = 3;  // Factory type of `LiquidityLockerFactory`.\n    uint8 public constant SL_FACTORY = 4;  // Factory type of `StakeLockerFactory`.\n\n    uint8 public constant INTEREST_CALC_TYPE = 10;  // Calc type of `RepaymentCalc`.\n    uint8 public constant LATEFEE_CALC_TYPE  = 11;  // Calc type of `LateFeeCalc`.\n    uint8 public constant PREMIUM_CALC_TYPE  = 12;  // Calc type of `PremiumCalc`.\n\n    uint256 constant USD = 10 ** 6;  // USDC precision decimals\n    uint256 constant BTC = 10 ** 8;  // WBTC precision decimals\n    uint256 constant WAD = 10 ** 18;\n    uint256 constant RAY = 10 ** 27;\n\n    uint256 constant MAX_UINT = uint256(-1);\n\n    /*****************/\n    /*** Utilities ***/\n    /*****************/\n    struct Token {\n        address addr; // ERC20 Mainnet address\n        uint256 slot; // Balance storage slot\n        address orcl; // Chainlink oracle address\n    }\n\n    mapping (bytes32 => Token) tokens;\n\n    struct TestObj {\n        uint256 pre;\n        uint256 post;\n    }\n\n    event Debug(string, uint256);\n    event Debug(string, address);\n    event Debug(string, bool);\n\n    constructor() public { hevm = Hevm(address(bytes20(uint160(uint256(keccak256(\"hevm cheat code\")))))); }\n\n    /**************************************/\n    /*** Actor/Multisig Setup Functions ***/\n    /**************************************/\n    function createBorrower()       public { bob = new Borrower(); }\n    function createBorrowers()      public { bob = new Borrower(); ben = new Borrower(); bud = new Borrower(); }\n\n    function createCommoner()       public { cam = new Commoner(); }\n\n    function createHolder()         public { hal = new Holder(); }\n    function createHolders()        public { hal = new Holder(); hue = new Holder(); }\n\n    function createLP()             public { leo = new LP(); }\n    function createLPs()            public { leo = new LP(); liz = new LP(); lex = new LP(); lee = new LP(); }\n\n    function createPoolDelegate()   public { pat = new PoolDelegate(); }\n    function createPoolDelegates()  public { pat = new PoolDelegate(); pam = new PoolDelegate(); }\n\n    function createStaker()         public { sam = new Staker(); }\n    function createStakers()        public { sam = new Staker(); sid = new Staker(); sue = new Staker(); }\n\n    function createGovernor()       public { gov = new Governor(); }\n    function createGovernors()      public { gov = new Governor(); fakeGov = new Governor(); }\n\n    function createSecurityAdmin()  public { securityAdmin = new SecurityAdmin(); }\n\n    function createEmergencyAdmin() public { emergencyAdmin = new EmergencyAdmin(); }\n\n    function setUpPoolDelegate() public {\n        createPoolDelegate();\n        gov.setPoolDelegateAllowlist(address(pat), true);\n    }\n\n    function setUpPoolDelegates() public {\n        createPoolDelegates();\n        gov.setPoolDelegateAllowlist(address(pat), true);\n        gov.setPoolDelegateAllowlist(address(pam), true);\n    }\n\n    function setUpActors() public {\n        setUpPoolDelegates();\n        createBorrowers();\n        createCommoner();\n        createHolders();\n        createLPs();\n        createStakers();\n    }\n\n    /**************************************/\n    /*** Maple Contract Setup Functions ***/\n    /**************************************/\n    function createMpl()      public { mpl      = new MapleToken(\"MapleToken\", \"MPL\", USDC); }\n    function createGlobals()  public { globals  = gov.createGlobals(address(mpl)); }\n    function createTreasury() public { treasury = new MapleTreasury(address(mpl), USDC, UNISWAP_V2_ROUTER_02, address(globals)); }\n    function createBPool()    public { bPool    = IBPool(IBFactory(BPOOL_FACTORY).newBPool()); }\n\n    function setUpMplRewardsFactory() public {\n        mplRewardsFactory = gov.createMplRewardsFactory();\n        fakeGov.setGovMplRewardsFactory(mplRewardsFactory);\n    }\n\n    function setUpGlobals() public {\n        createGovernors();\n        createSecurityAdmin();\n        createEmergencyAdmin();\n        createMpl();\n        createGlobals();\n        createTreasury();\n        createBPool();\n\n        gov.setMapleTreasury(address(treasury));\n        gov.setGlobalAdmin(address(emergencyAdmin));\n        gov.setDefaultUniswapPath(WBTC, USDC, WETH);\n        gov.setGovTreasury(treasury);\n        fakeGov.setGovTreasury(treasury);\n    }\n\n    /**********************************/\n    /*** Calculator Setup Functions ***/\n    /**********************************/\n    function createLateFeeCalc()   public { lateFeeCalc   = new LateFeeCalc(5); }\n    function createPremiumCalc()   public { premiumCalc   = new PremiumCalc(500); }\n    function createRepaymentCalc() public { repaymentCalc = new RepaymentCalc(); }\n\n    function setUpCalcs() public {\n        createLateFeeCalc();\n        createPremiumCalc();\n        createRepaymentCalc();\n\n        gov.setCalc(address(repaymentCalc), true);\n        gov.setCalc(address(lateFeeCalc),   true);\n        gov.setCalc(address(premiumCalc),   true);\n\n        calcs = [address(repaymentCalc), address(lateFeeCalc), address(premiumCalc)];\n    }\n\n    /********************************/\n    /*** Factory Setup Functions ***/\n    /********************************/\n    function createPoolFactory()             public { poolFactory = new PoolFactory(address(globals)); }\n    function createStakeLockerFactory()      public { slFactory   = new StakeLockerFactory(); }\n    function createLiquidityLockerFactory()  public { llFactory   = new LiquidityLockerFactory(); }\n    function createDebtLockerFactories()     public { dlFactory   = new DebtLockerFactory(); dlFactory2  = new DebtLockerFactory(); }\n    function createLoanFactory()             public { loanFactory = new LoanFactory(address(globals)); }\n    function createCollateralLockerFactory() public { clFactory   = new CollateralLockerFactory(); }\n    function createFundingLockerFactory()    public { flFactory   = new FundingLockerFactory(); }\n\n    function setUpFactories() public {\n        createPoolFactory();\n        createStakeLockerFactory();\n        createLiquidityLockerFactory();\n        createDebtLockerFactories();\n        createLoanFactory();\n        createCollateralLockerFactory();\n        createFundingLockerFactory();\n\n        gov.setValidPoolFactory(address(poolFactory), true);\n        gov.setValidSubFactory( address(poolFactory), address(slFactory),  true);\n        gov.setValidSubFactory( address(poolFactory), address(llFactory),  true);\n        gov.setValidSubFactory( address(poolFactory), address(dlFactory),  true);\n        gov.setValidSubFactory( address(poolFactory), address(dlFactory2), true);\n\n        gov.setValidLoanFactory(address(loanFactory), true);\n        gov.setValidSubFactory( address(loanFactory), address(flFactory), true);\n        gov.setValidSubFactory( address(loanFactory), address(clFactory), true);\n    }\n\n    /**************************************/\n    /*** Liquidity Pool Setup Functions ***/\n    /**************************************/\n    function createLiquidityPool() public {\n        pool = Pool(pat.createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),\n            address(slFactory),\n            address(llFactory),\n            500,\n            100,\n            uint256(-1)\n        ));\n    }\n\n    function createLiquidityPools() public {\n        createLiquidityPool();\n        pool2 = Pool(pam.createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),\n            address(slFactory),\n            address(llFactory),\n            7500,\n            50,\n            MAX_UINT // liquidityCap value\n        ));\n    }\n\n    function setUpLiquidityPool() public {\n        createLiquidityPool();\n        stakeLocker = StakeLocker(pool.stakeLocker());\n        pat.approve(address(bPool), pool.stakeLocker(), uint256(-1));\n        pat.stake(pool.stakeLocker(), bPool.balanceOf(address(pat)));\n        pat.finalize(address(pool));\n        pat.setOpenToPublic(address(pool), true);\n    }\n\n    function stakeAndFinalizePool(uint256 stakeAmt) public {\n        stakeLocker = StakeLocker(pool.stakeLocker());\n        pat.approve(address(bPool), pool.stakeLocker(), uint256(-1));\n        pat.stake(pool.stakeLocker(), stakeAmt);\n        pat.finalize(address(pool));\n        pat.setOpenToPublic(address(pool), true);\n    }\n\n    function stakeAndFinalizePools(uint256 stakeAmt, uint256 stakeAmt2) public {\n        stakeAndFinalizePool(stakeAmt);\n\n        stakeLocker2 = StakeLocker(pool2.stakeLocker());\n        pam.approve(address(bPool), pool2.stakeLocker(), uint256(-1));\n        pam.stake(pool2.stakeLocker(), stakeAmt2);\n        pam.finalize(address(pool2));\n        pam.setOpenToPublic(address(pool2), true);\n    }\n\n    function stakeAndFinalizePool() public {\n        stakeAndFinalizePool(bPool.balanceOf(address(pat)));\n    }\n\n    function stakeAndFinalizePools() public {\n        stakeAndFinalizePools(bPool.balanceOf(address(pat)), bPool.balanceOf(address(pam)));\n    }\n\n    function setUpLiquidityPools() public {\n        createLiquidityPools();\n        stakeAndFinalizePools();\n    }\n\n    /******************************/\n    /*** Oracle Setup Functions ***/\n    /******************************/\n    function createWethOracle() public { wethOracle = new ChainlinkOracle(tokens[\"WETH\"].orcl, WETH, address(securityAdmin)); }\n    function createWbtcOracle() public { wbtcOracle = new ChainlinkOracle(tokens[\"WBTC\"].orcl, WBTC, address(securityAdmin)); }\n    function createDaiOracle()  public { daiOracle  = new ChainlinkOracle(tokens[\"DAI\"].orcl,  DAI,  address(securityAdmin)); }\n    function createUsdOracle()  public { usdOracle  = new UsdOracle(); }\n\n    function setUpOracles() public {\n        createWethOracle();\n        createWbtcOracle();\n        createDaiOracle();\n        createUsdOracle();\n\n        gov.setPriceOracle(WETH, address(wethOracle));\n        gov.setPriceOracle(WBTC, address(wbtcOracle));\n        gov.setPriceOracle(DAI,  address(daiOracle));\n        gov.setPriceOracle(USDC, address(usdOracle));\n    }\n\n    /*************************************/\n    /*** Balancer Pool Setup Functions ***/\n    /*************************************/\n    function createBalancerPool(uint256 usdcAmount, uint256 mplAmount) public {\n        // Mint USDC into this account\n        mint(\"USDC\", address(this), usdcAmount);\n\n        // Initialize MPL/USDC Balancer Pool and whitelist\n        bPool = IBPool(IBFactory(BPOOL_FACTORY).newBPool());\n        usdc.approve(address(bPool), MAX_UINT);\n        mpl.approve(address(bPool),  MAX_UINT);\n        bPool.bind(USDC,         usdcAmount, 5 ether);  // Bind USDC with 5 denormalization weight\n        bPool.bind(address(mpl),  mplAmount, 5 ether);  // Bind  MPL with 5 denormalization weight\n        bPool.finalize();\n        gov.setValidBalancerPool(address(bPool), true);\n    }\n    // TODO: Update this and update tests to use realistic launch pool (waiting for pool fuzz merge)\n    function createBalancerPool() public {\n        createBalancerPool(1_550_000 * USD, 155_000 * WAD);\n    }\n\n    function setUpBalancerPool() public {\n        createBalancerPool();\n        transferBptsToPoolDelegates();\n    }\n\n    function setUpBalancerPoolForStakers() public {\n        createBalancerPool();\n        transferBptsToPoolDelegateAndStakers();\n    }\n\n    function setUpBalancerPoolForPools() public {\n        createBalancerPool();\n        transferBptsToPoolDelegatesAndStakers();\n    }\n\n    function transferBptsToPoolDelegates() public {\n        bPool.transfer(address(pat), 50 * WAD);  // Give PD a balance of BPTs to finalize pool\n        bPool.transfer(address(pam), 50 * WAD);  // Give PD a balance of BPTs to finalize pool\n    }\n\n    function transferBptsToPoolDelegateAndStakers() public {\n        bPool.transfer(address(pat), 50 * WAD);  // Give PD a balance of BPTs to finalize pool\n        bPool.transfer(address(sam), 25 * WAD);  // Give staker a balance of BPTs to stake against finalized pool\n        bPool.transfer(address(sid), 25 * WAD);  // Give staker a balance of BPTs to stake against finalized pool\n    }\n\n    function transferBptsToPoolDelegatesAndStakers() public {\n        bPool.transfer(address(pat), 25 * WAD);  // Give PD a balance of BPTs to finalize pool\n        bPool.transfer(address(pam), 25 * WAD);  // Give PD a balance of BPTs to finalize pool\n        bPool.transfer(address(sam), 25 * WAD);  // Give staker a balance of BPTs to stake against finalized pool\n        bPool.transfer(address(sid), 25 * WAD);  // Give staker a balance of BPTs to stake against finalized pool\n    }\n\n    function transferMoreBpts(address to, uint256 amt) public {\n        bPool.transfer(to, amt);\n    }\n\n    /****************************/\n    /*** Loan Setup Functions ***/\n    /****************************/\n    function createLoan() public {\n        uint256[5] memory specs = [500, 180, 30, uint256(1000 * USD), 2000];\n        loan = bob.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs);\n    }\n    function createLoan(uint256[5] memory specs) public {\n        loan = bob.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs);\n    }\n    function createLoans() public {\n        uint256[5] memory specs = [500, 180, 30, uint256(1000 * USD), 2000];\n        loan  = bob.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs);\n        loan2 = ben.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs);\n        loan3 = bud.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs);\n    }\n\n    /*************************************/\n    /*** Yield Farming Setup Functions ***/\n    /*************************************/\n    function setUpMplRewards() public {\n        mplRewards = gov.createMplRewards(address(mpl), address(pool));\n        fakeGov.setGovMplRewards(mplRewards);                            // Used to assert failures\n    }\n\n    function createFarmers() public {\n        fay = new Farmer(mplRewards, pool);\n        fez = new Farmer(mplRewards, pool);\n        fox = new Farmer(mplRewards, pool);\n    }\n\n    function setUpFarmers(uint256 amt1, uint256 amt2, uint256 amt3) public {\n        createFarmers();\n\n        mintFundsAndDepositIntoPool(fay, pool, amt1, amt1);\n        mintFundsAndDepositIntoPool(fez, pool, amt2, amt2);\n        mintFundsAndDepositIntoPool(fox, pool, amt3, amt3);\n    }\n\n    /******************************/\n    /*** Test Utility Functions ***/\n    /******************************/\n    function setUpTokens() public {\n        gov.setLiquidityAsset(DAI,   true);\n        gov.setLiquidityAsset(USDC,  true);\n        gov.setCollateralAsset(DAI,  true);\n        gov.setCollateralAsset(USDC, true);\n        gov.setCollateralAsset(WETH, true);\n        gov.setCollateralAsset(WBTC, true);\n\n        tokens[\"USDC\"].addr = USDC;\n        tokens[\"USDC\"].slot = 9;\n\n        tokens[\"DAI\"].addr = DAI;\n        tokens[\"DAI\"].slot = 2;\n        tokens[\"DAI\"].orcl = 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9;\n\n        tokens[\"WETH\"].addr = WETH;\n        tokens[\"WETH\"].slot = 3;\n        tokens[\"WETH\"].orcl = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n\n        tokens[\"WBTC\"].addr = WBTC;\n        tokens[\"WBTC\"].slot = 0;\n        tokens[\"WBTC\"].orcl = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;\n    }\n\n    // Manipulate mainnet ERC20 balance\n    function mint(bytes32 symbol, address account, uint256 amt) public {\n        address addr = tokens[symbol].addr;\n        uint256 slot  = tokens[symbol].slot;\n        uint256 bal = IERC20(addr).balanceOf(account);\n\n        hevm.store(\n            addr,\n            keccak256(abi.encode(account, slot)), // Mint tokens\n            bytes32(bal + amt)\n        );\n\n        assertEq(IERC20(addr).balanceOf(account), bal + amt); // Assert new balance\n    }\n\n    // Verify equality within accuracy decimals\n    function withinPrecision(uint256 val0, uint256 val1, uint256 accuracy) public {\n        uint256 diff  = val0 > val1 ? val0 - val1 : val1 - val0;\n        if (diff == 0) return;\n\n        uint256 denominator = val0 == 0 ? val1 : val0;\n        bool check = ((diff * RAY) / denominator) < (RAY / 10 ** accuracy);\n\n        if (!check){\n            emit log_named_uint(\"Error: approx a == b not satisfied, accuracy digits \", accuracy);\n            emit log_named_uint(\"  Expected\", val0);\n            emit log_named_uint(\"    Actual\", val1);\n            fail();\n        }\n    }\n\n    // Verify equality within difference\n    function withinDiff(uint256 val0, uint256 val1, uint256 expectedDiff) public {\n        uint256 actualDiff = val0 > val1 ? val0 - val1 : val1 - val0;\n        bool check = actualDiff <= expectedDiff;\n\n        if (!check) {\n            emit log_named_uint(\"Error: approx a == b not satisfied, accuracy difference \", expectedDiff);\n            emit log_named_uint(\"  Expected\", val0);\n            emit log_named_uint(\"    Actual\", val1);\n            fail();\n        }\n    }\n\n    function constrictToRange(uint256 val, uint256 min, uint256 max) public pure returns (uint256) {\n        return constrictToRange(val, min, max, false);\n    }\n\n    function constrictToRange(uint256 val, uint256 min, uint256 max, bool nonZero) public pure returns (uint256) {\n        if      (val == 0 && !nonZero) return 0;\n        else if (max == min)           return max;\n        else                           return val % (max - min) + min;\n    }\n\n    function getFuzzedSpecs(\n        uint256 apr,\n        uint256 index,             // Random index for random payment interval\n        uint256 numPayments,       // Used for termDays\n        uint256 requestAmount,\n        uint256 collateralRatio\n    ) public pure returns (uint256[5] memory specs) {\n        return getFuzzedSpecs(apr, index, numPayments, requestAmount, collateralRatio, 10_000 * USD, 10_000, 1E10 * USD);\n    }\n\n    function getFuzzedSpecs(\n        uint256 apr,\n        uint256 index,             // Random index for random payment interval\n        uint256 numPayments,       // Used for termDays\n        uint256 requestAmount,\n        uint256 collateralRatio,\n        uint256 minimumRequestAmt,\n        uint256 maxCollateralRatio,\n        uint256 maxRequestAmt\n    ) public pure returns (uint256[5] memory specs) {\n        uint16[10] memory paymentIntervalArray = [1, 2, 5, 7, 10, 15, 30, 60, 90, 360];\n        numPayments = constrictToRange(numPayments, 5, 100, true);\n        uint256 paymentIntervalDays = paymentIntervalArray[index % 10];  // TODO: Consider changing this approach\n        uint256 termDays            = paymentIntervalDays * numPayments;\n\n        specs = [\n            constrictToRange(apr, 1, 10_000, true),                                   // APR between 0.01% and 100% (non-zero for test behavior)\n            termDays,                                                                 // Fuzzed term days\n            paymentIntervalDays,                                                      // Payment interval days from array\n            constrictToRange(requestAmount, minimumRequestAmt, maxRequestAmt, true),  // 10k USD - 10b USD loans (non-zero) in general scenario\n            constrictToRange(collateralRatio, 0, maxCollateralRatio)                  // Collateral ratio between 0 and maxCollateralRatio\n        ];\n    }\n\n    function toApy(uint256 yield, uint256 stake, uint256 dTime) internal returns (uint256) {\n        return yield * 10_000 * 365 days / stake / dTime;\n    }\n\n    // Function used to calculate theoretical allotments (e.g. interest for FDTs)\n    function calcPortion(uint256 amt, uint256 totalClaim, uint256 totalAmt) internal pure returns (uint256) {\n        return amt == uint256(0) ? uint256(0) : amt.mul(totalClaim).div(totalAmt);\n    }\n    /*****************************/\n    /*** Yield Farming Helpers ***/\n    /*****************************/\n    function setUpFarming(uint256 totalMpl, uint256 rewardsDuration) internal {\n        mpl.transfer(address(gov), totalMpl);              // Transfer MPL to Governor\n        gov.transfer(mpl, address(mplRewards), totalMpl);  // Transfer MPL to MplRewards\n        gov.setRewardsDuration(rewardsDuration);\n        gov.notifyRewardAmount(totalMpl);\n    }\n\n    function stakeIntoFarm(Farmer farmer, uint256 amt) internal{\n        farmer.increaseCustodyAllowance(address(pool), address(mplRewards), amt);\n        farmer.stake(amt);\n    }\n\n    function setUpFarmingAndDeposit(uint256 totalMpl, uint256 rewardsDuration, uint256 amt1, uint256 amt2, uint256 amt3) internal {\n        setUpFarming(totalMpl, rewardsDuration);\n\n        stakeIntoFarm(fay, amt1);\n        stakeIntoFarm(fez, amt2);\n        stakeIntoFarm(fox, amt3);\n    }\n\n    /********************/\n    /*** Pool Helpers ***/\n    /********************/\n    function finalizePool(Pool pool, PoolDelegate del, bool openToPublic) internal {\n        del.approve(address(bPool), pool.stakeLocker(), MAX_UINT);\n        del.stake(pool.stakeLocker(), bPool.balanceOf(address(del)) / 2);\n\n        del.finalize(address(pool));\n        if (openToPublic) del.setOpenToPublic(address(pool), true);\n    }\n\n    function mintFundsAndDepositIntoPool(LP lp, Pool pool, uint256 mintAmt, uint256 liquidityAmt) internal {\n        if (mintAmt > uint256(0)) {\n            mint(\"USDC\", address(lp), mintAmt);\n        }\n\n        lp.approve(USDC, address(pool), MAX_UINT);\n        lp.deposit(address(pool), liquidityAmt);\n    }\n\n    function drawdown(Loan loan, Borrower bow, uint256 usdDrawdownAmt) internal {\n        uint256 cReq = loan.collateralRequiredForDrawdown(usdDrawdownAmt); // wETH required for `usdDrawdownAmt` USDC drawdown on loan\n        mint(\"WETH\", address(bow), cReq);\n        bow.approve(WETH, address(loan),  cReq);\n        bow.drawdown(address(loan),  usdDrawdownAmt);\n    }\n\n    function doPartialLoanPayment(Loan loan, Borrower bow) internal returns (uint256 amt) {\n        (amt,,,,) = loan.getNextPayment(); // USDC required for next payment of loan\n        mint(\"USDC\", address(bow), amt);\n        bow.approve(USDC, address(loan),  amt);\n        bow.makePayment(address(loan));\n    }\n\n    function doFullLoanPayment(Loan loan, Borrower bow) internal {\n        (uint256 amt,,) = loan.getFullPayment(); // USDC required for full payment of loan\n        mint(\"USDC\", address(bow), amt);\n        bow.approve(USDC, address(loan),  amt);\n        bow.makeFullPayment(address(loan));\n    }\n\n    function setUpLoanMakeOnePaymentAndDefault() public returns (uint256 interestPaid) {\n        // Fund the pool\n        mint(\"USDC\", address(leo), 20_000_000 * USD);\n        leo.approve(USDC, address(pool), MAX_UINT);\n        leo.deposit(address(pool), 10_000_000 * USD);\n\n        // Fund the loan\n        pat.fundLoan(address(pool), address(loan), address(dlFactory), 1_000_000 * USD);\n        uint cReq = loan.collateralRequiredForDrawdown(1_000_000 * USD);\n\n        // Drawdown loan\n        mint(\"WETH\", address(bob), cReq);\n        bob.approve(WETH, address(loan), MAX_UINT);\n        bob.approve(USDC, address(loan), MAX_UINT);\n        bob.drawdown(address(loan), 1_000_000 * USD);\n\n        uint256 preBal = IERC20(USDC).balanceOf(address(bob));\n        bob.makePayment(address(loan));  // Make one payment to register interest for Staker\n        interestPaid = preBal.sub(IERC20(USDC).balanceOf(address(bob)));\n\n        // Warp to late payment\n        uint256 start = block.timestamp;\n        uint256 nextPaymentDue = loan.nextPaymentDue();\n        uint256 defaultGracePeriod = globals.defaultGracePeriod();\n        hevm.warp(start + nextPaymentDue + defaultGracePeriod + 1);\n\n        // Trigger default\n        pat.triggerDefault(address(pool), address(loan), address(dlFactory));\n    }\n\n    function make_withdrawable(LP investor, Pool pool) internal {\n        uint256 currentTime = block.timestamp;\n        assertTrue(investor.try_intendToWithdraw(address(pool)));\n        assertEq(pool.withdrawCooldown(address(investor)), currentTime, \"Incorrect value set\");\n        hevm.warp(currentTime + globals.lpCooldownPeriod());\n    }\n\n    function setUpUniswapMplUsdcPool(uint256 mplDesiredAmt, uint256 usdcDesiredAmt) internal {\n        // Mint USDC into this account\n        mint(\"USDC\", address(this), usdcDesiredAmt);\n\n        // Initialize MPL/USDC Uniswap Pool\n        uniswapPair = IUniswapV2Pair(IUniswapV2Factory(UNISWAP_V2_FACTORY).createPair(address(mpl), address(usdc)));\n        usdc.approve(UNISWAP_V2_ROUTER_02, MAX_UINT);\n        mpl.approve(UNISWAP_V2_ROUTER_02,  MAX_UINT);\n        // passing the same value of amountAMin, amountBMin to mplDesiredAmt & usdcDesiredAmt respectively as those\n        // values will never gonna be in use for the initial addition of the liquidity.\n        IUniswapV2Router02(UNISWAP_V2_ROUTER_02).addLiquidity(address(mpl), address(usdc), mplDesiredAmt, usdcDesiredAmt, mplDesiredAmt, usdcDesiredAmt, address(gov), now + 10 minutes);\n    }\n\n    /***********************/\n    /*** Staking Helpers ***/\n    /***********************/\n    function make_unstakeable(Staker staker, StakeLocker stakeLocker) internal {\n        uint256 currentTime = block.timestamp;\n        assertTrue(staker.try_intendToUnstake(address(stakeLocker)));\n        assertEq(stakeLocker.unstakeCooldown(address(staker)), currentTime, \"Incorrect value set\");\n        hevm.warp(currentTime + globals.stakerCooldownPeriod());\n    }\n\n    function toWad(uint256 amt) internal view returns (uint256) {\n        return amt.mul(WAD).div(USD);\n    }\n\n    // function test_cheat_code_for_slot() public {\n    //     address CDAI = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n\n    //     uint256 i = 0;\n\n    //     while(IERC20(CDAI).balanceOf(address(this)) == 0) {\n    //         hevm.store(\n    //             CDAI,\n    //             keccak256(abi.encode(address(this), i)), // Mint tokens\n    //             bytes32(uint256(100))\n    //         );\n    //         if(IERC20(CDAI).balanceOf(address(this)) == 100) {\n    //             log_named_uint(\"slot\", i);\n    //         }\n    //         i += 1;\n    //     }\n    //     // assertTrue(false);\n    // }\n}\n"
    },
    "packages/protocol/contracts/test/user/Borrower.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../Loan.sol\";\n\nimport \"../../interfaces/IStakeLocker.sol\";\nimport \"../../interfaces/ILoan.sol\";\nimport \"../../interfaces/ILoanFactory.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Borrower {\n\n    /************************/\n    /*** DIRECT FUNCTIONS ***/\n    /************************/\n\n    function pause(address loan) external {\n        ILoan(loan).pause();\n    }\n\n    function unpause(address loan) external {\n        ILoan(loan).unpause();\n    }\n\n    function makePayment(address loan) external {\n        ILoan(loan).makePayment();\n    }\n\n    function makeFullPayment(address loan) external {\n        ILoan(loan).makeFullPayment();\n    }\n\n    function drawdown(address loan, uint256 _drawdownAmount) external {\n        ILoan(loan).drawdown(_drawdownAmount);\n    }\n\n    function approve(address token, address account, uint256 amt) external {\n        IERC20(token).approve(account, amt);\n    }\n\n    function createLoan(\n        address loanFactory,\n        address liquidityAsset,\n        address collateralAsset,\n        address flFactory,\n        address clFactory,\n        uint256[5] memory specs,\n        address[3] memory calcs\n    )\n        external returns (Loan loan)\n    {\n        loan = Loan(\n            ILoanFactory(loanFactory).createLoan(liquidityAsset, collateralAsset, flFactory, clFactory, specs, calcs)\n        );\n    }\n\n    function triggerDefault(address loan) external {\n        ILoan(loan).triggerDefault();\n    }\n\n\n    /*********************/\n    /*** TRY FUNCTIONS ***/\n    /*********************/\n\n    function try_createLoan(\n        address loanFactory,\n        address liquidityAsset,\n        address collateralAsset,\n        address flFactory,\n        address clFactory,\n        uint256[5] memory specs,\n        address[3] memory calcs\n    )\n        external returns (bool ok)\n    {\n        string memory sig = \"createLoan(address,address,address,address,uint256[5],address[3])\";\n        (ok,) = address(loanFactory).call(\n            abi.encodeWithSignature(sig, liquidityAsset, collateralAsset, flFactory, clFactory, specs, calcs)\n        );\n    }\n\n    function try_drawdown(address loan, uint256 amt) external returns (bool ok) {\n        string memory sig = \"drawdown(uint256)\";\n        (ok,) = address(loan).call(abi.encodeWithSignature(sig, amt));\n    }\n\n    function try_makePayment(address loan) external returns (bool ok) {\n        string memory sig = \"makePayment()\";\n        (ok,) = address(loan).call(abi.encodeWithSignature(sig));\n    }\n\n    function try_makeFullPayment(address loan) external returns (bool ok) {\n        string memory sig = \"makeFullPayment()\";\n        (ok,) = address(loan).call(abi.encodeWithSignature(sig));\n    }\n\n    function try_unwind(address loan) external returns (bool ok) {\n        string memory sig = \"unwind()\";\n        (ok,) = address(loan).call(abi.encodeWithSignature(sig));\n    }\n\n    function try_pull(address locker, address dst, uint256 amt) external returns (bool ok) {\n        string memory sig = \"pull(address,uint256)\";\n        (ok,) = address(locker).call(abi.encodeWithSignature(sig, dst, amt));\n    }\n\n    function try_setLoanAdmin(address loan, address newLoanAdmin, bool status) external returns (bool ok) {\n        string memory sig = \"setLoanAdmin(address,bool)\";\n        (ok,) = address(loan).call(abi.encodeWithSignature(sig, newLoanAdmin, status));\n    }\n\n    function try_pause(address target) external returns (bool ok) {\n        string memory sig = \"pause()\";\n        (ok,) = target.call(abi.encodeWithSignature(sig));\n    }\n\n    function try_unpause(address target) external returns (bool ok) {\n        string memory sig = \"unpause()\";\n        (ok,) = target.call(abi.encodeWithSignature(sig));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/user/Commoner.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\ncontract Commoner {\n\n    function try_setLiquidityCap(address pool, uint256 liquidityCap) external returns (bool ok) {\n        string memory sig = \"setLiquidityCap(uint256)\";\n        (ok,) = address(pool).call(abi.encodeWithSignature(sig, liquidityCap));\n    }\n\n    function try_triggerDefault(address loan) external returns (bool ok) {\n        string memory sig = \"triggerDefault()\";\n        (ok,) = loan.call(abi.encodeWithSignature(sig));\n    }\n\n    function try_setProtocolPause(address globals, bool pause) external returns (bool ok) {\n        string memory sig = \"setProtocolPause(bool)\";\n        (ok,) = globals.call(abi.encodeWithSignature(sig, pause));\n    }\n\n    function try_setManualOverride(address oracle, bool _override) external returns (bool ok) {\n        string memory sig = \"setManualOverride(bool)\";\n        (ok,) = oracle.call(abi.encodeWithSignature(sig, _override));\n    }\n\n    function try_setManualPrice(address oracle, int256 priceFeed) external returns (bool ok) {\n        string memory sig = \"setManualPrice(int256)\";\n        (ok,) = oracle.call(abi.encodeWithSignature(sig, priceFeed));\n    }\n\n    function try_changeAggregator(address oracle, address aggregator) external returns (bool ok) {\n        string memory sig = \"changeAggregator(address)\";\n        (ok,) = oracle.call(abi.encodeWithSignature(sig, aggregator));\n    }\n\n    function try_pause(address target) external returns (bool ok) {\n        string memory sig = \"pause()\";\n        (ok,) = target.call(abi.encodeWithSignature(sig));\n    }\n\n    function try_unpause(address target) external returns (bool ok) {\n        string memory sig = \"unpause()\";\n        (ok,) = target.call(abi.encodeWithSignature(sig));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/user/Farmer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./LP.sol\";\n\nimport \"../../MplRewards.sol\";\n\nimport \"../../interfaces/IPool.sol\";\n\ncontract Farmer is LP {\n\n    MplRewards public mplRewards;\n    IERC20     public poolFDT;\n\n    constructor(MplRewards _mplRewards, IERC20 _poolFDT) public {\n        mplRewards = _mplRewards;\n        poolFDT    = _poolFDT;\n    }\n\n    /************************/\n    /*** DIRECT FUNCTIONS ***/\n    /************************/\n\n    function approve(address account, uint256 amt) public {\n        poolFDT.approve(account, amt);\n    }\n\n    function increaseCustodyAllowance(address pool, address account, uint256 amt) public {\n        IPool(pool).increaseCustodyAllowance(account, amt);\n    }\n\n    function transfer(address asset, address to, uint256 amt) public {\n        IERC20(asset).transfer(to, amt);\n    }\n\n    function stake(uint256 amt) public {\n        mplRewards.stake(amt);\n    }\n\n    function withdraw(uint256 amt) public {\n        mplRewards.withdraw(amt);\n    }\n\n    function getReward() public {\n        mplRewards.getReward();\n    }\n\n    function exit() public {\n        mplRewards.exit();\n    }\n\n    /*********************/\n    /*** TRY FUNCTIONS ***/\n    /*********************/\n\n    function try_stake(uint256 amt) external returns (bool ok) {\n        string memory sig = \"stake(uint256)\";\n        (ok,) = address(mplRewards).call(abi.encodeWithSignature(sig, amt));\n    }\n\n    function try_withdraw(uint256 amt) external returns (bool ok) {\n        string memory sig = \"withdraw(uint256)\";\n        (ok,) = address(mplRewards).call(abi.encodeWithSignature(sig, amt));\n    }\n\n    function try_increaseCustodyAllowance(address pool, address account, uint256 amt) external returns (bool ok) {\n        string memory sig = \"increaseCustodyAllowance(address,uint256)\";\n        (ok,) = pool.call(abi.encodeWithSignature(sig, account, amt));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/user/Holder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../token/interfaces/IBaseFDT.sol\";\n\ncontract Holder {\n    function withdrawFunds(address token) external {\n        IBaseFDT(token).withdrawFunds();\n    }\n}\n"
    },
    "packages/protocol/contracts/test/user/LP.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/IPool.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract LP {\n\n    /************************/\n    /*** DIRECT FUNCTIONS ***/\n    /************************/\n\n    function approve(address token, address account, uint256 amt) external {\n        IERC20(token).approve(account, amt);\n    }\n\n    function withdraw(address pool, uint256 amt) external {\n        IPool(pool).withdraw(amt);\n    }\n\n    function deposit(address pool, uint256 amt) external {\n        IPool(pool).deposit(amt);\n    }\n\n    function transferFDT(address pool, address account, uint256 amt) external {\n        IPool(pool).transfer(account, amt);\n    }\n\n    function withdrawFunds(address pool) external {\n        IPool(pool).withdrawFunds();\n    }\n\n    function claim(address pool, address loan, address dlFactory) external { IPool(pool).claim(loan, dlFactory); }\n\n    function intendToWithdraw(address pool) external { IPool(pool).intendToWithdraw(); }\n\n    /*********************/\n    /*** TRY FUNCTIONS ***/\n    /*********************/\n\n    function try_deposit(address pool1, uint256 amt)  external returns (bool ok) {\n        string memory sig = \"deposit(uint256)\";\n        (ok,) = address(pool1).call(abi.encodeWithSignature(sig, amt));\n    }\n\n    function try_withdraw(address pool, uint256 amt) external returns (bool ok) {\n        string memory sig = \"withdraw(uint256)\";\n        (ok,) = pool.call(abi.encodeWithSignature(sig, amt));\n    }\n\n    function try_withdrawFunds(address pool) external returns (bool ok) {\n        string memory sig = \"withdrawFunds()\";\n        (ok,) = pool.call(abi.encodeWithSignature(sig));\n    }\n\n    function try_claim(address pool, address loan, address dlFactory) external returns (bool ok) {\n        string memory sig = \"claim(address,address)\";\n        (ok,) = pool.call(abi.encodeWithSignature(sig, loan, dlFactory));\n    }\n\n    function try_intendToWithdraw(address pool) external returns (bool ok) {\n        string memory sig = \"intendToWithdraw()\";\n        (ok,) = pool.call(abi.encodeWithSignature(sig));\n    }\n\n    function try_cancelWithdraw(address pool) external returns (bool ok) {\n        string memory sig = \"cancelWithdraw()\";\n        (ok,) = pool.call(abi.encodeWithSignature(sig));\n    }\n\n    function try_transfer(address pool, address account, uint256 amt) external returns (bool ok) {\n        string memory sig = \"transfer(address,uint256)\";\n        (ok,) = pool.call(abi.encodeWithSignature(sig, account, amt));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/user/PoolDelegate.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/IBPool.sol\";\nimport \"../../interfaces/ILoan.sol\";\nimport \"../../interfaces/IPool.sol\";\nimport \"../../interfaces/IPoolFactory.sol\";\nimport \"../../interfaces/IStakeLocker.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract PoolDelegate {\n\n    /************************/\n    /*** DIRECT FUNCTIONS ***/\n    /************************/\n\n    function createPool(\n        address poolFactory,\n        address liquidityAsset,\n        address stakeAsset,\n        address slFactory,\n        address llFactory,\n        uint256 stakingFee,\n        uint256 delegateFee,\n        uint256 liquidityCap\n    )\n        external returns (address liquidityPool)\n    {\n        liquidityPool = IPoolFactory(poolFactory).createPool(\n            liquidityAsset,\n            stakeAsset,\n            slFactory,\n            llFactory,\n            stakingFee,\n            delegateFee,\n            liquidityCap\n        );\n    }\n\n    function approve(address token, address account, uint256 amt) external {\n        IERC20(token).approve(account, amt);\n    }\n\n    function stake(address stakeLocker, uint256 amt) external {\n        IStakeLocker(stakeLocker).stake(amt);\n    }\n\n    function finalize(address pool) external {\n        IPool(pool).finalize();\n    }\n\n    function unstake(address stakeLocker, uint256 amt) external {\n        IStakeLocker(stakeLocker).unstake(amt);\n    }\n\n    function fundLoan(address pool, address loan, address dlFactory, uint256 amt) external {\n        IPool(pool).fundLoan(loan, dlFactory, amt);\n    }\n\n    function unwind(address loan) external {\n        ILoan(loan).unwind();\n    }\n\n    function claim(address pool, address loan, address dlFactory) external returns (uint256[7] memory) {\n        return IPool(pool).claim(loan, dlFactory);\n    }\n\n    function deactivate(address pool) external {\n        IPool(pool).deactivate();\n    }\n\n    function triggerDefault(address pool, address loan, address dlFactory) external {\n        IPool(pool).triggerDefault(loan, dlFactory);\n    }\n\n    function setPoolAdmin(address pool, address newPoolAdmin, bool status) external {\n        IPool(pool).setPoolAdmin(newPoolAdmin, status);\n    }\n\n    function setOpenToPublic(address pool, bool open) external {\n        IPool(pool).setOpenToPublic(open);\n    }\n\n    function setLockupPeriod(address pool, uint256 lockupPeriod) external {\n        IPool(pool).setLockupPeriod(lockupPeriod);\n    }\n\n    function setStakeLockerLockupPeriod(address stakeLocker, uint256 lockupPeriod) external {\n        IStakeLocker(stakeLocker).setLockupPeriod(lockupPeriod);\n    }\n\n    function setStakingFee(address pool, uint256 stakingFee) external {\n        IPool(pool).setStakingFee(stakingFee);\n    }\n\n    function setAllowList(address pool, address account, bool status) external {\n        IPool(pool).setAllowList(account, status);\n    }\n\n    function openStakeLockerToPublic(address stakeLocker) external {\n        IStakeLocker(stakeLocker).openStakeLockerToPublic();\n    }\n\n    function setAllowlist(address stakeLocker, address account, bool status) external {\n        IStakeLocker(stakeLocker).setAllowlist(account, status);\n    }\n\n    // Balancer Pool\n    function joinBPool(IBPool bPool, uint poolAmountOut, uint[] calldata maxAmountsIn) external {\n        bPool.joinPool(poolAmountOut, maxAmountsIn);\n    }\n\n    /*********************/\n    /*** TRY FUNCTIONS ***/\n    /*********************/\n\n    function try_createPool(\n        address poolFactory,\n        address liquidityAsset,\n        address stakeAsset,\n        address slFactory,\n        address llFactory,\n        uint256 stakingFee,\n        uint256 delegateFee,\n        uint256 liquidityCap\n    )\n        external returns (bool ok)\n    {\n        string memory sig = \"createPool(address,address,address,address,uint256,uint256,uint256)\";\n        (ok,) = address(poolFactory).call(\n            abi.encodeWithSignature(sig, liquidityAsset, stakeAsset, slFactory, llFactory, stakingFee, delegateFee, liquidityCap)\n        );\n    }\n\n    function try_fundLoan(address pool, address loan, address dlFactory, uint256 amt) external returns (bool ok) {\n        string memory sig = \"fundLoan(address,address,uint256)\";\n        (ok,) = address(pool).call(abi.encodeWithSignature(sig, loan, dlFactory, amt));\n    }\n\n    function try_unwind(address loan) external returns (bool ok) {\n        string memory sig = \"unwind()\";\n        (ok,) = address(loan).call(abi.encodeWithSignature(sig));\n    }\n\n    function try_claim(address pool, address loan, address dlFactory) external returns (bool ok) {\n        string memory sig = \"claim(address,address)\";\n        (ok,) = address(pool).call(abi.encodeWithSignature(sig, loan, dlFactory));\n    }\n\n    function try_finalize(address pool) external returns (bool ok) {\n        string memory sig = \"finalize()\";\n        (ok,) = address(pool).call(abi.encodeWithSignature(sig));\n    }\n\n    function try_deactivate(address pool) external returns (bool ok) {\n        string memory sig = \"deactivate()\";\n        (ok,) = address(pool).call(abi.encodeWithSignature(sig));\n    }\n\n    function try_setLiquidityCap(address pool, uint256 liquidityCap) external returns (bool ok) {\n        string memory sig = \"setLiquidityCap(uint256)\";\n        (ok,) = address(pool).call(abi.encodeWithSignature(sig, liquidityCap));\n    }\n\n    function try_setLockupPeriod(address pool, uint256 newPeriod) external returns (bool ok) {\n        string memory sig = \"setLockupPeriod(uint256)\";\n        (ok,) = address(pool).call(abi.encodeWithSignature(sig, newPeriod));\n    }\n\n    function try_setStakingFee(address pool, uint256 newStakingFee) external returns (bool ok) {\n        string memory sig = \"setStakingFee(uint256)\";\n        (ok,) = address(pool).call(abi.encodeWithSignature(sig, newStakingFee));\n    }\n\n    function try_triggerDefault(address pool, address loan, address dlFactory) external returns (bool ok) {\n        string memory sig = \"triggerDefault(address,address)\";\n        (ok,) = address(pool).call(abi.encodeWithSignature(sig, loan, dlFactory));\n    }\n\n    function try_setOpenToPublic(address pool, bool open) external returns (bool ok) {\n        string memory sig = \"setOpenToPublic(bool)\";\n        (ok,) = address(pool).call(abi.encodeWithSignature(sig, open));\n    }\n\n    function try_openStakeLockerToPublic(address stakeLocker) external returns (bool ok) {\n        string memory sig = \"openStakeLockerToPublic()\";\n        (ok,) = address(stakeLocker).call(abi.encodeWithSignature(sig));\n    }\n\n    function try_setAllowList(address pool, address account, bool status) external returns (bool ok) {\n        string memory sig = \"setAllowList(address,bool)\";\n        (ok,) = address(pool).call(abi.encodeWithSignature(sig, account, status));\n    }\n\n    function try_setAllowlist(address stakeLocker, address account, bool status) external returns (bool ok) {\n        string memory sig = \"setAllowlist(address,bool)\";\n        (ok,) = address(stakeLocker).call(abi.encodeWithSignature(sig, account, status));\n    }\n\n    function try_setPoolAdmin(address pool, address newPoolAdmin, bool status) external returns (bool ok) {\n        string memory sig = \"setPoolAdmin(address,bool)\";\n        (ok,) = address(pool).call(abi.encodeWithSignature(sig, newPoolAdmin, status));\n    }\n\n    function try_pause(address target) external returns (bool ok) {\n        string memory sig = \"pause()\";\n        (ok,) = target.call(abi.encodeWithSignature(sig));\n    }\n\n    function try_unpause(address target) external returns (bool ok) {\n        string memory sig = \"unpause()\";\n        (ok,) = target.call(abi.encodeWithSignature(sig));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/user/Staker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/IBPool.sol\";\nimport \"../../interfaces/IStakeLocker.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Staker {\n\n    /************************/\n    /*** DIRECT FUNCTIONS ***/\n    /************************/\n\n    function approve(address token, address account, uint256 amt) external {\n        IERC20(token).approve(account, amt);\n    }\n\n    function increaseCustodyAllowance(address stakeLocker, address account, uint256 amt) public {\n        IStakeLocker(stakeLocker).increaseCustodyAllowance(account, amt);\n    }\n\n    function stake(address stakeLocker, uint256 amt) external {\n        IStakeLocker(stakeLocker).stake(amt);\n    }\n\n    function unstake(address stakeLocker, uint256 amt) external {\n        IStakeLocker(stakeLocker).unstake(amt);\n    }\n\n    function transfer(address token, address dst, uint256 amt) external {\n        IERC20(token).transfer(dst, amt);\n    }\n\n    function intendToUnstake(address stakeLocker) external { IStakeLocker(stakeLocker).intendToUnstake(); }\n\n    // Balancer Pool\n    function joinBPool(IBPool bPool, uint poolAmountOut, uint[] calldata maxAmountsIn) external {\n        bPool.joinPool(poolAmountOut, maxAmountsIn);\n    }\n\n\n    /*********************/\n    /*** TRY FUNCTIONS ***/\n    /*********************/\n\n    function try_stake(address stakeLocker, uint256 amt) external returns (bool ok) {\n        string memory sig = \"stake(uint256)\";\n        (ok,) = address(stakeLocker).call(abi.encodeWithSignature(sig, amt));\n    }\n\n    function try_unstake(address stakeLocker, uint256 amt) external returns (bool ok) {\n        string memory sig = \"unstake(uint256)\";\n        (ok,) = address(stakeLocker).call(abi.encodeWithSignature(sig, amt));\n    }\n\n    function try_transfer(address token, address dst, uint256 amt) external returns (bool ok) {\n        string memory sig = \"transfer(address,uint256)\";\n        (ok,) = address(token).call(abi.encodeWithSignature(sig, dst, amt));\n    }\n\n    function try_transferFrom(address token, address from, address to, uint256 amt) external returns (bool ok) {\n        string memory sig = \"transferFrom(address,address,uint256)\";\n        (ok,) = address(token).call(abi.encodeWithSignature(sig, from, to, amt));\n    }\n\n    function try_intendToUnstake(address stakeLocker) external returns (bool ok) {\n        string memory sig = \"intendToUnstake()\";\n        (ok,) = stakeLocker.call(abi.encodeWithSignature(sig));\n    }\n\n    function try_cancelUnstake(address stakeLocker) external returns (bool ok) {\n        string memory sig = \"cancelUnstake()\";\n        (ok,) = stakeLocker.call(abi.encodeWithSignature(sig));\n    }\n\n    function try_withdrawFunds(address stakeLocker) external returns (bool ok) {\n        string memory sig = \"withdrawFunds()\";\n        (ok,) = stakeLocker.call(abi.encodeWithSignature(sig));\n    }\n\n    function try_increaseCustodyAllowance(address stakeLocker, address account, uint256 amt) external returns (bool ok) {\n        string memory sig = \"increaseCustodyAllowance(address,uint256)\";\n        (ok,) = stakeLocker.call(abi.encodeWithSignature(sig, account, amt));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/user/Governor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../MapleGlobals.sol\";\nimport \"../../MapleTreasury.sol\";\nimport \"../../MplRewards.sol\";\nimport \"../../MplRewardsFactory.sol\";\n\ncontract Governor {\n\n    /************************/\n    /*** DIRECT FUNCTIONS ***/\n    /************************/\n\n    MapleGlobals      globals;\n    MplRewards        mplRewards;\n    MplRewardsFactory mplRewardsFactory;\n    MapleTreasury     treasury;\n\n    function createGlobals(address mpl) external returns (MapleGlobals) {\n        globals = new MapleGlobals(address(this), mpl, address(1));\n        return globals;\n    }\n\n    function createMplRewardsFactory() external returns (MplRewardsFactory) {\n        mplRewardsFactory = new MplRewardsFactory(address(globals));\n        return mplRewardsFactory;\n    }\n\n    function createMplRewards(address mpl, address pool) external returns (MplRewards) {\n        mplRewards = MplRewards(mplRewardsFactory.createMplRewards(mpl, pool));\n        return mplRewards;\n    }\n\n    // Used for \"fake\" governors pointing at a globals contract they didn't create\n    function setGovGlobals(MapleGlobals _globals) external {\n        globals = _globals;\n    }\n\n    function setGovMplRewardsFactory(MplRewardsFactory _mplRewardsFactory) external {\n        mplRewardsFactory = _mplRewardsFactory;\n    }\n\n    // Used for \"fake\" governors pointing at a staking rewards contract they don't own\n    function setGovMplRewards(MplRewards _mplRewards) external {\n        mplRewards = _mplRewards;\n    }\n\n    // Used for \"fake\" governors pointing at a treasury contract they didn't create\n    function setGovTreasury(MapleTreasury _treasury) external {\n        treasury = _treasury;\n    }\n\n    function transfer(IERC20 token, address account, uint256 amt) external {\n        token.transfer(account, amt);\n    }\n\n    /*** MapleGlobals Setters ***/\n    function setCalc(address calc, bool valid)                                 external { globals.setCalc(calc, valid); }\n    function setCollateralAsset(address asset, bool valid)                     external { globals.setCollateralAsset(asset, valid); }\n    function setLiquidityAsset(address asset, bool valid)                      external { globals.setLiquidityAsset(asset, valid); }\n    function setValidLoanFactory(address factory, bool valid)                  external { globals.setValidLoanFactory(factory, valid); }\n    function setValidPoolFactory(address factory, bool valid)                  external { globals.setValidPoolFactory(factory, valid); }\n    function setValidSubFactory(address fac, address sub, bool valid)          external { globals.setValidSubFactory(fac, sub, valid); }\n    function setMapleTreasury(address _treasury)                               external { globals.setMapleTreasury(_treasury); }\n    function setGlobalAdmin(address _globalAdmin)                              external { globals.setGlobalAdmin(_globalAdmin); }\n    function setPoolDelegateAllowlist(address pd, bool valid)                  external { globals.setPoolDelegateAllowlist(pd, valid); }\n    function setInvestorFee(uint256 fee)                                       external { globals.setInvestorFee(fee); }\n    function setTreasuryFee(uint256 fee)                                       external { globals.setTreasuryFee(fee); }\n    function setDefaultGracePeriod(uint256 period)                             external { globals.setDefaultGracePeriod(period); }\n    function setFundingPeriod(uint256 period)                                  external { globals.setFundingPeriod(period); }\n    function setSwapOutRequired(uint256 swapAmt)                               external { globals.setSwapOutRequired(swapAmt); }\n    function setPendingGovernor(address gov)                                   external { globals.setPendingGovernor(gov); }\n    function acceptGovernor()                                                  external { globals.acceptGovernor(); }\n    function setPriceOracle(address asset, address oracle)                     external { globals.setPriceOracle(asset, oracle); }\n    function setMaxSwapSlippage(uint256 newSlippage)                           external { globals.setMaxSwapSlippage(newSlippage); }\n    function setDefaultUniswapPath(address from, address to, address mid)      external { globals.setDefaultUniswapPath(from, to, mid); }\n    function setValidBalancerPool(address balancerPool, bool valid)            external { globals.setValidBalancerPool(balancerPool, valid); }\n    function setLpCooldownPeriod(uint256 period)                               external { globals.setLpCooldownPeriod(period); }\n    function setStakerCooldownPeriod(uint256 period)                           external { globals.setStakerCooldownPeriod(period); }\n    function setLpWithdrawWindow(uint256 period)                               external { globals.setLpWithdrawWindow(period); }\n    function setStakerUnstakeWindow(uint256 period)                            external { globals.setStakerUnstakeWindow(period); }\n\n    /*** MapleTreasury Functions ***/\n    function setGlobals(address newGlobals)              external { treasury.setGlobals(newGlobals); }\n    function reclaimERC20(address asset, uint256 amount) external { treasury.reclaimERC20(asset, amount); }\n    function distributeToHolders()                       external { treasury.distributeToHolders(); }\n    function convertERC20(address asset)                 external { treasury.convertERC20(asset); }\n\n    /*** MplRewards Setters ***/\n    function transferOwnership(address newOwner)      external { mplRewards.transferOwnership(newOwner); }\n    function notifyRewardAmount(uint256 reward)       external { mplRewards.notifyRewardAmount(reward); }\n    function updatePeriodFinish(uint256 timestamp)    external { mplRewards.updatePeriodFinish(timestamp); }\n    function recoverERC20(address asset, uint256 amt) external { mplRewards.recoverERC20(asset, amt); }\n    function setRewardsDuration(uint256 duration)     external { mplRewards.setRewardsDuration(duration); }\n    function setPaused(bool paused)                   external { mplRewards.setPaused(paused); }\n\n\n    /*********************/\n    /*** TRY FUNCTIONS ***/\n    /*********************/\n\n    /*** MapleGlobals Setters ***/\n    function try_setGlobals(address target, address _globals) external returns (bool ok) {\n        string memory sig = \"setGlobals(address)\";\n        (ok,) = address(target).call(abi.encodeWithSignature(sig, _globals));\n    }\n    function try_createMplRewards(address mpl, address pool) external returns (bool ok) {\n        string memory sig = \"createMplRewards(address,address)\";\n        (ok,) = address(mplRewardsFactory).call(abi.encodeWithSignature(sig, mpl, pool));\n    }\n    function try_setDefaultUniswapPath(address from, address to, address mid) external returns (bool ok) {\n        string memory sig = \"setDefaultUniswapPath(address,address,address)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, from, to, mid));\n    }\n    function try_setCalc(address calc, bool valid) external returns (bool ok) {\n        string memory sig = \"setCalc(address,bool)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, calc, valid));\n    }\n    function try_setCollateralAsset(address asset, bool valid) external returns (bool ok) {\n        string memory sig = \"setCollateralAsset(address,bool)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, asset, valid));\n    }\n    function try_setLiquidityAsset(address asset, bool valid) external returns (bool ok) {\n        string memory sig = \"setLiquidityAsset(address,bool)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, asset, valid));\n    }\n    function try_setValidLoanFactory(address factory, bool valid) external returns (bool ok) {\n        string memory sig = \"setValidLoanFactory(address,bool)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, factory, valid));\n    }\n    function try_setValidPoolFactory(address factory, bool valid) external returns (bool ok) {\n        string memory sig = \"setValidPoolFactory(address,bool)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, factory, valid));\n    }\n    function try_setValidSubFactory(address fac, address sub, bool valid) external returns (bool ok) {\n        string memory sig = \"setValidSubFactory(address,address,bool)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, fac, sub, valid));\n    }\n    function try_setMapleTreasury(address _treasury) external returns (bool ok) {\n        string memory sig = \"setMapleTreasury(address)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, _treasury));\n    }\n    function try_setPoolDelegateAllowlist(address pd, bool valid) external returns (bool ok) {\n        string memory sig = \"setPoolDelegateAllowlist(address,bool)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, pd, valid));\n    }\n    function try_setInvestorFee(uint256 fee) external returns (bool ok) {\n        string memory sig = \"setInvestorFee(uint256)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, fee));\n    }\n    function try_setTreasuryFee(uint256 fee) external returns (bool ok) {\n        string memory sig = \"setTreasuryFee(uint256)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, fee));\n    }\n    function try_setDefaultGracePeriod(uint256 defaultGracePeriod) external returns (bool ok) {\n        string memory sig = \"setDefaultGracePeriod(uint256)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, defaultGracePeriod));\n    }\n    function try_setFundingPeriod(uint256 fundingPeriod) external returns (bool ok) {\n        string memory sig = \"setFundingPeriod(uint256)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, fundingPeriod));\n    }\n    function try_setSwapOutRequired(uint256 swapAmt) external returns (bool ok) {\n        string memory sig = \"setSwapOutRequired(uint256)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, swapAmt));\n    }\n    function try_setPendingGovernor(address pendingGov) external returns (bool ok) {\n        string memory sig = \"setPendingGovernor(address)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, pendingGov));\n    }\n    function try_acceptGovernor() external returns (bool ok) {\n        string memory sig = \"acceptGovernor()\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig));\n    }\n    function try_setPriceOracle(address asset, address oracle) external returns (bool ok) {\n        string memory sig = \"setPriceOracle(address,address)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, asset, oracle));\n    }\n    function try_setMaxSwapSlippage(uint256 newSlippage) external returns (bool ok) {\n        string memory sig = \"setMaxSwapSlippage(uint256)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, newSlippage));\n    }\n    function try_setValidBalancerPool(address balancerPool, bool valid) external returns (bool ok) {\n        string memory sig = \"setValidBalancerPool(address,bool)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, balancerPool, valid));\n    }\n    function try_setMinLoanEquity(uint256 newLiquidity) external returns (bool ok) {\n        string memory sig = \"setMinLoanEquity(uint256)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, newLiquidity));\n    }\n    function try_setLpCooldownPeriod(uint256 period) external returns (bool ok) {\n        string memory sig = \"setLpCooldownPeriod(uint256)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, period));\n    }\n    function try_setStakerCooldownPeriod(uint256 period) external returns (bool ok) {\n        string memory sig = \"setStakerCooldownPeriod(uint256)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, period));\n    }\n    function try_setLpWithdrawWindow(uint256 period) external returns (bool ok) {\n        string memory sig = \"setLpWithdrawWindow(uint256)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, period));\n    }\n    function try_setStakerUnstakeWindow(uint256 period) external returns (bool ok) {\n        string memory sig = \"setStakerUnstakeWindow(uint256)\";\n        (ok,) = address(globals).call(abi.encodeWithSignature(sig, period));\n    }\n\n    /*** MplRewards Setters ***/\n    function try_transferOwnership(address newOwner) external returns (bool ok) {\n        string memory sig = \"transferOwnership(address)\";\n        (ok,) = address(mplRewards).call(abi.encodeWithSignature(sig, newOwner));\n    }\n    function try_notifyRewardAmount(uint256 reward) external returns (bool ok) {\n        string memory sig = \"notifyRewardAmount(uint256)\";\n        (ok,) = address(mplRewards).call(abi.encodeWithSignature(sig, reward));\n    }\n    function try_updatePeriodFinish(uint256 timestamp) external returns (bool ok) {\n        string memory sig = \"updatePeriodFinish(uint256)\";\n        (ok,) = address(mplRewards).call(abi.encodeWithSignature(sig, timestamp));\n    }\n    function try_recoverERC20(address asset, uint256 amt) external returns (bool ok) {\n        string memory sig = \"recoverERC20(address,uint256)\";\n        (ok,) = address(mplRewards).call(abi.encodeWithSignature(sig, asset, amt));\n    }\n    function try_setRewardsDuration(uint256 duration) external returns (bool ok) {\n        string memory sig = \"setRewardsDuration(uint256)\";\n        (ok,) = address(mplRewards).call(abi.encodeWithSignature(sig, duration));\n    }\n    function try_setPaused(bool paused) external returns (bool ok) {\n        string memory sig = \"setPaused(bool)\";\n        (ok,) = address(mplRewards).call(abi.encodeWithSignature(sig, paused));\n    }\n\n    /*** Treasury Functions ***/\n    function try_setGlobals(address newGlobals) external returns (bool ok) {\n        string memory sig = \"setGlobals(address)\";\n        (ok,) = address(treasury).call(abi.encodeWithSignature(sig, newGlobals));\n    }\n    function try_reclaimERC20_treasury(address asset, uint256 amount) external returns (bool ok) {\n        string memory sig = \"reclaimERC20(address,uint256)\";\n        (ok,) = address(treasury).call(abi.encodeWithSignature(sig, asset, amount));\n    }\n    function try_distributeToHolders() external returns (bool ok) {\n        string memory sig = \"distributeToHolders()\";\n        (ok,) = address(treasury).call(abi.encodeWithSignature(sig));\n    }\n    function try_convertERC20(address asset) external returns (bool ok) {\n        string memory sig = \"convertERC20(address)\";\n        (ok,) = address(treasury).call(abi.encodeWithSignature(sig, asset));\n    }\n\n    /*** Pool Functions ***/\n    function try_reclaimERC20(address target, address token) external returns (bool ok) {\n        string memory sig = \"reclaimERC20(address)\";\n        (ok,) = target.call(abi.encodeWithSignature(sig, token));\n    }\n\n    /*** PoolFactory/LoanFactory Functions ***/\n    function try_pause(address target) external returns (bool ok) {\n        string memory sig = \"pause()\";\n        (ok,) = target.call(abi.encodeWithSignature(sig));\n    }\n    function try_unpause(address target) external returns (bool ok) {\n        string memory sig = \"unpause()\";\n        (ok,) = target.call(abi.encodeWithSignature(sig));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/user/SecurityAdmin.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/IOracle.sol\";\nimport \"../../interfaces/IPool.sol\";\nimport \"../../oracles/ChainlinkOracle.sol\";\n\ncontract SecurityAdmin {\n\n    function claim(address pool, address loan, address dlFactory) external { IPool(pool).claim(loan, dlFactory); }\n    function setManualPrice(address target, int256 price)         external { IOracle(target).setManualPrice(price); }\n    function setManualOverride(address target, bool _override)    external { IOracle(target).setManualOverride(_override); }\n    function changeAggregator(address target, address aggregator) external { IOracle(target).changeAggregator(aggregator); }\n\n    function try_claim(address pool, address loan, address dlFactory) external returns (bool ok) {\n        string memory sig = \"claim(address,address)\";\n        (ok,) = pool.call(abi.encodeWithSignature(sig, loan, dlFactory));\n    }\n\n    function try_setManualPrice(address oracle, int256 priceFeed) external returns (bool ok) {\n        string memory sig = \"setManualPrice(int256)\";\n        (ok,) = oracle.call(abi.encodeWithSignature(sig, priceFeed));\n    }\n\n    function try_setManualOverride(address oracle, bool _override) external returns (bool ok) {\n        string memory sig = \"setManualOverride(bool)\";\n        (ok,) = oracle.call(abi.encodeWithSignature(sig, _override));\n    }\n\n    function try_changeAggregator(address oracle, address aggregator) external returns (bool ok) {\n        string memory sig = \"changeAggregator(address)\";\n        (ok,) = oracle.call(abi.encodeWithSignature(sig, aggregator));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/user/EmergencyAdmin.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\ncontract EmergencyAdmin {\n   function try_setProtocolPause(address globals, bool pause) external returns (bool ok) {\n        string memory sig = \"setProtocolPause(bool)\";\n        (ok,) = globals.call(abi.encodeWithSignature(sig, pause));\n    }\n}\n"
    },
    "packages/protocol/contracts/MapleGlobals.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IERC20Details.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/ISubFactory.sol\";\n\ninterface ICalc { function calcType() external view returns (uint8); }\n\n/// @title MapleGlobals maintains a central source of parameters and allowlists for the Maple protocol.\ncontract MapleGlobals {\n\n    using SafeMath for uint256;\n\n    address public immutable mpl;         // The ERC-2222 Maple Token for the Maple protocol.\n\n    address public pendingGovernor;       // The Governor that is declared for governorship transfer. Must be accepted for transfer to take effect.\n    address public governor;              // The Governor responsible for management of global Maple variables.\n    address public mapleTreasury;         // The MapleTreasury is the Treasury where all fees pass through for conversion, prior to distribution.\n    address public globalAdmin;           // The Global Admin of the whole network. Has the power to switch off/on the functionality of entire protocol.\n\n    uint256 public defaultGracePeriod;    // Represents the amount of time a Borrower has to make a missed payment before a default can be triggered.\n    uint256 public swapOutRequired;       // Represents minimum amount of Pool cover that a Pool Delegate has to provide before they can finalize a Pool.\n    uint256 public fundingPeriod;         // Amount of time to allow a Borrower to drawdown on their Loan after funding period ends.\n    uint256 public investorFee;           // Portion of drawdown that goes to the Pool Delegates and individual Lenders.\n    uint256 public treasuryFee;           // Portion of drawdown that goes to the MapleTreasury.\n    uint256 public maxSwapSlippage;       // Maximum amount of slippage for Uniswap transactions.\n    uint256 public minLoanEquity;         // Minimum amount of LoanFDTs required to trigger liquidations (basis points percentage of totalSupply).\n    uint256 public stakerCooldownPeriod;  // Period (in secs) after which Stakers are allowed to unstake  their BPTs  from a StakeLocker.\n    uint256 public lpCooldownPeriod;      // Period (in secs) after which LPs     are allowed to withdraw their funds from a Pool.\n    uint256 public stakerUnstakeWindow;   // Window of time (in secs) after `stakerCooldownPeriod` that an account has to withdraw before their intent to unstake  is invalidated.\n    uint256 public lpWithdrawWindow;      // Window of time (in secs) after `lpCooldownPeriod`     that an account has to withdraw before their intent to withdraw is invalidated.\n\n    bool public protocolPaused;  // Switch to pause the functionality of the entire protocol.\n\n    mapping(address => bool) public isValidLiquidityAsset;            // Mapping of valid Liquidity Assets.\n    mapping(address => bool) public isValidCollateralAsset;           // Mapping of valid Collateral Assets.\n    mapping(address => bool) public validCalcs;                       // Mapping of valid Calculators\n    mapping(address => bool) public isValidPoolDelegate;              // Mapping of valid Pool Delegates (prevent unauthorized/unknown addresses from creating Pools).\n    mapping(address => bool) public isValidBalancerPool;              // Mapping of valid Balancer Pools that Maple has approved for BPT staking.\n\n    // Determines the liquidation path of various assets in Loans and the Treasury.\n    // The value provided will determine whether or not to perform a bilateral or triangular swap on Uniswap.\n    // For example, `defaultUniswapPath[WBTC][USDC]` value would indicate what asset to convert WBTC into before conversion to USDC.\n    // If `defaultUniswapPath[WBTC][USDC] == USDC`, then the swap is bilateral and no middle asset is swapped.\n    // If `defaultUniswapPath[WBTC][USDC] == WETH`, then swap WBTC for WETH, then WETH for USDC.\n    mapping(address => mapping(address => address)) public defaultUniswapPath;\n\n    mapping(address => address) public oracleFor;  // Chainlink oracle for a given asset.\n\n    mapping(address => bool)                     public isValidPoolFactory;  // Mapping of valid Pool Factories.\n    mapping(address => bool)                     public isValidLoanFactory;  // Mapping of valid Loan Factories.\n    mapping(address => mapping(address => bool)) public validSubFactories;   // Mapping of valid sub factories.\n\n    event                     Initialized();\n    event              CollateralAssetSet(address asset, uint256 decimals, string symbol, bool valid);\n    event               LiquidityAssetSet(address asset, uint256 decimals, string symbol, bool valid);\n    event                       OracleSet(address asset, address oracle);\n    event TransferRestrictionExemptionSet(address indexed exemptedContract, bool valid);\n    event                 BalancerPoolSet(address balancerPool, bool valid);\n    event              PendingGovernorSet(address indexed pendingGovernor);\n    event                GovernorAccepted(address indexed governor);\n    event                 GlobalsParamSet(bytes32 indexed which, uint256 value);\n    event               GlobalsAddressSet(bytes32 indexed which, address addr);\n    event                  ProtocolPaused(bool pause);\n    event                  GlobalAdminSet(address indexed newGlobalAdmin);\n    event                 PoolDelegateSet(address indexed delegate, bool valid);\n\n    /**\n        @dev Checks that `msg.sender` is the Governor.\n    */\n    modifier isGovernor() {\n        require(msg.sender == governor, \"MG:NOT_GOV\");\n        _;\n    }\n\n    /**\n        @dev   Constructor function.\n        @dev   It emits an `Initialized` event.\n        @param _governor    Address of Governor.\n        @param _mpl         Address of the ERC-2222 Maple Token for the Maple protocol.\n        @param _globalAdmin Address the Global Admin.\n    */\n    constructor(address _governor, address _mpl, address _globalAdmin) public {\n        governor             = _governor;\n        mpl                  = _mpl;\n        swapOutRequired      = 10_000;     // $10,000 of Pool cover\n        fundingPeriod        = 10 days;\n        defaultGracePeriod   = 5 days;\n        investorFee          = 50;         // 0.5 %\n        treasuryFee          = 50;         // 0.5 %\n        maxSwapSlippage      = 1000;       // 10 %\n        minLoanEquity        = 2000;       // 20 %\n        globalAdmin          = _globalAdmin;\n        stakerCooldownPeriod = 10 days;\n        lpCooldownPeriod     = 10 days;\n        stakerUnstakeWindow  = 2 days;\n        lpWithdrawWindow     = 2 days;\n        emit Initialized();\n    }\n\n    /************************/\n    /*** Setter Functions ***/\n    /************************/\n\n    /**\n        @dev  Sets the Staker cooldown period. This change will affect the existing cool down period for the Stakers that already intended to unstake.\n              Only the Governor can call this function.\n        @dev  It emits a `GlobalsParamSet` event.\n        @param newCooldownPeriod New value for the cool down period.\n    */\n    function setStakerCooldownPeriod(uint256 newCooldownPeriod) external isGovernor {\n        stakerCooldownPeriod = newCooldownPeriod;\n        emit GlobalsParamSet(\"STAKER_COOLDOWN_PERIOD\", newCooldownPeriod);\n    }\n\n    /**\n        @dev   Sets the Liquidity Pool cooldown period. This change will affect the existing cool down period for the LPs that already intended to withdraw.\n               Only the Governor can call this function.\n        @dev   It emits a `GlobalsParamSet` event.\n        @param newCooldownPeriod New value for the cool down period.\n    */\n    function setLpCooldownPeriod(uint256 newCooldownPeriod) external isGovernor {\n        lpCooldownPeriod = newCooldownPeriod;\n        emit GlobalsParamSet(\"LP_COOLDOWN_PERIOD\", newCooldownPeriod);\n    }\n\n    /**\n        @dev   Sets the Staker unstake window. This change will affect the existing window for the Stakers that already intended to unstake.\n               Only the Governor can call this function.\n        @dev   It emits a `GlobalsParamSet` event.\n        @param newUnstakeWindow New value for the unstake window.\n    */\n    function setStakerUnstakeWindow(uint256 newUnstakeWindow) external isGovernor {\n        stakerUnstakeWindow = newUnstakeWindow;\n        emit GlobalsParamSet(\"STAKER_UNSTAKE_WINDOW\", newUnstakeWindow);\n    }\n\n    /**\n        @dev   Sets the Liquidity Pool withdraw window. This change will affect the existing window for the LPs that already intended to withdraw.\n               Only the Governor can call this function.\n        @dev   It emits a `GlobalsParamSet` event.\n        @param newLpWithdrawWindow New value for the withdraw window.\n    */\n    function setLpWithdrawWindow(uint256 newLpWithdrawWindow) external isGovernor {\n        lpWithdrawWindow = newLpWithdrawWindow;\n        emit GlobalsParamSet(\"LP_WITHDRAW_WINDOW\", newLpWithdrawWindow);\n    }\n\n    /**\n        @dev   Sets the allowed Uniswap slippage percentage, in basis points. Only the Governor can call this function.\n        @dev   It emits a `GlobalsParamSet` event.\n        @param newMaxSlippage New max slippage percentage (in basis points)\n    */\n    function setMaxSwapSlippage(uint256 newMaxSlippage) external isGovernor {\n        _checkPercentageRange(newMaxSlippage);\n        maxSwapSlippage = newMaxSlippage;\n        emit GlobalsParamSet(\"MAX_SWAP_SLIPPAGE\", newMaxSlippage);\n    }\n\n    /**\n      @dev   Sets the Global Admin. Only the Governor can call this function.\n      @dev   It emits a `GlobalAdminSet` event.\n      @param newGlobalAdmin New global admin address.\n    */\n    function setGlobalAdmin(address newGlobalAdmin) external {\n        require(msg.sender == governor && newGlobalAdmin != address(0), \"MG:NOT_GOV_OR_ADMIN\");\n        require(!protocolPaused, \"MG:PROTO_PAUSED\");\n        globalAdmin = newGlobalAdmin;\n        emit GlobalAdminSet(newGlobalAdmin);\n    }\n\n    /**\n        @dev   Sets the validity of a Balancer Pool. Only the Governor can call this function.\n        @dev   It emits a `BalancerPoolSet` event.\n        @param balancerPool Address of Balancer Pool contract.\n        @param valid        The new validity status of a Balancer Pool.\n    */\n    function setValidBalancerPool(address balancerPool, bool valid) external isGovernor {\n        isValidBalancerPool[balancerPool] = valid;\n        emit BalancerPoolSet(balancerPool, valid);\n    }\n\n    /**\n      @dev   Sets the paused/unpaused state of the protocol. Only the Global Admin can call this function.\n      @dev   It emits a `ProtocolPaused` event.\n      @param pause Boolean flag to switch externally facing functionality in the protocol on/off.\n    */\n    function setProtocolPause(bool pause) external {\n        require(msg.sender == globalAdmin, \"MG:NOT_ADMIN\");\n        protocolPaused = pause;\n        emit ProtocolPaused(pause);\n    }\n\n    /**\n        @dev   Sets the validity of a PoolFactory. Only the Governor can call this function.\n        @param poolFactory Address of PoolFactory.\n        @param valid       The new validity status of a PoolFactory.\n    */\n    function setValidPoolFactory(address poolFactory, bool valid) external isGovernor {\n        isValidPoolFactory[poolFactory] = valid;\n    }\n\n    /**\n        @dev   Sets the validity of a LoanFactory. Only the Governor can call this function.\n        @param loanFactory Address of LoanFactory.\n        @param valid       The new validity status of a LoanFactory.\n    */\n    function setValidLoanFactory(address loanFactory, bool valid) external isGovernor {\n        isValidLoanFactory[loanFactory] = valid;\n    }\n\n    /**\n        @dev   Sets the validity of a sub factory as it relates to a super factory. Only the Governor can call this function.\n        @param superFactory The core factory (e.g. PoolFactory, LoanFactory).\n        @param subFactory   The sub factory used by core factory (e.g. LiquidityLockerFactory).\n        @param valid        The new validity status of a subFactory within context of super factory.\n    */\n    function setValidSubFactory(address superFactory, address subFactory, bool valid) external isGovernor {\n        require(isValidLoanFactory[superFactory] || isValidPoolFactory[superFactory], \"MG:INVALID_SUPER_F\");\n        validSubFactories[superFactory][subFactory] = valid;\n    }\n\n    /**\n        @dev   Sets the path to swap an asset through Uniswap. Only the Governor can call this function.\n        @param from Asset being swapped.\n        @param to   Final asset to receive. **\n        @param mid  Middle asset.\n\n        ** Set to == mid to enable a bilateral swap (single path swap).\n           Set to != mid to enable a triangular swap (multi path swap).\n    */\n    function setDefaultUniswapPath(address from, address to, address mid) external isGovernor {\n        defaultUniswapPath[from][to] = mid;\n    }\n\n    /**\n        @dev   Sets the validity of a Pool Delegate (those allowed to create Pools). Only the Governor can call this function.\n        @dev   It emits a `PoolDelegateSet` event.\n        @param delegate Address to manage permissions for.\n        @param valid    The new validity status of a Pool Delegate.\n    */\n    function setPoolDelegateAllowlist(address delegate, bool valid) external isGovernor {\n        isValidPoolDelegate[delegate] = valid;\n        emit PoolDelegateSet(delegate, valid);\n    }\n\n    /**\n        @dev   Sets the validity of an asset for collateral. Only the Governor can call this function.\n        @dev   It emits a `CollateralAssetSet` event.\n        @param asset The asset to assign validity to.\n        @param valid The new validity status of a Collateral Asset.\n    */\n    function setCollateralAsset(address asset, bool valid) external isGovernor {\n        isValidCollateralAsset[asset] = valid;\n        emit CollateralAssetSet(asset, IERC20Details(asset).decimals(), IERC20Details(asset).symbol(), valid);\n    }\n\n    /**\n        @dev   Sets the validity of an asset for liquidity in Pools. Only the Governor can call this function.\n        @dev   It emits a `LiquidityAssetSet` event.\n        @param asset Address of the valid asset.\n        @param valid The new validity status a Liquidity Asset in Pools.\n    */\n    function setLiquidityAsset(address asset, bool valid) external isGovernor {\n        isValidLiquidityAsset[asset] = valid;\n        emit LiquidityAssetSet(asset, IERC20Details(asset).decimals(), IERC20Details(asset).symbol(), valid);\n    }\n\n    /**\n        @dev   Sets the validity of a calculator contract. Only the Governor can call this function.\n        @param calc  Calculator address.\n        @param valid The new validity status of a Calculator.\n    */\n    function setCalc(address calc, bool valid) external isGovernor {\n        validCalcs[calc] = valid;\n    }\n\n    /**\n        @dev   Sets the investor fee (in basis points). Only the Governor can call this function.\n        @dev   It emits a `GlobalsParamSet` event.\n        @param _fee The fee, e.g., 50 = 0.50%.\n    */\n    function setInvestorFee(uint256 _fee) external isGovernor {\n        _checkPercentageRange(treasuryFee.add(_fee));\n        investorFee = _fee;\n        emit GlobalsParamSet(\"INVESTOR_FEE\", _fee);\n    }\n\n    /**\n        @dev   Sets the treasury fee (in basis points). Only the Governor can call this function.\n        @dev   It emits a `GlobalsParamSet` event.\n        @param _fee The fee, e.g., 50 = 0.50%.\n    */\n    function setTreasuryFee(uint256 _fee) external isGovernor {\n        _checkPercentageRange(investorFee.add(_fee));\n        treasuryFee = _fee;\n        emit GlobalsParamSet(\"TREASURY_FEE\", _fee);\n    }\n\n    /**\n        @dev   Sets the MapleTreasury. Only the Governor can call this function.\n        @dev   It emits a `GlobalsParamSet` event.\n        @param _mapleTreasury New MapleTreasury address.\n    */\n    function setMapleTreasury(address _mapleTreasury) external isGovernor {\n        require(_mapleTreasury != address(0), \"MG:ZERO_ADDR\");\n        mapleTreasury = _mapleTreasury;\n        emit GlobalsAddressSet(\"MAPLE_TREASURY\", _mapleTreasury);\n    }\n\n    /**\n        @dev   Sets the default grace period. Only the Governor can call this function.\n        @dev   It emits a `GlobalsParamSet` event.\n        @param _defaultGracePeriod Number of seconds to set the grace period to.\n    */\n    function setDefaultGracePeriod(uint256 _defaultGracePeriod) external isGovernor {\n        defaultGracePeriod = _defaultGracePeriod;\n        emit GlobalsParamSet(\"DEFAULT_GRACE_PERIOD\", _defaultGracePeriod);\n    }\n\n    /**\n        @dev   Sets the minimum Loan equity. Only the Governor can call this function.\n        @dev   It emits a `GlobalsParamSet` event.\n        @param _minLoanEquity Min percentage of Loan equity an account must have to trigger liquidations.\n    */\n    function setMinLoanEquity(uint256 _minLoanEquity) external isGovernor {\n        _checkPercentageRange(_minLoanEquity);\n        minLoanEquity = _minLoanEquity;\n        emit GlobalsParamSet(\"MIN_LOAN_EQUITY\", _minLoanEquity);\n    }\n\n    /**\n        @dev   Sets the funding period. Only the Governor can call this function.\n        @dev   It emits a `GlobalsParamSet` event.\n        @param _fundingPeriod Number of seconds to set the drawdown grace period to.\n    */\n    function setFundingPeriod(uint256 _fundingPeriod) external isGovernor {\n        fundingPeriod = _fundingPeriod;\n        emit GlobalsParamSet(\"FUNDING_PERIOD\", _fundingPeriod);\n    }\n\n    /**\n        @dev   Sets the the minimum Pool cover required to finalize a Pool. Only the Governor can call this function. FIX\n        @dev   It emits a `GlobalsParamSet` event.\n        @param amt The new minimum swap out required.\n    */\n    function setSwapOutRequired(uint256 amt) external isGovernor {\n        require(amt >= uint256(10_000), \"MG:SWAP_OUT_TOO_LOW\");\n        swapOutRequired = amt;\n        emit GlobalsParamSet(\"SWAP_OUT_REQUIRED\", amt);\n    }\n\n    /**\n        @dev   Sets a price feed's oracle. Only the Governor can call this function.\n        @dev   It emits a `OracleSet` event.\n        @param asset  Asset to update price for.\n        @param oracle New oracle to use.\n    */\n    function setPriceOracle(address asset, address oracle) external isGovernor {\n        oracleFor[asset] = oracle;\n        emit OracleSet(asset, oracle);\n    }\n\n    /************************************/\n    /*** Transfer Ownership Functions ***/\n    /************************************/\n\n    /**\n        @dev   Sets a new Pending Governor. This address can become Governor if they accept. Only the Governor can call this function.\n        @dev   It emits a `PendingGovernorSet` event.\n        @param _pendingGovernor Address of new Pending Governor.\n    */\n    function setPendingGovernor(address _pendingGovernor) external isGovernor {\n        require(_pendingGovernor != address(0), \"MG:ZERO_ADDR\");\n        pendingGovernor = _pendingGovernor;\n        emit PendingGovernorSet(_pendingGovernor);\n    }\n\n    /**\n        @dev Accept the Governor position. Only the Pending Governor can call this function.\n        @dev It emits a `GovernorAccepted` event.\n    */\n    function acceptGovernor() external {\n        require(msg.sender == pendingGovernor, \"MG:NOT_PENDING_GOV\");\n        governor        = msg.sender;\n        pendingGovernor = address(0);\n        emit GovernorAccepted(msg.sender);\n    }\n\n    /************************/\n    /*** Getter Functions ***/\n    /************************/\n\n    /**\n        @dev    Fetch price for asset from Chainlink oracles.\n        @param  asset Asset to fetch price of.\n        @return Price of asset in USD.\n    */\n    function getLatestPrice(address asset) external view returns (uint256) {\n        return uint256(IOracle(oracleFor[asset]).getLatestPrice());\n    }\n\n    /**\n        @dev   Checks that a subFactory is valid as it relates to a super factory.\n        @param superFactory The core factory (e.g. PoolFactory, LoanFactory).\n        @param subFactory   The sub factory used by core factory (e.g. LiquidityLockerFactory).\n        @param factoryType  The type expected for the subFactory. References listed below.\n                                0 = COLLATERAL_LOCKER_FACTORY\n                                1 = DEBT_LOCKER_FACTORY\n                                2 = FUNDING_LOCKER_FACTORY\n                                3 = LIQUIDITY_LOCKER_FACTORY\n                                4 = STAKE_LOCKER_FACTORY\n    */\n    function isValidSubFactory(address superFactory, address subFactory, uint8 factoryType) external view returns (bool) {\n        return validSubFactories[superFactory][subFactory] && ISubFactory(subFactory).factoryType() == factoryType;\n    }\n\n    /**\n        @dev   Checks that a Calculator is valid.\n        @param calc     Calculator address.\n        @param calcType Calculator type.\n    */\n    function isValidCalc(address calc, uint8 calcType) external view returns (bool) {\n        return validCalcs[calc] && ICalc(calc).calcType() == calcType;\n    }\n\n    /**\n        @dev    Returns the `lpCooldownPeriod` and `lpWithdrawWindow` as a tuple, for convenience.\n        @return [0] = lpCooldownPeriod\n                [1] = lpWithdrawWindow\n    */\n    function getLpCooldownParams() external view returns (uint256, uint256) {\n        return (lpCooldownPeriod, lpWithdrawWindow);\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /**\n        @dev Checks that percentage is less than 100%.\n    */\n    function _checkPercentageRange(uint256 percentage) internal pure {\n        require(percentage <= uint256(10_000), \"MG:PCT_OOB\");\n    }\n\n}\n"
    },
    "packages/protocol/contracts/MapleTreasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/IMapleGlobals.sol\";\nimport \"./interfaces/IProtocolMapleToken.sol\";\nimport \"./interfaces/IERC20Details.sol\";\nimport \"./interfaces/IUniswapRouter.sol\";\n\nimport \"./library/Util.sol\";\n\n/// @title MapleTreasury earns revenue from Loans and distributes it to token holders and the Maple development team.\ncontract MapleTreasury {\n\n    using SafeMath  for uint256;\n    using SafeERC20 for IERC20;\n\n    address public immutable mpl;            // The address of ERC-2222 Maple Token for the Maple protocol.\n    address public immutable fundsToken;     // The address of the `fundsToken` of the ERC-2222 Maple Token.\n    address public immutable uniswapRouter;  // The address of the official UniswapV2 router.\n    address public           globals;        // The address of an instance of MapleGlobals.\n\n    /**\n        @dev   Instantiates the MapleTreasury contract.\n        @param _mpl           The address of ERC-2222 Maple Token for the Maple protocol.\n        @param _fundsToken    The address of the `fundsToken` of the ERC-2222 Maple Token.\n        @param _uniswapRouter The address of the official UniswapV2 router.\n        @param _globals       The address of an instance of MapleGlobals.\n    */\n    constructor(\n        address _mpl,\n        address _fundsToken,\n        address _uniswapRouter,\n        address _globals\n    ) public {\n        mpl           = _mpl;\n        fundsToken    = _fundsToken;\n        uniswapRouter = _uniswapRouter;\n        globals       = _globals;\n    }\n\n    event      ERC20Conversion(address indexed asset, uint256 amountIn, uint256 amountOut);\n    event DistributedToHolders(uint256 amount);\n    event       ERC20Reclaimed(address indexed asset, uint256 amount);\n    event           GlobalsSet(address newGlobals);\n\n    /**\n        @dev Checks that `msg.sender` is the Governor.\n    */\n    modifier isGovernor() {\n        require(msg.sender == IMapleGlobals(globals).governor(), \"MT:NOT_GOV\");\n        _;\n    }\n\n    /**\n        @dev   Updates the MapleGlobals instance. Only the Governor can call this function.\n        @dev   It emits a `GlobalsSet` event.\n        @param newGlobals Address of a new MapleGlobals instance.\n    */\n    function setGlobals(address newGlobals) isGovernor external {\n        globals = newGlobals;\n        emit GlobalsSet(newGlobals);\n    }\n\n    /**\n        @dev   Reclaims Treasury funds to the MapleDAO address. Only the Governor can call this function.\n        @dev   It emits a `ERC20Reclaimed` event.\n        @param asset  Address of the token to be reclaimed.\n        @param amount Amount to withdraw.\n    */\n    function reclaimERC20(address asset, uint256 amount) isGovernor external {\n        IERC20(asset).safeTransfer(msg.sender, amount);\n        emit ERC20Reclaimed(asset, amount);\n    }\n\n    /**\n        @dev Passes through the current `fundsToken` balance of the Treasury to Maple Token, where it can be claimed by MPL holders.\n             Only the Governor can call this function.\n        @dev It emits a `DistributedToHolders` event.\n    */\n    function distributeToHolders() isGovernor external {\n        IERC20 _fundsToken = IERC20(fundsToken);\n        uint256 distributeAmount = _fundsToken.balanceOf(address(this));\n        _fundsToken.safeTransfer(mpl, distributeAmount);\n        IProtocolMapleToken(mpl).updateFundsReceived();\n        emit DistributedToHolders(distributeAmount);\n    }\n\n    /**\n        @dev   Converts an ERC-20 asset, via Uniswap, to `fundsToken`. Only the Governor can call this function.\n        @dev   It emits a `ERC20Conversion` event.\n        @param asset The ERC-20 asset to convert to `fundsToken`.\n    */\n    function convertERC20(address asset) isGovernor external {\n        require(asset != fundsToken, \"MT:ASSET_IS_FUNDS_TOKEN\");\n\n        IMapleGlobals _globals = IMapleGlobals(globals);\n\n        uint256 assetBalance = IERC20(asset).balanceOf(address(this));\n        uint256 minAmount    = Util.calcMinAmount(_globals, asset, fundsToken, assetBalance);\n\n        IERC20(asset).safeApprove(uniswapRouter, uint256(0));\n        IERC20(asset).safeApprove(uniswapRouter, assetBalance);\n\n        address uniswapAssetForPath = _globals.defaultUniswapPath(asset, fundsToken);\n        bool middleAsset            = uniswapAssetForPath != fundsToken && uniswapAssetForPath != address(0);\n\n        address[] memory path = new address[](middleAsset ? 3 : 2);\n\n        path[0] = asset;\n        path[1] = middleAsset ? uniswapAssetForPath : fundsToken;\n\n        if (middleAsset) path[2] = fundsToken;\n\n        uint256[] memory returnAmounts = IUniswapRouter(uniswapRouter).swapExactTokensForTokens(\n            assetBalance,\n            minAmount.sub(minAmount.mul(_globals.maxSwapSlippage()).div(10_000)),\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        emit ERC20Conversion(asset, returnAmounts[0], returnAmounts[path.length - 1]);\n    }\n\n}\n"
    },
    "packages/token/contracts/MapleToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport { IMapleToken } from \"./interfaces/IMapleToken.sol\";\n\nimport { ERC2222 } from \"./ERC2222.sol\";\n\ncontract MapleToken is IMapleToken, ERC2222 {\n\n    bytes32 public immutable override DOMAIN_SEPARATOR;\n\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 amount,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH = 0xfc77c2b9d30fe91687fd39abb7d16fcdfe1472d065740051ab8b13e4bf4a617f;\n\n    mapping (address => uint256) public override nonces;\n\n    /**\n        @dev Instantiates the MapleToken.\n        @param name       Name of the token.\n        @param symbol     Symbol of the token.\n        @param fundsToken The asset claimable / distributed via ERC-2222, deposited to MapleToken contract.\n     */\n    constructor (\n        string memory name,\n        string memory symbol,\n        address fundsToken\n    ) ERC2222(name, symbol, fundsToken) public {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n\n        require(address(fundsToken) != address(0), \"MapleToken:INVALID_FUNDS_TOKEN\");\n        _mint(msg.sender, 10_000_000 * 10 ** 18);\n    }\n\n    /**\n        @dev Approve by signature.\n        @param owner    Owner address that signed the permit\n        @param spender  Spender of the permit\n        @param amount   Permit approval spend limit\n        @param deadline Deadline after which the permit is invalid\n        @param v        ECDSA signature v component\n        @param r        ECDSA signature r component\n        @param s        ECDSA signature s component\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {\n        require(deadline >= block.timestamp, 'MapleToken:EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == owner, 'MapleToken:INVALID_SIGNATURE');\n        _approve(owner, spender, amount);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/DebtLockerFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./DebtLocker.sol\";\n\n/// @title DebtLockerFactory instantiates DebtLockers.\ncontract DebtLockerFactory {\n\n    mapping(address => address) public owner;     // Mapping of DebtLocker addresses to their owner (i.e owner[locker] = Owner of the DebtLocker).\n    mapping(address => bool)    public isLocker;  // True only if a DebtLocker was created by this factory.\n\n    uint8 public constant factoryType = 1;  // i.e LockerFactoryTypes::DEBT_LOCKER_FACTORY\n\n    event DebtLockerCreated(address indexed owner, address debtLocker, address loan);\n\n    /**\n        @dev    Instantiates a DebtLocker.\n        @dev    It emits a `DebtLockerCreated` event.\n        @param  loan       The Loan this DebtLocker will escrow tokens for.\n        @return debtLocker Address of the instantiated DebtLocker.\n    */\n    function newLocker(address loan) external returns (address debtLocker) {\n        debtLocker           = address(new DebtLocker(loan, msg.sender));\n        owner[debtLocker]    = msg.sender;\n        isLocker[debtLocker] = true;\n\n        emit DebtLockerCreated(msg.sender, debtLocker, loan);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/FundingLockerFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./FundingLocker.sol\";\n\nimport \"./interfaces/ILoanFactory.sol\";\n\n/// @title FundingLockerFactory instantiates FundingLockers.\ncontract FundingLockerFactory {\n\n    mapping(address => address) public owner;     // Mapping of FundingLocker addresses to their owner (i.e owner[locker] = Owner of the FundingLocker).\n    mapping(address => bool)    public isLocker;  // True only if a FundingLocker was created by this factory.\n\n    uint8 public constant factoryType = 2;  // i.e FactoryType::FUNDING_LOCKER_FACTORY\n\n    event FundingLockerCreated(address indexed owner, address fundingLocker, address liquidityAsset);\n\n    /**\n        @dev    Instantiates a FundingLocker.\n        @dev    It emits a `FundingLockerCreated` event.\n        @param  liquidityAsset The Liquidity Asset this FundingLocker will escrow.\n        @return fundingLocker  Address of the instantiated FundingLocker.\n    */\n    function newLocker(address liquidityAsset) external returns (address fundingLocker) {\n        fundingLocker           = address(new FundingLocker(liquidityAsset, msg.sender));\n        owner[fundingLocker]    = msg.sender;\n        isLocker[fundingLocker] = true;\n\n        emit FundingLockerCreated(msg.sender, fundingLocker, liquidityAsset);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/LiquidityLockerFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./LiquidityLocker.sol\";\n\n/// @title LiquidityLockerFactory instantiates LiquidityLockers.\ncontract LiquidityLockerFactory {\n\n    mapping(address => address) public owner;     // Mapping of LiquidityLocker addresses to their owner (i.e owner[locker] = Owner of the LiquidityLocker).\n    mapping(address => bool)    public isLocker;  // True only if a LiquidityLocker was created by this factory.\n\n    uint8 public constant factoryType = 3;        // i.e LockerFactoryTypes::LIQUIDITY_LOCKER_FACTORY\n\n    event LiquidityLockerCreated(address indexed owner, address liquidityLocker, address liquidityAsset);\n\n    /**\n        @dev    Instantiates a LiquidityLocker contract.\n        @dev    It emits a `LiquidityLockerCreated` event.\n        @param  liquidityAsset  The Liquidity Asset this LiquidityLocker will escrow.\n        @return liquidityLocker Address of the instantiated LiquidityLocker.\n    */\n    function newLocker(address liquidityAsset) external returns (address liquidityLocker) {\n        liquidityLocker           = address(new LiquidityLocker(liquidityAsset, msg.sender));\n        owner[liquidityLocker]    = msg.sender;\n        isLocker[liquidityLocker] = true;\n\n        emit LiquidityLockerCreated(msg.sender, liquidityLocker, liquidityAsset);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/LoanFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport \"./Loan.sol\";\n\n/// @title LoanFactory instantiates Loans.\ncontract LoanFactory is Pausable {\n\n    using SafeMath for uint256;\n\n    uint8 public constant CL_FACTORY = 0;  // Factory type of `CollateralLockerFactory`.\n    uint8 public constant FL_FACTORY = 2;  // Factory type of `FundingLockerFactory`.\n\n    uint8 public constant INTEREST_CALC_TYPE = 10;  // Calc type of `RepaymentCalc`.\n    uint8 public constant LATEFEE_CALC_TYPE  = 11;  // Calc type of `LateFeeCalc`.\n    uint8 public constant PREMIUM_CALC_TYPE  = 12;  // Calc type of `PremiumCalc`.\n\n    IMapleGlobals public globals;  // Instance of the MapleGlobals.\n\n    uint256 public loansCreated;   // Incrementor for number of Loans created.\n\n    mapping(uint256 => address) public loans;   // Loans address mapping.\n    mapping(address => bool)    public isLoan;  // True only if a Loan was created by this factory.\n\n    mapping(address => bool) public loanFactoryAdmins;  // The LoanFactory Admin addresses that have permission to do certain operations in case of disaster management.\n\n    event LoanFactoryAdminSet(address indexed loanFactoryAdmin, bool allowed);\n\n    event LoanCreated(\n        address loan,\n        address indexed borrower,\n        address indexed liquidityAsset,\n        address collateralAsset,\n        address collateralLocker,\n        address fundingLocker,\n        uint256[5] specs,\n        address[3] calcs,\n        string name,\n        string symbol\n    );\n\n    constructor(address _globals) public {\n        globals = IMapleGlobals(_globals);\n    }\n\n    /**\n        @dev   Sets MapleGlobals. Only the Governor can call this function.\n        @param newGlobals Address of new MapleGlobals.\n    */\n    function setGlobals(address newGlobals) external {\n        _isValidGovernor();\n        globals = IMapleGlobals(newGlobals);\n    }\n\n    /**\n        @dev    Create a new Loan.\n        @dev    It emits a `LoanCreated` event.\n        @param  liquidityAsset  Asset the Loan will raise funding in.\n        @param  collateralAsset Asset the Loan will use as collateral.\n        @param  flFactory       The factory to instantiate a FundingLocker from.\n        @param  clFactory       The factory to instantiate a CollateralLocker from.\n        @param  specs           Contains specifications for this Loan.\n                                    specs[0] = apr\n                                    specs[1] = termDays\n                                    specs[2] = paymentIntervalDays\n                                    specs[3] = requestAmount\n                                    specs[4] = collateralRatio\n        @param  calcs           The calculators used for this Loan.\n                                    calcs[0] = repaymentCalc\n                                    calcs[1] = lateFeeCalc\n                                    calcs[2] = premiumCalc\n        @return loanAddress     Address of the instantiated Loan.\n    */\n    function createLoan(\n        address liquidityAsset,\n        address collateralAsset,\n        address flFactory,\n        address clFactory,\n        uint256[5] memory specs,\n        address[3] memory calcs\n    ) external whenNotPaused returns (address loanAddress) {\n        _whenProtocolNotPaused();\n        IMapleGlobals _globals = globals;\n\n        // Perform validity checks.\n        require(_globals.isValidSubFactory(address(this), flFactory, FL_FACTORY), \"LF:INVALID_FLF\");\n        require(_globals.isValidSubFactory(address(this), clFactory, CL_FACTORY), \"LF:INVALID_CLF\");\n\n        require(_globals.isValidCalc(calcs[0], INTEREST_CALC_TYPE), \"LF:INVALID_INT_C\");\n        require(_globals.isValidCalc(calcs[1],  LATEFEE_CALC_TYPE), \"LF:INVALID_LATE_FEE_C\");\n        require(_globals.isValidCalc(calcs[2],  PREMIUM_CALC_TYPE), \"LF:INVALID_PREM_C\");\n\n        // Deploy new Loan.\n        Loan loan = new Loan(\n            msg.sender,\n            liquidityAsset,\n            collateralAsset,\n            flFactory,\n            clFactory,\n            specs,\n            calcs\n        );\n\n        // Update the LoanFactory identification mappings.\n        loanAddress         = address(loan);\n        loans[loansCreated] = loanAddress;\n        isLoan[loanAddress] = true;\n        ++loansCreated;\n\n        emit LoanCreated(\n            loanAddress,\n            msg.sender,\n            liquidityAsset,\n            collateralAsset,\n            loan.collateralLocker(),\n            loan.fundingLocker(),\n            specs,\n            calcs,\n            loan.name(),\n            loan.symbol()\n        );\n    }\n\n    /**\n        @dev   Sets a LoanFactory Admin. Only the Governor can call this function.\n        @dev   It emits a `LoanFactoryAdminSet` event.\n        @param loanFactoryAdmin An address being allowed or disallowed as a LoanFactory Admin.\n        @param allowed          Status of a LoanFactory Admin.\n    */\n    function setLoanFactoryAdmin(address loanFactoryAdmin, bool allowed) external {\n        _isValidGovernor();\n        loanFactoryAdmins[loanFactoryAdmin] = allowed;\n        emit LoanFactoryAdminSet(loanFactoryAdmin, allowed);\n    }\n\n    /**\n        @dev Triggers paused state. Halts functionality for certain functions. Only the Governor or a LoanFactory Admin can call this function.\n    */\n    function pause() external {\n        _isValidGovernorOrLoanFactoryAdmin();\n        super._pause();\n    }\n\n    /**\n        @dev Triggers unpaused state. Restores functionality for certain functions. Only the Governor or a LoanFactory Admin can call this function.\n    */\n    function unpause() external {\n        _isValidGovernorOrLoanFactoryAdmin();\n        super._unpause();\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Governor.\n    */\n    function _isValidGovernor() internal view {\n        require(msg.sender == globals.governor(), \"LF:NOT_GOV\");\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Governor or a LoanFactory Admin.\n    */\n    function _isValidGovernorOrLoanFactoryAdmin() internal view {\n        require(msg.sender == globals.governor() || loanFactoryAdmins[msg.sender], \"LF:NOT_GOV_OR_ADMIN\");\n    }\n\n    /**\n        @dev Checks that the protocol is not in a paused state.\n    */\n    function _whenProtocolNotPaused() internal view {\n        require(!globals.protocolPaused(), \"LF:PROTO_PAUSED\");\n    }\n\n}\n"
    },
    "packages/protocol/contracts/MplRewardsFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./interfaces/IMapleGlobals.sol\";\n\nimport \"./MplRewards.sol\";\n\n/// @title MplRewardsFactory instantiates MplRewards contracts.\ncontract MplRewardsFactory {\n\n    IMapleGlobals public globals;  // Instance of MapleGlobals, used to retrieve the current Governor.\n\n    mapping(address => bool) public isMplRewards;  // True only if an MplRewards was created by this factory.\n\n    event MplRewardsCreated(address indexed rewardsToken, address indexed stakingToken, address indexed mplRewards, address owner);\n\n    constructor(address _globals) public {\n        globals = IMapleGlobals(_globals);\n    }\n\n    /**\n        @dev   Updates the MapleGlobals instance. Only the Governor can call this function.\n        @param _globals Address of new MapleGlobals contract.\n    */\n    function setGlobals(address _globals) external {\n        require(msg.sender == globals.governor(), \"RF:NOT_GOV\");\n        globals = IMapleGlobals(_globals);\n    }\n\n    /**\n        @dev   Instantiates a MplRewards contract. Only the Governor can call this function.\n        @dev   It emits a `MplRewardsCreated` event.\n        @param rewardsToken Address of the rewards token (will always be MPL).\n        @param stakingToken Address of the staking token (token used to stake to earn rewards).\n                            (i.e., Pool address for PoolFDT mining, StakeLocker address for staked BPT mining.)\n        @return mplRewards  Address of the instantiated MplRewards.\n    */\n    function createMplRewards(address rewardsToken, address stakingToken) external returns (address mplRewards) {\n        require(msg.sender == globals.governor(), \"RF:NOT_GOV\");\n        mplRewards               = address(new MplRewards(rewardsToken, stakingToken, msg.sender));\n        isMplRewards[mplRewards] = true;\n\n        emit MplRewardsCreated(rewardsToken, stakingToken, mplRewards, msg.sender);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/PoolFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport \"./Pool.sol\";\n\n/// @title PoolFactory instantiates Pools.\ncontract PoolFactory is Pausable {\n\n    uint8 public constant LL_FACTORY = 3;  // Factory type of `LiquidityLockerFactory`.\n    uint8 public constant SL_FACTORY = 4;  // Factory type of `StakeLockerFactory`.\n\n    uint256  public poolsCreated;  // Incrementor for number of Pools created.\n    IMapleGlobals public globals;  // A MapleGlobals instance.\n\n    mapping(uint256 => address) public pools;              // Map to reference Pools corresponding to their respective indices.\n    mapping(address => bool)    public isPool;             // True only if a Pool was instantiated by this factory.\n    mapping(address => bool)    public poolFactoryAdmins;  // The PoolFactory Admin addresses that have permission to do certain operations in case of disaster management.\n\n    event PoolFactoryAdminSet(address indexed poolFactoryAdmin, bool allowed);\n\n    event PoolCreated(\n        address indexed pool,\n        address indexed delegate,\n        address liquidityAsset,\n        address stakeAsset,\n        address liquidityLocker,\n        address stakeLocker,\n        uint256 stakingFee,\n        uint256 delegateFee,\n        uint256 liquidityCap,\n        string  name,\n        string  symbol\n    );\n\n    constructor(address _globals) public {\n        globals = IMapleGlobals(_globals);\n    }\n\n    /**\n        @dev   Sets MapleGlobals instance. Only the Governor can call this function.\n        @param newGlobals Address of new MapleGlobals.\n    */\n    function setGlobals(address newGlobals) external {\n        _isValidGovernor();\n        globals = IMapleGlobals(newGlobals);\n    }\n\n    /**\n        @dev    Instantiates a Pool.\n        @dev    It emits a `PoolCreated` event.\n        @param  liquidityAsset The asset escrowed in a LiquidityLocker.\n        @param  stakeAsset     The asset escrowed in a StakeLocker.\n        @param  slFactory      The factory to instantiate a StakeLocker from.\n        @param  llFactory      The factory to instantiate a LiquidityLocker from.\n        @param  stakingFee     Fee that Stakers earn on interest, in basis points.\n        @param  delegateFee    Fee that the Pool Delegate earns on interest, in basis points.\n        @param  liquidityCap   Amount of Liquidity Asset accepted by the Pool.\n        @return poolAddress    Address of the instantiated Pool.\n    */\n    function createPool(\n        address liquidityAsset,\n        address stakeAsset,\n        address slFactory,\n        address llFactory,\n        uint256 stakingFee,\n        uint256 delegateFee,\n        uint256 liquidityCap\n    ) external whenNotPaused returns (address poolAddress) {\n        _whenProtocolNotPaused();\n        {\n            IMapleGlobals _globals = globals;\n            require(_globals.isValidSubFactory(address(this), llFactory, LL_FACTORY), \"PF:INVALID_LLF\");\n            require(_globals.isValidSubFactory(address(this), slFactory, SL_FACTORY), \"PF:INVALID_SLF\");\n            require(_globals.isValidPoolDelegate(msg.sender),                         \"PF:NOT_DELEGATE\");\n        }\n\n        string memory name   = \"Maple Pool Token\";\n        string memory symbol = \"MPL-LP\";\n\n        Pool pool =\n            new Pool(\n                msg.sender,\n                liquidityAsset,\n                stakeAsset,\n                slFactory,\n                llFactory,\n                stakingFee,\n                delegateFee,\n                liquidityCap,\n                name,\n                symbol\n            );\n\n        poolAddress         = address(pool);\n        pools[poolsCreated] = poolAddress;\n        isPool[poolAddress] = true;\n        ++poolsCreated;\n\n        emit PoolCreated(\n            poolAddress,\n            msg.sender,\n            liquidityAsset,\n            stakeAsset,\n            pool.liquidityLocker(),\n            pool.stakeLocker(),\n            stakingFee,\n            delegateFee,\n            liquidityCap,\n            name,\n            symbol\n        );\n    }\n\n    /**\n        @dev   Sets a PoolFactory Admin. Only the Governor can call this function.\n        @dev   It emits a `PoolFactoryAdminSet` event.\n        @param poolFactoryAdmin An address being allowed or disallowed as a PoolFactory Admin.\n        @param allowed  Status of a PoolFactory Admin.\n    */\n    function setPoolFactoryAdmin(address poolFactoryAdmin, bool allowed) external {\n        _isValidGovernor();\n        poolFactoryAdmins[poolFactoryAdmin] = allowed;\n        emit PoolFactoryAdminSet(poolFactoryAdmin, allowed);\n    }\n\n    /**\n        @dev Triggers paused state. Halts functionality for certain functions. Only the Governor or a PoolFactory Admin can call this function.\n    */\n    function pause() external {\n        _isValidGovernorOrPoolFactoryAdmin();\n        super._pause();\n    }\n\n    /**\n        @dev Triggers unpaused state. Restores functionality for certain functions. Only the Governor or a PoolFactory Admin can call this function.\n    */\n    function unpause() external {\n        _isValidGovernorOrPoolFactoryAdmin();\n        super._unpause();\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Governor.\n    */\n    function _isValidGovernor() internal view {\n        require(msg.sender == globals.governor(), \"PF:NOT_GOV\");\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Governor or a PoolFactory Admin.\n    */\n    function _isValidGovernorOrPoolFactoryAdmin() internal view {\n        require(msg.sender == globals.governor() || poolFactoryAdmins[msg.sender], \"PF:NOT_GOV_OR_ADMIN\");\n    }\n\n    /**\n        @dev Checks that the protocol is not in a paused state.\n    */\n    function _whenProtocolNotPaused() internal view {\n        require(!globals.protocolPaused(), \"PF:PROTO_PAUSED\");\n    }\n\n}\n"
    },
    "packages/protocol/contracts/StakeLockerFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./StakeLocker.sol\";\n\n/// @title StakeLockerFactory instantiates StakeLockers.\ncontract StakeLockerFactory {\n\n    mapping(address => address) public owner;     // Mapping of StakeLocker addresses to their owner (i.e owner[locker] = Owner of the StakeLocker).\n    mapping(address => bool)    public isLocker;  // True only if a StakeLocker was created by this factory.\n\n    uint8 public constant factoryType = 4;  // i.e FactoryType::STAKE_LOCKER_FACTORY.\n\n    event StakeLockerCreated(\n        address indexed owner,\n        address stakeLocker,\n        address stakeAsset,\n        address liquidityAsset,\n        string name,\n        string symbol\n    );\n\n    /**\n        @dev    Instantiate a StakeLocker.\n        @dev    It emits a `StakeLockerCreated` event.\n        @param  stakeAsset     Address of the Stake Asset (generally Balancer Pool BPTs).\n        @param  liquidityAsset Address of the Liquidity Asset (as defined in the Pool).\n        @return stakeLocker    Address of the instantiated StakeLocker.\n    */\n    function newLocker(\n        address stakeAsset,\n        address liquidityAsset\n    ) external returns (address stakeLocker) {\n        stakeLocker           = address(new StakeLocker(stakeAsset, liquidityAsset, msg.sender));\n        owner[stakeLocker]    = msg.sender;\n        isLocker[stakeLocker] = true;\n\n        emit StakeLockerCreated(\n            msg.sender,\n            stakeLocker,\n            stakeAsset,\n            liquidityAsset,\n            StakeLocker(stakeLocker).name(),\n            StakeLocker(stakeLocker).symbol()\n        );\n    }\n\n}\n"
    },
    "packages/protocol/contracts/test/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity 0.6.11;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}"
    },
    "packages/protocol/contracts/test/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity 0.6.11;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "packages/protocol/contracts/test/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity 0.6.11;\n\ninterface IUniswapV2Router02 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "packages/protocol/contracts/LateFeeCalc.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/ILoan.sol\";\nimport \"./interfaces/IRepaymentCalc.sol\";\n\n/// @title LateFeeCalc calculates late fees on Loans.\ncontract LateFeeCalc {\n\n    using SafeMath for uint256;\n\n    uint8   public constant calcType = 11;  // \"LATEFEE type\"\n    bytes32 public constant name     = \"FLAT\";\n\n    uint256 public immutable lateFee;  // The fee in basis points, charged on the payment amount.\n\n    constructor(uint256 _lateFee) public {\n        lateFee = _lateFee;\n    }\n\n    /**\n        @dev    Calculates the late fee payment for a Loan.\n        @param  interest Amount of interest to be used to calculate late fee for.\n        @return Late fee that is charged to the Borrower.\n    */\n    function getLateFee(uint256 interest) external view returns (uint256) {\n        return interest.mul(lateFee).div(10_000);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/PremiumCalc.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/ILoan.sol\";\n\n/// @title PremiumCalc calculates premium fees on Loans.\ncontract PremiumCalc {\n\n    using SafeMath for uint256;\n\n    uint8   public constant calcType = 12;      // PREMIUM type.\n    bytes32 public constant name     = \"FLAT\";\n\n    uint256 public immutable premiumFee;  // Flat percentage fee (in basis points) of principal to charge as a premium when calling a Loan.\n\n    constructor(uint256 _premiumFee) public {\n        premiumFee = _premiumFee;\n    }\n\n    /**\n        @dev    Calculates the premium payment for a Loan, when making a full payment.\n        @param  _loan         The address of a Loan to calculate a premium payment for.\n        @return total         Principal + Interest.\n        @return principalOwed Principal.\n        @return interest      Interest.\n    */\n    function getPremiumPayment(address _loan) external view returns (uint256 total, uint256 principalOwed, uint256 interest) {\n        principalOwed = ILoan(_loan).principalOwed();\n        interest      = principalOwed.mul(premiumFee).div(10_000);\n        total         = interest.add(principalOwed);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/RepaymentCalc.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/ILoan.sol\";\n\n/// @title RepaymentCalc calculates payment amounts on Loans.\ncontract RepaymentCalc {\n\n\tusing SafeMath for uint256;\n\n    uint8   public constant calcType = 10;               // INTEREST type.\n    bytes32 public constant name     = \"INTEREST_ONLY\";  // Calculator.\n\n    /**\n        @dev    Calculates the next payment for a Loan.\n        @param  _loan         The address of a Loan to calculate a payment for.\n        @return total         Entitled interest of the next payment (Principal + Interest only when the next payment is last payment of the Loan).\n        @return principalOwed Entitled principal amount needed to be paid in the next payment.\n        @return interest      Entitled interest amount needed to be paid in the next payment.\n    */\n    function getNextPayment(address _loan) external view returns (uint256 total, uint256 principalOwed, uint256 interest) {\n\n        ILoan loan = ILoan(_loan);\n\n        principalOwed = loan.principalOwed();\n\n        // Equation = principal * APR * (paymentInterval / year)\n        // Principal * APR gives annual interest\n        // Multiplying that by (paymentInterval / year) gives portion of annual interest due for each interval.\n        interest =\n            principalOwed\n                .mul(loan.apr())\n                .mul(loan.paymentIntervalSeconds())\n                .div(10_000)\n                .div(365 days);\n\n        (total, principalOwed) = loan.paymentsRemaining() == 1\n            ? (interest.add(principalOwed), principalOwed)\n            : (interest, 0);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/oracles/ChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./IChainlinkAggregatorV3.sol\";\nimport \"../interfaces/IMapleGlobals.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title ChainlinkOracle is a wrapper contract for Chainlink oracle price feeds that allows for manual price feed overrides.\ncontract ChainlinkOracle is Ownable {\n\n    IChainlinkAggregatorV3 public priceFeed;\n    IMapleGlobals public globals;\n\n    address public immutable assetAddress;\n\n    bool   public manualOverride;\n    int256 public manualPrice;\n\n    event ChangeAggregatorFeed(address _newMedianizer, address _oldMedianizer);\n    event       SetManualPrice(int256 _oldPrice, int256 _newPrice);\n    event    SetManualOverride(bool _override);\n\n    /**\n        @dev   Creates a new Chainlink based oracle.\n        @param _aggregator   Address of Chainlink aggregator.\n        @param _assetAddress Address of currency (0x0 for ETH).\n        @param _owner        Address of the owner of the contract.\n    */\n    constructor(address _aggregator, address _assetAddress, address _owner) public {\n        require(_aggregator != address(0), \"CO:ZERO_AGGREGATOR_ADDR\");\n        priceFeed       = IChainlinkAggregatorV3(_aggregator);\n        assetAddress    = _assetAddress;\n        transferOwnership(_owner);\n    }\n\n    /**\n        @dev    Returns the latest price.\n        @return price The latest price.\n    */\n    function getLatestPrice() public view returns (int256) {\n        if (manualOverride) return manualPrice;\n        (uint80 roundID, int256 price,,uint256 timeStamp, uint80 answeredInRound) = priceFeed.latestRoundData();\n\n        require(timeStamp != 0,             \"CO:ROUND_NOT_COMPLETE\");\n        require(answeredInRound >= roundID,         \"CO:STALE_DATA\");\n        require(price != int256(0),                 \"CO:ZERO_PRICE\");\n        return price;\n    }\n\n\n    /**\n        @dev   Updates aggregator address. Only the contract Owner can call this function.\n        @dev   It emits a `ChangeAggregatorFeed` event.\n        @param aggregator Address of Chainlink aggregator.\n    */\n    function changeAggregator(address aggregator) external onlyOwner {\n        require(aggregator != address(0), \"CO:ZERO_AGGREGATOR_ADDR\");\n        emit ChangeAggregatorFeed(aggregator, address(priceFeed));\n        priceFeed = IChainlinkAggregatorV3(aggregator);\n    }\n\n    /**\n        @dev Returns address of oracle currency (0x0 for ETH).\n    */\n    function getAssetAddress() external view returns (address) {\n        return assetAddress;\n    }\n\n    /**\n        @dev Returns denomination of price.\n    */\n    function getDenomination() external pure returns (bytes32) {\n        // All Chainlink oracles are denominated in USD.\n        return bytes32(\"USD\");\n    }\n\n    /**\n        @dev   Sets a manual price. Only the contract Owner can call this function.\n               NOTE: this can only be used if manualOverride == true.\n        @dev   It emits a `SetManualPrice` event.\n        @param _price Price to set.\n    */\n    function setManualPrice(int256 _price) public onlyOwner {\n        require(manualOverride, \"CO:MANUAL_OVERRIDE_NOT_ACTIVE\");\n        emit SetManualPrice(manualPrice, _price);\n        manualPrice = _price;\n    }\n\n    /**\n        @dev   Sets manual override, allowing for manual price setting. Only the contract Owner can call this function.\n        @dev   It emits a `SetManualOverride` event.\n        @param _override Whether to use the manual override price or not.\n    */\n    function setManualOverride(bool _override) public onlyOwner {\n        manualOverride = _override;\n        emit SetManualOverride(_override);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/oracles/UsdOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\n/// @title UsdOracle is a constant price oracle feed that always returns 1 USD in 8 decimal precision.\ncontract UsdOracle {\n\n    int256 constant USD_PRICE = 1 * 10 ** 8;\n\n    /**\n        @dev Returns the constant USD price.\n    */\n    function getLatestPrice() public pure returns (int256) {\n        return USD_PRICE;\n    }\n}\n"
    },
    "packages/protocol/contracts/interfaces/IBPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IBPool {\n\n    function transfer(address, uint256) external returns (bool);\n\n    function INIT_POOL_SUPPLY() external view returns (uint256);\n\n    function MAX_OUT_RATIO() external view returns (uint256);\n\n    function bind(address, uint256, uint256) external;\n\n    function balanceOf(address) external view returns (uint256);\n\n    function finalize() external;\n\n    function gulp(address) external;\n\n    function isFinalized() external view returns (bool);\n\n    function isBound(address) external view returns (bool);\n\n    function getNumTokens() external view returns (uint256);\n\n    function getBalance(address) external view returns (uint256);\n\n    function getNormalizedWeight(address) external view returns (uint256);\n\n    function getDenormalizedWeight(address) external view returns (uint256);\n\n    function getTotalDenormalizedWeight() external view returns (uint256);\n\n    function getSwapFee() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function getFinalTokens() external view returns (address[] memory);\n\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;\n\n    function calcSingleOutGivenPoolIn(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256);\n\n    function calcPoolInGivenSingleOut(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256);\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPoolAmountIn\n    ) external returns (uint256 poolAmountIn);\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IBFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IBFactory {\n\n    function isBPool(address) external view returns (bool);\n\n    function newBPool() external returns (address);\n\n}\n"
    },
    "packages/ds-test/contracts/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", b);\n            emit log_named_string(\"  Value b\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "packages/protocol/contracts/Loan.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ICollateralLocker.sol\";\nimport \"./interfaces/ICollateralLockerFactory.sol\";\nimport \"./interfaces/IERC20Details.sol\";\nimport \"./interfaces/IFundingLocker.sol\";\nimport \"./interfaces/IFundingLockerFactory.sol\";\nimport \"./interfaces/IMapleGlobals.sol\";\nimport \"./interfaces/ILateFeeCalc.sol\";\nimport \"./interfaces/ILiquidityLocker.sol\";\nimport \"./interfaces/ILoanFactory.sol\";\nimport \"./interfaces/IPool.sol\";\nimport \"./interfaces/IPoolFactory.sol\";\nimport \"./interfaces/IPremiumCalc.sol\";\nimport \"./interfaces/IRepaymentCalc.sol\";\nimport \"./interfaces/IUniswapRouter.sol\";\n\nimport \"./library/Util.sol\";\nimport \"./library/LoanLib.sol\";\n\nimport \"./token/LoanFDT.sol\";\n\n/// @title Loan maintains all accounting and functionality related to Loans.\ncontract Loan is LoanFDT, Pausable {\n\n    using SafeMathInt     for int256;\n    using SignedSafeMath  for int256;\n    using SafeMath        for uint256;\n    using SafeERC20       for IERC20;\n\n    /**\n        Ready      = The Loan has been initialized and is ready for funding (assuming funding period hasn't ended)\n        Active     = The Loan has been drawdown and the Borrower is making payments\n        Matured    = The Loan is fully paid off and has \"matured\"\n        Expired    = The Loan did not initiate, and all funding was returned to Lenders\n        Liquidated = The Loan has been liquidated\n    */\n    enum State { Ready, Active, Matured, Expired, Liquidated }\n\n    State public loanState;  // The current state of this Loan, as defined in the State enum below.\n\n    IERC20 public immutable liquidityAsset;      // The asset deposited by Lenders into the FundingLocker, when funding this Loan.\n    IERC20 public immutable collateralAsset;     // The asset deposited by Borrower into the CollateralLocker, for collateralizing this Loan.\n\n    address public immutable fundingLocker;      // The FundingLocker that holds custody of Loan funds before drawdown.\n    address public immutable flFactory;          // The FundingLockerFactory.\n    address public immutable collateralLocker;   // The CollateralLocker that holds custody of Loan collateral.\n    address public immutable clFactory;          // The CollateralLockerFactory.\n    address public immutable borrower;           // The Borrower of this Loan, responsible for repayments.\n    address public immutable repaymentCalc;      // The RepaymentCalc for this Loan.\n    address public immutable lateFeeCalc;        // The LateFeeCalc for this Loan.\n    address public immutable premiumCalc;        // The PremiumCalc for this Loan.\n    address public immutable superFactory;       // The LoanFactory that deployed this Loan.\n\n    mapping(address => bool) public loanAdmins;  // Admin addresses that have permission to do certain operations in case of disaster management.\n\n    uint256 public nextPaymentDue;  // The unix timestamp due date of the next payment.\n\n    // Loan specifications\n    uint256 public immutable apr;                     // The APR in basis points.\n    uint256 public           paymentsRemaining;       // The number of payments remaining on the Loan.\n    uint256 public immutable termDays;                // The total length of the Loan term in days.\n    uint256 public immutable paymentIntervalSeconds;  // The time between Loan payments in seconds.\n    uint256 public immutable requestAmount;           // The total requested amount for Loan.\n    uint256 public immutable collateralRatio;         // The percentage of value of the drawdown amount to post as collateral in basis points.\n    uint256 public immutable createdAt;               // The timestamp of when Loan was instantiated.\n    uint256 public immutable fundingPeriod;           // The time for a Loan to be funded in seconds.\n    uint256 public immutable defaultGracePeriod;      // The time a Borrower has, after a payment is due, to make a payment before a liquidation can occur.\n\n    // Accounting variables\n    uint256 public principalOwed;   // The amount of principal owed (initially the drawdown amount).\n    uint256 public principalPaid;   // The amount of principal that has  been paid     by the Borrower since the Loan instantiation.\n    uint256 public interestPaid;    // The amount of interest  that has  been paid     by the Borrower since the Loan instantiation.\n    uint256 public feePaid;         // The amount of fees      that have been paid     by the Borrower since the Loan instantiation.\n    uint256 public excessReturned;  // The amount of excess    that has  been returned to the Lenders  after the Loan drawdown.\n\n    // Liquidation variables\n    uint256 public amountLiquidated;   // The amount of Collateral Asset that has been liquidated after default.\n    uint256 public amountRecovered;    // The amount of Liquidity Asset  that has been recovered  after default.\n    uint256 public defaultSuffered;    // The difference between `amountRecovered` and `principalOwed` after liquidation.\n    uint256 public liquidationExcess;  // If `amountRecovered > principalOwed`, this is the amount of Liquidity Asset that is to be returned to the Borrower.\n\n    event       LoanFunded(address indexed fundedBy, uint256 amountFunded);\n    event   BalanceUpdated(address indexed account, address indexed token, uint256 balance);\n    event         Drawdown(uint256 drawdownAmount);\n    event LoanStateChanged(State state);\n    event     LoanAdminSet(address indexed loanAdmin, bool allowed);\n\n    event PaymentMade(\n        uint256 totalPaid,\n        uint256 principalPaid,\n        uint256 interestPaid,\n        uint256 paymentsRemaining,\n        uint256 principalOwed,\n        uint256 nextPaymentDue,\n        bool latePayment\n    );\n\n    event Liquidation(\n        uint256 collateralSwapped,\n        uint256 liquidityAssetReturned,\n        uint256 liquidationExcess,\n        uint256 defaultSuffered\n    );\n\n    /**\n        @dev    Constructor for a Loan.\n        @dev    It emits a `LoanStateChanged` event.\n        @param  _borrower        Will receive the funding when calling `drawdown()`. Is also responsible for repayments.\n        @param  _liquidityAsset  The asset the Borrower is requesting funding in.\n        @param  _collateralAsset The asset provided as collateral by the Borrower.\n        @param  _flFactory       Factory to instantiate FundingLocker with.\n        @param  _clFactory       Factory to instantiate CollateralLocker with.\n        @param  specs            Contains specifications for this Loan.\n                                     specs[0] = apr\n                                     specs[1] = termDays\n                                     specs[2] = paymentIntervalDays (aka PID)\n                                     specs[3] = requestAmount\n                                     specs[4] = collateralRatio\n        @param  calcs            The calculators used for this Loan.\n                                     calcs[0] = repaymentCalc\n                                     calcs[1] = lateFeeCalc\n                                     calcs[2] = premiumCalc\n    */\n    constructor(\n        address _borrower,\n        address _liquidityAsset,\n        address _collateralAsset,\n        address _flFactory,\n        address _clFactory,\n        uint256[5] memory specs,\n        address[3] memory calcs\n    ) LoanFDT(\"Maple Loan Token\", \"MPL-LOAN\", _liquidityAsset) public {\n        IMapleGlobals globals = _globals(msg.sender);\n\n        // Perform validity cross-checks.\n        LoanLib.loanSanityChecks(globals, _liquidityAsset, _collateralAsset, specs);\n\n        borrower        = _borrower;\n        liquidityAsset  = IERC20(_liquidityAsset);\n        collateralAsset = IERC20(_collateralAsset);\n        flFactory       = _flFactory;\n        clFactory       = _clFactory;\n        createdAt       = block.timestamp;\n\n        // Update state variables.\n        apr                    = specs[0];\n        termDays               = specs[1];\n        paymentsRemaining      = specs[1].div(specs[2]);\n        paymentIntervalSeconds = specs[2].mul(1 days);\n        requestAmount          = specs[3];\n        collateralRatio        = specs[4];\n        fundingPeriod          = globals.fundingPeriod();\n        defaultGracePeriod     = globals.defaultGracePeriod();\n        repaymentCalc          = calcs[0];\n        lateFeeCalc            = calcs[1];\n        premiumCalc            = calcs[2];\n        superFactory           = msg.sender;\n\n        // Deploy lockers.\n        collateralLocker = ICollateralLockerFactory(_clFactory).newLocker(_collateralAsset);\n        fundingLocker    = IFundingLockerFactory(_flFactory).newLocker(_liquidityAsset);\n        emit LoanStateChanged(State.Ready);\n    }\n\n    /**************************/\n    /*** Borrower Functions ***/\n    /**************************/\n\n    /**\n        @dev   Draws down funding from FundingLocker, posts collateral, and transitions the Loan state from `Ready` to `Active`. Only the Borrower can call this function.\n        @dev   It emits four `BalanceUpdated` events.\n        @dev   It emits a `LoanStateChanged` event.\n        @dev   It emits a `Drawdown` event.\n        @param amt Amount of Liquidity Asset the Borrower draws down. Remainder is returned to the Loan where it can be claimed back by LoanFDT holders.\n    */\n    function drawdown(uint256 amt) external {\n        _whenProtocolNotPaused();\n        _isValidBorrower();\n        _isValidState(State.Ready);\n        IMapleGlobals globals = _globals(superFactory);\n\n        IFundingLocker _fundingLocker = IFundingLocker(fundingLocker);\n\n        require(amt >= requestAmount,              \"L:AMT_LT_REQUEST_AMT\");\n        require(amt <= _getFundingLockerBalance(), \"L:AMT_GT_FUNDED_AMT\");\n\n        // Update accounting variables for the Loan.\n        principalOwed  = amt;\n        nextPaymentDue = block.timestamp.add(paymentIntervalSeconds);\n\n        loanState = State.Active;\n\n        // Transfer the required amount of collateral for drawdown from the Borrower to the CollateralLocker.\n        collateralAsset.safeTransferFrom(borrower, collateralLocker, collateralRequiredForDrawdown(amt));\n\n        // Transfer funding amount from the FundingLocker to the Borrower, then drain remaining funds to the Loan.\n        uint256 treasuryFee = globals.treasuryFee();\n        uint256 investorFee = globals.investorFee();\n\n        address treasury = globals.mapleTreasury();\n\n        uint256 _feePaid = feePaid = amt.mul(investorFee).div(10_000);  // Update fees paid for `claim()`.\n        uint256 treasuryAmt        = amt.mul(treasuryFee).div(10_000);  // Calculate amount to send to the MapleTreasury.\n\n        _transferFunds(_fundingLocker, treasury, treasuryAmt);                         // Send the treasury fee directly to the MapleTreasury.\n        _transferFunds(_fundingLocker, borrower, amt.sub(treasuryAmt).sub(_feePaid));  // Transfer drawdown amount to the Borrower.\n\n        // Update excessReturned for `claim()`.\n        excessReturned = _getFundingLockerBalance().sub(_feePaid);\n\n        // Drain remaining funds from the FundingLocker (amount equal to `excessReturned` plus `feePaid`)\n        _fundingLocker.drain();\n\n        // Call `updateFundsReceived()` update LoanFDT accounting with funds received from fees and excess returned.\n        updateFundsReceived();\n\n        _emitBalanceUpdateEventForCollateralLocker();\n        _emitBalanceUpdateEventForFundingLocker();\n        _emitBalanceUpdateEventForLoan();\n\n        emit BalanceUpdated(treasury, address(liquidityAsset), liquidityAsset.balanceOf(treasury));\n        emit LoanStateChanged(State.Active);\n        emit Drawdown(amt);\n    }\n\n    /**\n        @dev Makes a payment for this Loan. Amounts are calculated for the Borrower.\n    */\n    function makePayment() external {\n        _whenProtocolNotPaused();\n        _isValidState(State.Active);\n        (uint256 total, uint256 principal, uint256 interest,, bool paymentLate) = getNextPayment();\n        --paymentsRemaining;\n        _makePayment(total, principal, interest, paymentLate);\n    }\n\n    /**\n        @dev Makes the full payment for this Loan (a.k.a. \"calling\" the Loan). This requires the Borrower to pay a premium fee.\n    */\n    function makeFullPayment() external {\n        _whenProtocolNotPaused();\n        _isValidState(State.Active);\n        (uint256 total, uint256 principal, uint256 interest) = getFullPayment();\n        paymentsRemaining = uint256(0);\n        _makePayment(total, principal, interest, false);\n    }\n\n    /**\n        @dev Updates the payment variables and transfers funds from the Borrower into the Loan.\n        @dev It emits one or two `BalanceUpdated` events (depending if payments remaining).\n        @dev It emits a `LoanStateChanged` event if no payments remaining.\n        @dev It emits a `PaymentMade` event.\n    */\n    function _makePayment(uint256 total, uint256 principal, uint256 interest, bool paymentLate) internal {\n\n        // Caching to reduce `SLOADs`.\n        uint256 _paymentsRemaining = paymentsRemaining;\n\n        // Update internal accounting variables.\n        interestPaid = interestPaid.add(interest);\n        if (principal > uint256(0)) principalPaid = principalPaid.add(principal);\n\n        if (_paymentsRemaining > uint256(0)) {\n            // Update info related to next payment and, if needed, decrement principalOwed.\n            nextPaymentDue = nextPaymentDue.add(paymentIntervalSeconds);\n            if (principal > uint256(0)) principalOwed = principalOwed.sub(principal);\n        } else {\n            // Update info to close loan.\n            principalOwed  = uint256(0);\n            loanState      = State.Matured;\n            nextPaymentDue = uint256(0);\n\n            // Transfer all collateral back to the Borrower.\n            ICollateralLocker(collateralLocker).pull(borrower, _getCollateralLockerBalance());\n            _emitBalanceUpdateEventForCollateralLocker();\n            emit LoanStateChanged(State.Matured);\n        }\n\n        // Loan payer sends funds to the Loan.\n        liquidityAsset.safeTransferFrom(msg.sender, address(this), total);\n\n        // Update FDT accounting with funds received from interest payment.\n        updateFundsReceived();\n\n        emit PaymentMade(\n            total,\n            principal,\n            interest,\n            _paymentsRemaining,\n            principalOwed,\n            _paymentsRemaining > 0 ? nextPaymentDue : 0,\n            paymentLate\n        );\n\n        _emitBalanceUpdateEventForLoan();\n    }\n\n    /************************/\n    /*** Lender Functions ***/\n    /************************/\n\n    /**\n        @dev   Funds this Loan and mints LoanFDTs for `mintTo` (DebtLocker in the case of Pool funding).\n               Only LiquidityLocker using valid/approved Pool can call this function.\n        @dev   It emits a `LoanFunded` event.\n        @dev   It emits a `BalanceUpdated` event.\n        @param amt    Amount to fund the Loan.\n        @param mintTo Address that LoanFDTs are minted to.\n    */\n    function fundLoan(address mintTo, uint256 amt) whenNotPaused external {\n        _whenProtocolNotPaused();\n        _isValidState(State.Ready);\n        _isValidPool();\n        _isWithinFundingPeriod();\n        liquidityAsset.safeTransferFrom(msg.sender, fundingLocker, amt);\n\n        uint256 wad = _toWad(amt);  // Convert to WAD precision.\n        _mint(mintTo, wad);         // Mint LoanFDTs to `mintTo` (i.e DebtLocker contract).\n\n        emit LoanFunded(mintTo, amt);\n        _emitBalanceUpdateEventForFundingLocker();\n    }\n\n    /**\n        @dev Handles returning capital to the Loan, where it can be claimed back by LoanFDT holders,\n             if the Borrower has not drawn down on the Loan past the drawdown grace period.\n        @dev It emits a `LoanStateChanged` event.\n    */\n    function unwind() external {\n        _whenProtocolNotPaused();\n        _isValidState(State.Ready);\n\n        // Update accounting for `claim()` and transfer funds from FundingLocker to Loan.\n        excessReturned = LoanLib.unwind(liquidityAsset, fundingLocker, createdAt, fundingPeriod);\n\n        updateFundsReceived();\n\n        // Transition state to `Expired`.\n        loanState = State.Expired;\n        emit LoanStateChanged(State.Expired);\n    }\n\n    /**\n        @dev Triggers a default if the Loan meets certain default conditions, liquidating all collateral and updating accounting.\n             Only the an account with sufficient LoanFDTs of this Loan can call this function.\n        @dev It emits a `BalanceUpdated` event.\n        @dev It emits a `Liquidation` event.\n        @dev It emits a `LoanStateChanged` event.\n    */\n    function triggerDefault() external {\n        _whenProtocolNotPaused();\n        _isValidState(State.Active);\n        require(LoanLib.canTriggerDefault(nextPaymentDue, defaultGracePeriod, superFactory, balanceOf(msg.sender), totalSupply()), \"L:FAILED_TO_LIQ\");\n\n        // Pull the Collateral Asset from the CollateralLocker, swap to the Liquidity Asset, and hold custody of the resulting Liquidity Asset in the Loan.\n        (amountLiquidated, amountRecovered) = LoanLib.liquidateCollateral(collateralAsset, address(liquidityAsset), superFactory, collateralLocker);\n        _emitBalanceUpdateEventForCollateralLocker();\n\n        // Decrement `principalOwed` by `amountRecovered`, set `defaultSuffered` to the difference (shortfall from the liquidation).\n        if (amountRecovered <= principalOwed) {\n            principalOwed   = principalOwed.sub(amountRecovered);\n            defaultSuffered = principalOwed;\n        }\n        // Set `principalOwed` to zero and return excess value from the liquidation back to the Borrower.\n        else {\n            liquidationExcess = amountRecovered.sub(principalOwed);\n            principalOwed = 0;\n            liquidityAsset.safeTransfer(borrower, liquidationExcess);  // Send excess to the Borrower.\n        }\n\n        // Update LoanFDT accounting with funds received from the liquidation.\n        updateFundsReceived();\n\n        // Transition `loanState` to `Liquidated`\n        loanState = State.Liquidated;\n\n        emit Liquidation(\n            amountLiquidated,  // Amount of Collateral Asset swapped.\n            amountRecovered,   // Amount of Liquidity Asset recovered from swap.\n            liquidationExcess, // Amount of Liquidity Asset returned to borrower.\n            defaultSuffered    // Remaining losses after the liquidation.\n        );\n        emit LoanStateChanged(State.Liquidated);\n    }\n\n    /***********************/\n    /*** Admin Functions ***/\n    /***********************/\n\n    /**\n        @dev Triggers paused state. Halts functionality for certain functions. Only the Borrower or a Loan Admin can call this function.\n    */\n    function pause() external {\n        _isValidBorrowerOrLoanAdmin();\n        super._pause();\n    }\n\n    /**\n        @dev Triggers unpaused state. Restores functionality for certain functions. Only the Borrower or a Loan Admin can call this function.\n    */\n    function unpause() external {\n        _isValidBorrowerOrLoanAdmin();\n        super._unpause();\n    }\n\n    /**\n        @dev   Sets a Loan Admin. Only the Borrower can call this function.\n        @dev   It emits a `LoanAdminSet` event.\n        @param loanAdmin An address being allowed or disallowed as a Loan Admin.\n        @param allowed   Status of a Loan Admin.\n    */\n    function setLoanAdmin(address loanAdmin, bool allowed) external {\n        _whenProtocolNotPaused();\n        _isValidBorrower();\n        loanAdmins[loanAdmin] = allowed;\n        emit LoanAdminSet(loanAdmin, allowed);\n    }\n\n    /**************************/\n    /*** Governor Functions ***/\n    /**************************/\n\n    /**\n        @dev   Transfers any locked funds to the Governor. Only the Governor can call this function.\n        @param token Address of the token to be reclaimed.\n    */\n    function reclaimERC20(address token) external {\n        LoanLib.reclaimERC20(token, address(liquidityAsset), _globals(superFactory));\n    }\n\n    /*********************/\n    /*** FDT Functions ***/\n    /*********************/\n\n    /**\n        @dev Withdraws all available funds earned through LoanFDT for a token holder.\n        @dev It emits a `BalanceUpdated` event.\n    */\n    function withdrawFunds() public override {\n        _whenProtocolNotPaused();\n        super.withdrawFunds();\n        emit BalanceUpdated(address(this), address(fundsToken), fundsToken.balanceOf(address(this)));\n    }\n\n    /************************/\n    /*** Getter Functions ***/\n    /************************/\n\n    /**\n        @dev    Returns the expected amount of Liquidity Asset to be recovered from a liquidation based on current oracle prices.\n        @return The minimum amount of Liquidity Asset that can be expected by swapping Collateral Asset.\n    */\n    function getExpectedAmountRecovered() external view returns (uint256) {\n        uint256 liquidationAmt = _getCollateralLockerBalance();\n        return Util.calcMinAmount(_globals(superFactory), address(collateralAsset), address(liquidityAsset), liquidationAmt);\n    }\n\n    /**\n        @dev    Returns information of the next payment amount.\n        @return [0] = Entitled interest of the next payment (Principal + Interest only when the next payment is last payment of the Loan)\n                [1] = Entitled principal amount needed to be paid in the next payment\n                [2] = Entitled interest amount needed to be paid in the next payment\n                [3] = Payment Due Date\n                [4] = Is Payment Late\n    */\n    function getNextPayment() public view returns (uint256, uint256, uint256, uint256, bool) {\n        return LoanLib.getNextPayment(repaymentCalc, nextPaymentDue, lateFeeCalc);\n    }\n\n    /**\n        @dev    Returns the information of a full payment amount.\n        @return total     Principal and interest owed, combined.\n        @return principal Principal owed.\n        @return interest  Interest owed.\n    */\n    function getFullPayment() public view returns (uint256 total, uint256 principal, uint256 interest) {\n        (total, principal, interest) = LoanLib.getFullPayment(repaymentCalc, nextPaymentDue, lateFeeCalc, premiumCalc);\n    }\n\n    /**\n        @dev    Calculates the collateral required to draw down amount.\n        @param  amt The amount of the Liquidity Asset to draw down from the FundingLocker.\n        @return The amount of the Collateral Asset required to post in the CollateralLocker for a given drawdown amount.\n    */\n    function collateralRequiredForDrawdown(uint256 amt) public view returns (uint256) {\n        return LoanLib.collateralRequiredForDrawdown(\n            IERC20Details(address(collateralAsset)),\n            IERC20Details(address(liquidityAsset)),\n            collateralRatio,\n            superFactory,\n            amt\n        );\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /**\n        @dev Checks that the protocol is not in a paused state.\n    */\n    function _whenProtocolNotPaused() internal view {\n        require(!_globals(superFactory).protocolPaused(), \"L:PROTO_PAUSED\");\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Borrower or a Loan Admin.\n    */\n    function _isValidBorrowerOrLoanAdmin() internal view {\n        require(msg.sender == borrower || loanAdmins[msg.sender], \"L:NOT_BORROWER_OR_ADMIN\");\n    }\n\n    /**\n        @dev Converts to WAD precision.\n    */\n    function _toWad(uint256 amt) internal view returns (uint256) {\n        return amt.mul(10 ** 18).div(10 ** IERC20Details(address(liquidityAsset)).decimals());\n    }\n\n    /**\n        @dev Returns the MapleGlobals instance.\n    */\n    function _globals(address loanFactory) internal view returns (IMapleGlobals) {\n        return IMapleGlobals(ILoanFactory(loanFactory).globals());\n    }\n\n    /**\n        @dev Returns the CollateralLocker balance.\n    */\n    function _getCollateralLockerBalance() internal view returns (uint256) {\n        return collateralAsset.balanceOf(collateralLocker);\n    }\n\n    /**\n        @dev Returns the FundingLocker balance.\n    */\n    function _getFundingLockerBalance() internal view returns (uint256) {\n        return liquidityAsset.balanceOf(fundingLocker);\n    }\n\n    /**\n        @dev   Checks that the current state of the Loan matches the provided state.\n        @param _state Enum of desired Loan state.\n    */\n    function _isValidState(State _state) internal view {\n        require(loanState == _state, \"L:INVALID_STATE\");\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Borrower.\n    */\n    function _isValidBorrower() internal view {\n        require(msg.sender == borrower, \"L:NOT_BORROWER\");\n    }\n\n    /**\n        @dev Checks that `msg.sender` is a Lender (LiquidityLocker) that is using an approved Pool to fund the Loan.\n    */\n    function _isValidPool() internal view {\n        address pool        = ILiquidityLocker(msg.sender).pool();\n        address poolFactory = IPool(pool).superFactory();\n        require(\n            _globals(superFactory).isValidPoolFactory(poolFactory) &&\n            IPoolFactory(poolFactory).isPool(pool),\n            \"L:INVALID_LENDER\"\n        );\n    }\n\n    /**\n        @dev Checks that \"now\" is currently within the funding period.\n    */\n    function _isWithinFundingPeriod() internal view {\n        require(block.timestamp <= createdAt.add(fundingPeriod), \"L:PAST_FUNDING_PERIOD\");\n    }\n\n    /**\n        @dev   Transfers funds from the FundingLocker.\n        @param from  Instance of the FundingLocker.\n        @param to    Address to send funds to.\n        @param value Amount to send.\n    */\n    function _transferFunds(IFundingLocker from, address to, uint256 value) internal {\n        from.pull(to, value);\n    }\n\n    /**\n        @dev Emits a `BalanceUpdated` event for the Loan.\n        @dev It emits a `BalanceUpdated` event.\n    */\n    function _emitBalanceUpdateEventForLoan() internal {\n        emit BalanceUpdated(address(this), address(liquidityAsset), liquidityAsset.balanceOf(address(this)));\n    }\n\n    /**\n        @dev Emits a `BalanceUpdated` event for the FundingLocker.\n        @dev It emits a `BalanceUpdated` event.\n    */\n    function _emitBalanceUpdateEventForFundingLocker() internal {\n        emit BalanceUpdated(fundingLocker, address(liquidityAsset), _getFundingLockerBalance());\n    }\n\n    /**\n        @dev Emits a `BalanceUpdated` event for the CollateralLocker.\n        @dev It emits a `BalanceUpdated` event.\n    */\n    function _emitBalanceUpdateEventForCollateralLocker() internal {\n        emit BalanceUpdated(collateralLocker, address(collateralAsset), _getCollateralLockerBalance());\n    }\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IStakeLocker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"../token/interfaces/IStakeLockerFDT.sol\";\n\ninterface IStakeLocker is IStakeLockerFDT {\n\n    function stakeDate(address) external returns (uint256);\n\n    function stake(uint256) external;\n\n    function unstake(uint256) external;\n\n    function pull(address, uint256) external;\n\n    function setAllowlist(address, bool) external;\n\n    function openStakeLockerToPublic() external;\n\n    function openToPublic() external view returns (bool);\n\n    function allowed(address) external view returns (bool);\n\n    function updateLosses(uint256) external;\n\n    function intendToUnstake() external;\n\n    function unstakeCooldown(address) external view returns (uint256);\n\n    function lockupPeriod() external view returns (uint256);\n\n    function stakeAsset() external view returns (address);\n\n    function liquidityAsset() external view returns (address);\n\n    function pool() external view returns (address);\n\n    function setLockupPeriod(uint256) external;\n\n    function cancelUnstake() external;\n\n    function increaseCustodyAllowance(address, uint256) external;\n\n    function transferByCustodian(address, address, uint256) external;\n\n    function pause() external;\n\n    function unpause() external;\n\n    function isUnstakeAllowed(address) external view returns (bool);\n\n    function isReceiveAllowed(uint256) external view returns (bool);\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/ILoan.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"../token/interfaces/ILoanFDT.sol\";\n\ninterface ILoan is ILoanFDT {\n    \n    // State Variables\n    function liquidityAsset() external view returns (address);\n    \n    function collateralAsset() external view returns (address);\n    \n    function fundingLocker() external view returns (address);\n    \n    function flFactory() external view returns (address);\n    \n    function collateralLocker() external view returns (address);\n    \n    function clFactory() external view returns (address);\n    \n    function borrower() external view returns (address);\n    \n    function repaymentCalc() external view returns (address);\n    \n    function lateFeeCalc() external view returns (address);\n    \n    function premiumCalc() external view returns (address);\n    \n    function loanState() external view returns (uint256);\n    \n    function collateralRequiredForDrawdown(uint256) external view returns (uint256);\n    \n\n    // Loan Specifications\n    function apr() external view returns (uint256);\n    \n    function paymentsRemaining() external view returns (uint256);\n    \n    function paymentIntervalSeconds() external view returns (uint256);\n    \n    function requestAmount() external view returns (uint256);\n    \n    function collateralRatio() external view returns (uint256);\n    \n    function fundingPeriod() external view returns (uint256);\n\n    function defaultGracePeriod() external view returns (uint256);\n    \n    function createdAt() external view returns (uint256);\n    \n    function principalOwed() external view returns (uint256);\n    \n    function principalPaid() external view returns (uint256);\n    \n    function interestPaid() external view returns (uint256);\n    \n    function feePaid() external view returns (uint256);\n    \n    function excessReturned() external view returns (uint256);\n    \n    function getNextPayment() external view returns (uint256, uint256, uint256, uint256);\n    \n    function superFactory() external view returns (address);\n    \n    function termDays() external view returns (uint256);\n    \n    function nextPaymentDue() external view returns (uint256);\n\n    function getFullPayment() external view returns (uint256, uint256, uint256);\n    \n\n    // Liquidations\n    function amountLiquidated() external view returns (uint256);\n\n    function defaultSuffered() external view returns (uint256);\n    \n    function amountRecovered() external view returns (uint256);\n    \n    function getExpectedAmountRecovered() external view returns (uint256);\n\n    function liquidationExcess() external view returns (uint256);\n    \n\n    // Functions\n    function fundLoan(address, uint256) external;\n    \n    function makePayment() external;\n    \n    function drawdown(uint256) external;\n    \n    function makeFullPayment() external;\n    \n    function triggerDefault() external;\n    \n    function unwind() external;\n    \n\n    // Security \n    function pause() external;\n\n    function unpause() external;\n\n    function loanAdmins(address) external view returns (address);\n\n    function setLoanAdmin(address, bool) external;\n\n\n    // Misc\n    function reclaimERC20(address) external;\n\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "packages/protocol/contracts/interfaces/ICollateralLocker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface ICollateralLocker {\n\n    function collateralAsset() external view returns (address);\n\n    function loan() external view returns (address);\n\n    function pull(address, uint256) external;\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/ICollateralLockerFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface ICollateralLockerFactory {\n\n    function owner(address) external view returns (address);\n    \n    function isLocker(address) external view returns (bool);\n\n    function factoryType() external view returns (uint8);\n\n    function newLocker(address) external returns (address);\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IERC20Details.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Details is IERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IFundingLocker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IFundingLocker {\n\n    function liquidityAsset() external view returns (address);\n\n    function loan() external view returns (address);\n\n    function pull(address, uint256) external;\n\n    function drain() external;\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IFundingLockerFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IFundingLockerFactory {\n\n    function owner(address) external view returns (address);\n    \n    function isLocker(address) external view returns (bool);\n\n    function factoryType() external view returns (uint8);\n    \n    function newLocker(address) external returns (address);\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IMapleGlobals.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IMapleGlobals {\n\n    function pendingGovernor() external view returns (address);\n\n    function governor() external view returns (address);\n\n    function globalAdmin() external view returns (address);\n\n    function mpl() external view returns (address);\n\n    function mapleTreasury() external view returns (address);\n\n    function isValidBalancerPool(address) external view returns (bool);\n\n    function treasuryFee() external view returns (uint256);\n\n    function investorFee() external view returns (uint256);\n\n    function defaultGracePeriod() external view returns (uint256);\n\n    function fundingPeriod() external view returns (uint256);\n\n    function swapOutRequired() external view returns (uint256);\n\n    function isValidLiquidityAsset(address) external view returns (bool);\n\n    function isValidCollateralAsset(address) external view returns (bool);\n\n    function isValidPoolDelegate(address) external view returns (bool);\n\n    function validCalcs(address) external view returns (bool);\n\n    function isValidCalc(address, uint8) external view returns (bool);\n\n    function getLpCooldownParams() external view returns (uint256, uint256);\n\n    function isValidLoanFactory(address) external view returns (bool);\n\n    function isValidSubFactory(address, address, uint8) external view returns (bool);\n\n    function isValidPoolFactory(address) external view returns (bool);\n    \n    function getLatestPrice(address) external view returns (uint256);\n    \n    function defaultUniswapPath(address, address) external view returns (address);\n\n    function minLoanEquity() external view returns (uint256);\n    \n    function maxSwapSlippage() external view returns (uint256);\n\n    function protocolPaused() external view returns (bool);\n\n    function stakerCooldownPeriod() external view returns (uint256);\n\n    function lpCooldownPeriod() external view returns (uint256);\n\n    function stakerUnstakeWindow() external view returns (uint256);\n\n    function lpWithdrawWindow() external view returns (uint256);\n\n    function oracleFor(address) external view returns (address);\n\n    function validSubFactories(address, address) external view returns (bool);\n\n    function setStakerCooldownPeriod(uint256) external;\n\n    function setLpCooldownPeriod(uint256) external;\n\n    function setStakerUnstakeWindow(uint256) external;\n\n    function setLpWithdrawWindow(uint256) external;\n\n    function setMaxSwapSlippage(uint256) external;\n\n    function setGlobalAdmin(address) external;\n\n    function setValidBalancerPool(address, bool) external;\n\n    function setProtocolPause(bool) external;\n\n    function setValidPoolFactory(address, bool) external;\n\n    function setValidLoanFactory(address, bool) external;\n\n    function setValidSubFactory(address, address, bool) external;\n\n    function setDefaultUniswapPath(address, address, address) external;\n\n    function setPoolDelegateAllowlist(address, bool) external;\n\n    function setCollateralAsset(address, bool) external;\n\n    function setLiquidityAsset(address, bool) external;\n\n    function setCalc(address, bool) external;\n\n    function setInvestorFee(uint256) external;\n\n    function setTreasuryFee(uint256) external;\n\n    function setMapleTreasury(address) external;\n\n    function setDefaultGracePeriod(uint256) external;\n\n    function setMinLoanEquity(uint256) external;\n\n    function setFundingPeriod(uint256) external;\n\n    function setSwapOutRequired(uint256) external;\n\n    function setPriceOracle(address, address) external;\n\n    function setPendingGovernor(address) external;\n\n    function acceptGovernor() external;\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/ILateFeeCalc.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface ILateFeeCalc {\n\n    function calcType() external view returns (uint8);\n\n    function name() external view returns (bytes32);\n\n    function lateFee() external view returns (uint256);\n\n    function getLateFee(uint256) external view returns (uint256);\n\n} \n"
    },
    "packages/protocol/contracts/interfaces/ILiquidityLocker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface ILiquidityLocker {\n\n    function pool() external view returns (address);\n\n    function liquidityAsset() external view returns (address);\n\n    function transfer(address, uint256) external;\n\n    function fundLoan(address, address, uint256) external;\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"../token/interfaces/IPoolFDT.sol\";\n\ninterface IPool is IPoolFDT {\n\n    function poolDelegate() external view returns (address);\n\n    function poolAdmins(address) external view returns (bool);\n\n    function deposit(uint256) external;\n\n    function increaseCustodyAllowance(address, uint256) external;\n\n    function transferByCustodian(address, address, uint256) external;\n\n    function poolState() external view returns (uint256);\n\n    function deactivate() external;\n\n    function finalize() external;\n\n    function claim(address, address) external returns (uint256[7] memory);\n\n    function setLockupPeriod(uint256) external;\n    \n    function setStakingFee(uint256) external;\n\n    function setPoolAdmin(address, bool) external;\n\n    function fundLoan(address, address, uint256) external;\n\n    function withdraw(uint256) external;\n\n    function superFactory() external view returns (address);\n\n    function triggerDefault(address, address) external;\n\n    function isPoolFinalized() external view returns (bool);\n\n    function setOpenToPublic(bool) external;\n\n    function setAllowList(address, bool) external;\n\n    function allowedLiquidityProviders(address) external view returns (bool);\n\n    function openToPublic() external view returns (bool);\n\n    function intendToWithdraw() external;\n\n    function DL_FACTORY() external view returns (uint8);\n\n    function liquidityAsset() external view returns (address);\n\n    function liquidityLocker() external view returns (address);\n\n    function stakeAsset() external view returns (address);\n\n    function stakeLocker() external view returns (address);\n\n    function stakingFee() external view returns (uint256);\n\n    function delegateFee() external view returns (uint256);\n\n    function principalOut() external view returns (uint256);\n\n    function liquidityCap() external view returns (uint256);\n\n    function lockupPeriod() external view returns (uint256);\n\n    function depositDate(address) external view returns (uint256);\n\n    function debtLockers(address, address) external view returns (address);\n\n    function withdrawCooldown(address) external view returns (uint256);\n\n    function setLiquidityCap(uint256) external;\n\n    function cancelWithdraw() external;\n\n    function reclaimERC20(address) external;\n\n    function BPTVal(address, address, address, address) external view returns (uint256);\n\n    function isDepositAllowed(uint256) external view returns (bool);\n\n    function getInitialStakeRequirements() external view returns (uint256, uint256, bool, uint256, uint256);\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IPoolFactory {\n\n    function LL_FACTORY() external view returns (uint8);\n\n    function SL_FACTORY() external view returns (uint8);\n\n    function poolsCreated() external view returns (uint256);\n\n    function globals() external view returns (address);\n\n    function pools(uint256) external view returns (address);\n\n    function isPool(address) external view returns (bool);\n\n    function poolFactoryAdmins(address) external view returns (bool);\n\n    function setGlobals(address) external;\n\n    function createPool(address, address, address, address, uint256, uint256, uint256) external returns (address);\n\n    function setPoolFactoryAdmin(address, bool) external;\n\n    function pause() external;\n\n    function unpause() external;\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IPremiumCalc.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IPremiumCalc {\n\n    function calcType() external view returns (uint8);\n\n    function name() external view returns (bytes32);\n\n    function premiumFee() external view returns (uint256);\n\n    function getPremiumPayment(address) external view returns (uint256, uint256, uint256);\n\n} \n"
    },
    "packages/protocol/contracts/interfaces/IRepaymentCalc.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IRepaymentCalc {\n\n    function calcType() external view returns (uint8);\n\n    function name() external view returns (bytes32);\n\n    function getNextPayment(address) external view returns (uint256, uint256, uint256);\n\n} \n"
    },
    "packages/protocol/contracts/interfaces/IUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IUniswapRouter {\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function WETH() external pure returns (address);\n\n}\n"
    },
    "packages/protocol/contracts/library/Util.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"../interfaces/IERC20Details.sol\";\nimport \"../interfaces/IMapleGlobals.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/// @title Util is a library that contains utility functions.\nlibrary Util {\n\n    using SafeMath for uint256;\n\n    /**\n        @dev    Calculates the minimum amount from a swap (adjustable for price slippage).\n        @param  globals   Instance of a MapleGlobals.\n        @param  fromAsset Address of ERC-20 that will be swapped.\n        @param  toAsset   Address of ERC-20 that will returned from swap.\n        @param  swapAmt   Amount of `fromAsset` to be swapped.\n        @return Expected amount of `toAsset` to receive from swap based on current oracle prices.\n    */\n    function calcMinAmount(IMapleGlobals globals, address fromAsset, address toAsset, uint256 swapAmt) external view returns (uint256) {\n        return\n            swapAmt\n                .mul(globals.getLatestPrice(fromAsset))           // Convert from `fromAsset` value.\n                .mul(10 ** IERC20Details(toAsset).decimals())     // Convert to `toAsset` decimal precision.\n                .div(globals.getLatestPrice(toAsset))             // Convert to `toAsset` value.\n                .div(10 ** IERC20Details(fromAsset).decimals());  // Convert from `fromAsset` decimal precision.\n    }\n}\n"
    },
    "packages/protocol/contracts/library/LoanLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"../interfaces/ICollateralLocker.sol\";\nimport \"../interfaces/ICollateralLockerFactory.sol\";\nimport \"../interfaces/IERC20Details.sol\";\nimport \"../interfaces/IFundingLocker.sol\";\nimport \"../interfaces/IFundingLockerFactory.sol\";\nimport \"../interfaces/IMapleGlobals.sol\";\nimport \"../interfaces/ILateFeeCalc.sol\";\nimport \"../interfaces/ILoanFactory.sol\";\nimport \"../interfaces/IPremiumCalc.sol\";\nimport \"../interfaces/IRepaymentCalc.sol\";\nimport \"../interfaces/IUniswapRouter.sol\";\n\nimport \"../library/Util.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/// @title LoanLib is a library of utility functions used by Loan.\nlibrary LoanLib {\n\n    using SafeMath  for uint256;\n    using SafeERC20 for IERC20;\n\n    address public constant UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    /********************************/\n    /*** Lender Utility Functions ***/\n    /********************************/\n\n    /**\n        @dev    Performs sanity checks on the data passed in Loan constructor.\n        @param  globals         Instance of a MapleGlobals.\n        @param  liquidityAsset  Contract address of the Liquidity Asset.\n        @param  collateralAsset Contract address of the Collateral Asset.\n        @param  specs           Contains specifications for this Loan.\n    */\n    function loanSanityChecks(IMapleGlobals globals, address liquidityAsset, address collateralAsset, uint256[5] calldata specs) external view {\n        require(globals.isValidLiquidityAsset(liquidityAsset),   \"L:INVALID_LIQ_ASSET\");\n        require(globals.isValidCollateralAsset(collateralAsset), \"L:INVALID_COL_ASSET\");\n\n        require(specs[2] != uint256(0),               \"L:ZERO_PID\");\n        require(specs[1].mod(specs[2]) == uint256(0), \"L:INVALID_TERM_DAYS\");\n        require(specs[3] > uint256(0),                \"L:ZERO_REQUEST_AMT\");\n    }\n\n    /**\n        @dev    Returns capital to Lenders, if the Borrower has not drawn down the Loan past the grace period.\n        @param  liquidityAsset IERC20 of the Liquidity Asset.\n        @param  fundingLocker  Address of FundingLocker.\n        @param  createdAt      Timestamp of Loan instantiation.\n        @param  fundingPeriod  Duration of the funding period, after which funds can be reclaimed.\n        @return excessReturned Amount of Liquidity Asset that was returned to the Loan from the FundingLocker.\n    */\n    function unwind(IERC20 liquidityAsset, address fundingLocker, uint256 createdAt, uint256 fundingPeriod) external returns (uint256 excessReturned) {\n        // Only callable if Loan funding period has elapsed.\n        require(block.timestamp > createdAt.add(fundingPeriod), \"L:STILL_FUNDING_PERIOD\");\n\n        // Account for existing balance in Loan.\n        uint256 preBal = liquidityAsset.balanceOf(address(this));\n\n        // Drain funding from FundingLocker, transfers all the Liquidity Asset to this Loan.\n        IFundingLocker(fundingLocker).drain();\n\n        return liquidityAsset.balanceOf(address(this)).sub(preBal);\n    }\n\n    /**\n        @dev    Liquidates a Borrower's collateral, via Uniswap, when a default is triggered. Only the Loan can call this function.\n        @param  collateralAsset  IERC20 of the Collateral Asset.\n        @param  liquidityAsset   Address of Liquidity Asset.\n        @param  superFactory     Factory that instantiated Loan.\n        @param  collateralLocker Address of CollateralLocker.\n        @return amountLiquidated Amount of Collateral Asset that was liquidated.\n        @return amountRecovered  Amount of Liquidity Asset that was returned to the Loan from the liquidation.\n    */\n    function liquidateCollateral(\n        IERC20  collateralAsset,\n        address liquidityAsset,\n        address superFactory,\n        address collateralLocker\n    )\n        external\n        returns (\n            uint256 amountLiquidated,\n            uint256 amountRecovered\n        )\n    {\n        // Get the liquidation amount from CollateralLocker.\n        uint256 liquidationAmt = collateralAsset.balanceOf(address(collateralLocker));\n\n        // Pull the Collateral Asset from CollateralLocker.\n        ICollateralLocker(collateralLocker).pull(address(this), liquidationAmt);\n\n        if (address(collateralAsset) == liquidityAsset || liquidationAmt == uint256(0)) return (liquidationAmt, liquidationAmt);\n\n        collateralAsset.safeApprove(UNISWAP_ROUTER, uint256(0));\n        collateralAsset.safeApprove(UNISWAP_ROUTER, liquidationAmt);\n\n        IMapleGlobals globals = _globals(superFactory);\n\n        // Get minimum amount of loan asset get after swapping collateral asset.\n        uint256 minAmount = Util.calcMinAmount(globals, address(collateralAsset), liquidityAsset, liquidationAmt);\n\n        // Generate Uniswap path.\n        address uniswapAssetForPath = globals.defaultUniswapPath(address(collateralAsset), liquidityAsset);\n        bool middleAsset = uniswapAssetForPath != liquidityAsset && uniswapAssetForPath != address(0);\n\n        address[] memory path = new address[](middleAsset ? 3 : 2);\n\n        path[0] = address(collateralAsset);\n        path[1] = middleAsset ? uniswapAssetForPath : liquidityAsset;\n\n        if (middleAsset) path[2] = liquidityAsset;\n\n        // Swap collateralAsset for Liquidity Asset.\n        uint256[] memory returnAmounts = IUniswapRouter(UNISWAP_ROUTER).swapExactTokensForTokens(\n            liquidationAmt,\n            minAmount.sub(minAmount.mul(globals.maxSwapSlippage()).div(10_000)),\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        return(returnAmounts[0], returnAmounts[path.length - 1]);\n    }\n\n    /**********************************/\n    /*** Governor Utility Functions ***/\n    /**********************************/\n\n    /**\n        @dev   Transfers any locked funds to the Governor. Only the Governor can call this function.\n        @param token          Address of the token to be reclaimed.\n        @param liquidityAsset Address of token that is used by the loan for drawdown and payments.\n        @param globals        Instance of a MapleGlobals.\n    */\n    function reclaimERC20(address token, address liquidityAsset, IMapleGlobals globals) external {\n        require(msg.sender == globals.governor(),               \"L:NOT_GOV\");\n        require(token != liquidityAsset && token != address(0), \"L:INVALID_TOKEN\");\n        IERC20(token).safeTransfer(msg.sender, IERC20(token).balanceOf(address(this)));\n    }\n\n    /************************/\n    /*** Getter Functions ***/\n    /************************/\n\n    /**\n        @dev    Returns if a default can be triggered.\n        @param  nextPaymentDue     Timestamp of when payment is due.\n        @param  defaultGracePeriod Amount of time after the next payment is due that a Borrower has before a liquidation can occur.\n        @param  superFactory       Factory that instantiated Loan.\n        @param  balance            LoanFDT balance of account trying to trigger a default.\n        @param  totalSupply        Total supply of LoanFDT.\n        @return Boolean indicating if default can be triggered.\n    */\n    function canTriggerDefault(uint256 nextPaymentDue, uint256 defaultGracePeriod, address superFactory, uint256 balance, uint256 totalSupply) external view returns (bool) {\n        bool pastDefaultGracePeriod = block.timestamp > nextPaymentDue.add(defaultGracePeriod);\n\n        // Check if the Loan is past the default grace period and that the account triggering the default has a percentage of total LoanFDTs\n        // that is greater than the minimum equity needed (specified in globals)\n        return pastDefaultGracePeriod && balance >= ((totalSupply * _globals(superFactory).minLoanEquity()) / 10_000);\n    }\n\n    /**\n        @dev    Returns information on next payment amount.\n        @param  repaymentCalc   Address of RepaymentCalc.\n        @param  nextPaymentDue  Timestamp of when payment is due.\n        @param  lateFeeCalc     Address of LateFeeCalc.\n        @return total           Entitled total amount needed to be paid in the next payment (Principal + Interest only when the next payment is last payment of the Loan).\n        @return principal       Entitled principal amount needed to be paid in the next payment.\n        @return interest        Entitled interest amount needed to be paid in the next payment.\n        @return _nextPaymentDue Payment Due Date.\n        @return paymentLate     Whether payment is late.\n    */\n    function getNextPayment(\n        address repaymentCalc,\n        uint256 nextPaymentDue,\n        address lateFeeCalc\n    )\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 principal,\n            uint256 interest,\n            uint256 _nextPaymentDue,\n            bool    paymentLate\n        )\n    {\n        _nextPaymentDue  = nextPaymentDue;\n\n        // Get next payment amounts from RepaymentCalc.\n        (total, principal, interest) = IRepaymentCalc(repaymentCalc).getNextPayment(address(this));\n\n        paymentLate = block.timestamp > _nextPaymentDue;\n\n        // If payment is late, add late fees.\n        if (paymentLate) {\n            uint256 lateFee = ILateFeeCalc(lateFeeCalc).getLateFee(interest);\n\n            total    = total.add(lateFee);\n            interest = interest.add(lateFee);\n        }\n    }\n\n    /**\n        @dev    Returns information on full payment amount.\n        @param  repaymentCalc   Address of RepaymentCalc.\n        @param  nextPaymentDue  Timestamp of when payment is due.\n        @param  lateFeeCalc     Address of LateFeeCalc.\n        @param  premiumCalc     Address of PremiumCalc.\n        @return total           Principal + Interest for the full payment.\n        @return principal       Entitled principal amount needed to be paid in the full payment.\n        @return interest        Entitled interest amount needed to be paid in the full payment.\n    */\n    function getFullPayment(\n        address repaymentCalc,\n        uint256 nextPaymentDue,\n        address lateFeeCalc,\n        address premiumCalc\n    )\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 principal,\n            uint256 interest\n        )\n    {\n        (total, principal, interest) = IPremiumCalc(premiumCalc).getPremiumPayment(address(this));\n\n        if (block.timestamp <= nextPaymentDue) return (total, principal, interest);\n\n        // If payment is late, calculate and add late fees using interest amount from regular payment.\n        (,, uint256 regInterest) = IRepaymentCalc(repaymentCalc).getNextPayment(address(this));\n\n        uint256 lateFee = ILateFeeCalc(lateFeeCalc).getLateFee(regInterest);\n\n        total    = total.add(lateFee);\n        interest = interest.add(lateFee);\n    }\n\n    /**\n        @dev    Calculates collateral required to drawdown amount.\n        @param  collateralAsset IERC20 of the Collateral Asset.\n        @param  liquidityAsset  IERC20 of the Liquidity Asset.\n        @param  collateralRatio Percentage of drawdown value that must be posted as collateral.\n        @param  superFactory    Factory that instantiated Loan.\n        @param  amt             Drawdown amount.\n        @return Amount of Collateral Asset required to post in CollateralLocker for given drawdown amount.\n    */\n    function collateralRequiredForDrawdown(\n        IERC20Details collateralAsset,\n        IERC20Details liquidityAsset,\n        uint256 collateralRatio,\n        address superFactory,\n        uint256 amt\n    )\n        external\n        view\n        returns (uint256)\n    {\n        IMapleGlobals globals = _globals(superFactory);\n\n        uint256 wad = _toWad(amt, liquidityAsset);  // Convert to WAD precision.\n\n        // Fetch current value of Liquidity Asset and Collateral Asset (Chainlink oracles provide 8 decimal precision).\n        uint256 liquidityAssetPrice  = globals.getLatestPrice(address(liquidityAsset));\n        uint256 collateralPrice = globals.getLatestPrice(address(collateralAsset));\n\n        // Calculate collateral required.\n        uint256 collateralRequiredUSD = wad.mul(liquidityAssetPrice).mul(collateralRatio).div(10_000);  // 18 + 8 = 26 decimals\n        uint256 collateralRequiredWAD = collateralRequiredUSD.div(collateralPrice);                     // 26 - 8 = 18 decimals\n\n        return collateralRequiredWAD.mul(10 ** collateralAsset.decimals()).div(10 ** 18);  // 18 + collateralAssetDecimals - 18 = collateralAssetDecimals\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    function _globals(address loanFactory) internal view returns (IMapleGlobals) {\n        return IMapleGlobals(ILoanFactory(loanFactory).globals());\n    }\n\n    function _toWad(uint256 amt, IERC20Details liquidityAsset) internal view returns (uint256) {\n        return amt.mul(10 ** 18).div(10 ** liquidityAsset.decimals());\n    }\n}\n"
    },
    "packages/protocol/contracts/token/LoanFDT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./BasicFDT.sol\";\n\n/// @title LoanFDT inherits BasicFDT and uses the original ERC-2222 logic.\nabstract contract LoanFDT is BasicFDT {\n    using SafeMath       for uint256;\n    using SafeMathUint   for uint256;\n    using SignedSafeMath for  int256;\n    using SafeMathInt    for  int256;\n    using SafeERC20      for  IERC20;\n\n    IERC20 public immutable fundsToken; // The `fundsToken` (dividends).\n\n    uint256 public fundsTokenBalance;   // The amount of `fundsToken` (Liquidity Asset) currently present and accounted for in this contract.\n\n    constructor(string memory name, string memory symbol, address _fundsToken) BasicFDT(name, symbol) public {\n        fundsToken = IERC20(_fundsToken);\n    }\n\n    /**\n        @dev Withdraws all available funds for a token holder.\n    */\n    function withdrawFunds() public virtual override {\n        uint256 withdrawableFunds = _prepareWithdraw();\n\n        if (withdrawableFunds > uint256(0)) {\n            fundsToken.safeTransfer(msg.sender, withdrawableFunds);\n\n            _updateFundsTokenBalance();\n        }\n    }\n\n    /**\n        @dev    Updates the current `fundsToken` balance and returns the difference of the new and previous `fundsToken` balance.\n        @return A int256 representing the difference of the new and previous `fundsToken` balance.\n    */\n    function _updateFundsTokenBalance() internal virtual override returns (int256) {\n        uint256 _prevFundsTokenBalance = fundsTokenBalance;\n\n        fundsTokenBalance = fundsToken.balanceOf(address(this));\n\n        return int256(fundsTokenBalance).sub(int256(_prevFundsTokenBalance));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "packages/protocol/contracts/token/interfaces/IPoolFDT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./IExtendedFDT.sol\";\n\ninterface IPoolFDT is IExtendedFDT {\n\n    function interestSum() external view returns (uint256);\n\n    function poolLosses() external view returns (uint256);\n\n    function interestBalance() external view returns (uint256);\n\n    function lossesBalance() external view returns (uint256);\n\n}\n"
    },
    "packages/protocol/contracts/token/interfaces/IExtendedFDT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./IBasicFDT.sol\";\n\ninterface IExtendedFDT is IBasicFDT {\n\n    event LossesPerShareUpdated(uint256);\n\n    event LossesCorrectionUpdated(address indexed, int256);\n\n    event LossesDistributed(address indexed, uint256);\n\n    event LossesRecognized(address indexed, uint256, uint256);\n\n    function lossesPerShare() external view returns (uint256);\n\n    function recognizableLossesOf(address) external view returns (uint256);\n\n    function recognizedLossesOf(address) external view returns (uint256);\n\n    function accumulativeLossesOf(address) external view returns (uint256);\n\n    function updateLossesReceived() external;\n\n}\n"
    },
    "packages/protocol/contracts/token/interfaces/IBasicFDT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IBaseFDT.sol\";\n\ninterface IBasicFDT is IBaseFDT, IERC20 {\n\n    event PointsPerShareUpdated(uint256);\n\n    event PointsCorrectionUpdated(address indexed, int256);\n\n    function withdrawnFundsOf(address) external view returns (uint256);\n\n    function accumulativeFundsOf(address) external view returns (uint256);\n\n    function updateFundsReceived() external;\n\n}\n"
    },
    "packages/protocol/contracts/token/interfaces/IBaseFDT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IBaseFDT {\n\n    /**\n        @dev    Returns the total amount of funds a given address is able to withdraw currently.\n        @param  owner Address of FDT holder.\n        @return A uint256 representing the available funds for a given account.\n    */\n    function withdrawableFundsOf(address owner) external view returns (uint256);\n\n    /**\n        @dev Withdraws all available funds for a FDT holder.\n    */\n    function withdrawFunds() external;\n\n    /**\n        @dev   This event emits when new funds are distributed.\n        @param by               The address of the sender that distributed funds.\n        @param fundsDistributed The amount of funds received for distribution.\n    */\n    event FundsDistributed(address indexed by, uint256 fundsDistributed);\n\n    /**\n        @dev   This event emits when distributed funds are withdrawn by a token holder.\n        @param by             The address of the receiver of funds.\n        @param fundsWithdrawn The amount of funds that were withdrawn.\n        @param totalWithdrawn The total amount of funds that were withdrawn.\n    */\n    event FundsWithdrawn(address indexed by, uint256 fundsWithdrawn, uint256 totalWithdrawn);\n\n}\n"
    },
    "packages/protocol/contracts/token/BasicFDT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport \"./interfaces/IBaseFDT.sol\";\nimport \"../math/SafeMathUint.sol\";\nimport \"../math/SafeMathInt.sol\";\n\n/// @title BasicFDT implements base level FDT functionality for accounting for revenues.\nabstract contract BasicFDT is IBaseFDT, ERC20 {\n    using SafeMath       for uint256;\n    using SafeMathUint   for uint256;\n    using SignedSafeMath for  int256;\n    using SafeMathInt    for  int256;\n\n    uint256 internal constant pointsMultiplier = 2 ** 128;\n    uint256 internal pointsPerShare;\n\n    mapping(address => int256)  internal pointsCorrection;\n    mapping(address => uint256) internal withdrawnFunds;\n\n    event   PointsPerShareUpdated(uint256 pointsPerShare);\n    event PointsCorrectionUpdated(address indexed account, int256 pointsCorrection);\n\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) public { }\n\n    /**\n        @dev Distributes funds to token holders.\n        @dev It reverts if the total supply of tokens is 0.\n        @dev It emits a `FundsDistributed` event if the amount of received funds is greater than 0.\n        @dev It emits a `PointsPerShareUpdated` event if the amount of received funds is greater than 0.\n             About undistributed funds:\n                In each distribution, there is a small amount of funds which do not get distributed,\n                   which is `(value  pointsMultiplier) % totalSupply()`.\n                With a well-chosen `pointsMultiplier`, the amount funds that are not getting distributed\n                   in a distribution can be less than 1 (base unit).\n                We can actually keep track of the undistributed funds in a distribution\n                   and try to distribute it in the next distribution.\n    */\n    function _distributeFunds(uint256 value) internal {\n        require(totalSupply() > 0, \"FDT:ZERO_SUPPLY\");\n\n        if (value == 0) return;\n\n        pointsPerShare = pointsPerShare.add(value.mul(pointsMultiplier) / totalSupply());\n        emit FundsDistributed(msg.sender, value);\n        emit PointsPerShareUpdated(pointsPerShare);\n    }\n\n    /**\n        @dev    Prepares the withdrawal of funds.\n        @dev    It emits a `FundsWithdrawn` event if the amount of withdrawn funds is greater than 0.\n        @return withdrawableDividend The amount of dividend funds that can be withdrawn.\n    */\n    function _prepareWithdraw() internal returns (uint256 withdrawableDividend) {\n        withdrawableDividend       = withdrawableFundsOf(msg.sender);\n        uint256 _withdrawnFunds    = withdrawnFunds[msg.sender].add(withdrawableDividend);\n        withdrawnFunds[msg.sender] = _withdrawnFunds;\n\n        emit FundsWithdrawn(msg.sender, withdrawableDividend, _withdrawnFunds);\n    }\n\n    /**\n        @dev    Returns the amount of funds that an account can withdraw.\n        @param  _owner The address of a token holder.\n        @return The amount funds that `_owner` can withdraw.\n    */\n    function withdrawableFundsOf(address _owner) public view override returns (uint256) {\n        return accumulativeFundsOf(_owner).sub(withdrawnFunds[_owner]);\n    }\n\n    /**\n        @dev    Returns the amount of funds that an account has withdrawn.\n        @param  _owner The address of a token holder.\n        @return The amount of funds that `_owner` has withdrawn.\n    */\n    function withdrawnFundsOf(address _owner) external view returns (uint256) {\n        return withdrawnFunds[_owner];\n    }\n\n    /**\n        @dev    Returns the amount of funds that an account has earned in total.\n        @dev    accumulativeFundsOf(_owner) = withdrawableFundsOf(_owner) + withdrawnFundsOf(_owner)\n                                         = (pointsPerShare * balanceOf(_owner) + pointsCorrection[_owner]) / pointsMultiplier\n        @param  _owner The address of a token holder.\n        @return The amount of funds that `_owner` has earned in total.\n    */\n    function accumulativeFundsOf(address _owner) public view returns (uint256) {\n        return\n            pointsPerShare\n                .mul(balanceOf(_owner))\n                .toInt256Safe()\n                .add(pointsCorrection[_owner])\n                .toUint256Safe() / pointsMultiplier;\n    }\n\n    /**\n        @dev   Transfers tokens from one account to another. Updates pointsCorrection to keep funds unchanged.\n        @dev   It emits two `PointsCorrectionUpdated` events, one for the sender and one for the receiver.\n        @param from  The address to transfer from.\n        @param to    The address to transfer to.\n        @param value The amount to be transferred.\n    */\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual override {\n        super._transfer(from, to, value);\n\n        int256 _magCorrection       = pointsPerShare.mul(value).toInt256Safe();\n        int256 pointsCorrectionFrom = pointsCorrection[from].add(_magCorrection);\n        pointsCorrection[from]      = pointsCorrectionFrom;\n        int256 pointsCorrectionTo   = pointsCorrection[to].sub(_magCorrection);\n        pointsCorrection[to]        = pointsCorrectionTo;\n\n        emit PointsCorrectionUpdated(from, pointsCorrectionFrom);\n        emit PointsCorrectionUpdated(to,   pointsCorrectionTo);\n    }\n\n    /**\n        @dev   Mints tokens to an account. Updates pointsCorrection to keep funds unchanged.\n        @param account The account that will receive the created tokens.\n        @param value   The amount that will be created.\n    */\n    function _mint(address account, uint256 value) internal virtual override {\n        super._mint(account, value);\n\n        int256 _pointsCorrection = pointsCorrection[account].sub(\n            (pointsPerShare.mul(value)).toInt256Safe()\n        );\n\n        pointsCorrection[account] = _pointsCorrection;\n\n        emit PointsCorrectionUpdated(account, _pointsCorrection);\n    }\n\n    /**\n        @dev   Burns an amount of the token of a given account. Updates pointsCorrection to keep funds unchanged.\n        @dev   It emits a `PointsCorrectionUpdated` event.\n        @param account The account whose tokens will be burnt.\n        @param value   The amount that will be burnt.\n    */\n    function _burn(address account, uint256 value) internal virtual override {\n        super._burn(account, value);\n\n        int256 _pointsCorrection = pointsCorrection[account].add(\n            (pointsPerShare.mul(value)).toInt256Safe()\n        );\n\n        pointsCorrection[account] = _pointsCorrection;\n\n        emit PointsCorrectionUpdated(account, _pointsCorrection);\n    }\n\n    /**\n        @dev Withdraws all available funds for a token holder.\n    */\n    function withdrawFunds() public virtual override {}\n\n    /**\n        @dev    Updates the current `fundsToken` balance and returns the difference of the new and previous `fundsToken` balance.\n        @return A int256 representing the difference of the new and previous `fundsToken` balance.\n    */\n    function _updateFundsTokenBalance() internal virtual returns (int256) {}\n\n    /**\n        @dev Registers a payment of funds in tokens. May be called directly after a deposit is made.\n        @dev Calls _updateFundsTokenBalance(), whereby the contract computes the delta of the new and previous\n             `fundsToken` balance and increments the total received funds (cumulative), by delta, by calling _distributeFunds().\n    */\n    function updateFundsReceived() public virtual {\n        int256 newFunds = _updateFundsTokenBalance();\n\n        if (newFunds <= 0) return;\n\n        _distributeFunds(newFunds.toUint256Safe());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "packages/protocol/contracts/math/SafeMathUint.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nlibrary SafeMathUint {\n    function toInt256Safe(uint256 a) internal pure returns (int256 b) {\n        b = int256(a);\n        require(b >= 0, \"SMU:OOB\");\n    }\n}\n"
    },
    "packages/protocol/contracts/math/SafeMathInt.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nlibrary SafeMathInt {\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\n        require(a >= 0, \"SMI:NEG\");\n        return uint256(a);\n    }\n}\n"
    },
    "packages/protocol/contracts/token/interfaces/IStakeLockerFDT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./IExtendedFDT.sol\";\n\ninterface IStakeLockerFDT is IExtendedFDT {\n\n    function fundsToken() external view returns (address);\n\n    function fundsTokenBalance() external view returns (uint256);\n\n    function bptLosses() external view returns (uint256);\n\n    function lossesBalance() external view returns (uint256);\n\n}\n"
    },
    "packages/protocol/contracts/token/interfaces/ILoanFDT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./IBasicFDT.sol\";\n\ninterface ILoanFDT is IBasicFDT {\n\n    function fundsToken() external view returns (address);\n\n    function fundsTokenBalance() external view returns (uint256);\n\n}\n"
    },
    "packages/protocol/contracts/MplRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/IERC2258.sol\";\n\n// https://docs.synthetix.io/contracts/source/contracts/stakingrewards\n/// @title MplRewards Synthetix farming contract fork for liquidity mining.\ncontract MplRewards is Ownable {\n\n    using SafeMath  for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20    public immutable rewardsToken;\n    IERC2258  public immutable stakingToken;\n\n    uint256 public periodFinish;\n    uint256 public rewardRate;\n    uint256 public rewardsDuration;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public lastPauseTime;\n    bool    public paused;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n\n    event            RewardAdded(uint256 reward);\n    event                 Staked(address indexed account, uint256 amount);\n    event              Withdrawn(address indexed account, uint256 amount);\n    event             RewardPaid(address indexed account, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event              Recovered(address token, uint256 amount);\n    event           PauseChanged(bool isPaused);\n\n    constructor(address _rewardsToken, address _stakingToken, address _owner) public {\n        rewardsToken    = IERC20(_rewardsToken);\n        stakingToken    = IERC2258(_stakingToken);\n        rewardsDuration = 7 days;\n        transferOwnership(_owner);\n    }\n\n    function _updateReward(address account) internal {\n        uint256 _rewardPerTokenStored = rewardPerToken();\n        rewardPerTokenStored          = _rewardPerTokenStored;\n        lastUpdateTime                = lastTimeRewardApplicable();\n\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = _rewardPerTokenStored;\n        }\n    }\n\n    function _notPaused() internal view {\n        require(!paused, \"R:PAUSED\");\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        return _totalSupply == 0\n            ? rewardPerTokenStored\n            : rewardPerTokenStored.add(\n                  lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)\n              );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    /**\n        @dev It emits a `Staked` event.\n    */\n    function stake(uint256 amount) external {\n        _notPaused();\n        _updateReward(msg.sender);\n        uint256 newBalance = _balances[msg.sender].add(amount);\n        require(amount > 0, \"R:ZERO_STAKE\");\n        require(stakingToken.custodyAllowance(msg.sender, address(this)) >= newBalance, \"R:INSUF_CUST_ALLOWANCE\");\n        _totalSupply          = _totalSupply.add(amount);\n        _balances[msg.sender] = newBalance;\n        emit Staked(msg.sender, amount);\n    }\n\n    /**\n        @dev It emits a `Withdrawn` event.\n    */\n    function withdraw(uint256 amount) public {\n        _notPaused();\n        _updateReward(msg.sender);\n        require(amount > 0, \"R:ZERO_WITHDRAW\");\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.transferByCustodian(msg.sender, msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n        @dev It emits a `RewardPaid` event if any rewards are received.\n    */\n    function getReward() public {\n        _notPaused();\n        _updateReward(msg.sender);\n        uint256 reward = rewards[msg.sender];\n\n        if (reward == uint256(0)) return;\n\n        rewards[msg.sender] = uint256(0);\n        rewardsToken.safeTransfer(msg.sender, reward);\n        emit RewardPaid(msg.sender, reward);\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    /**\n        @dev Only the contract Owner may call this.\n        @dev It emits a `RewardAdded` event.\n    */\n    function notifyRewardAmount(uint256 reward) external onlyOwner {\n        _updateReward(address(0));\n\n        uint256 _rewardRate = block.timestamp >= periodFinish\n            ? reward.div(rewardsDuration)\n            : reward.add(\n                  periodFinish.sub(block.timestamp).mul(rewardRate)\n              ).div(rewardsDuration);\n\n        rewardRate = _rewardRate;\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(_rewardRate <= balance.div(rewardsDuration), \"R:REWARD_TOO_HIGH\");\n\n        lastUpdateTime = block.timestamp;\n        periodFinish   = block.timestamp.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n\n    /**\n        @dev End rewards emission earlier. Only the contract Owner may call this.\n    */\n    function updatePeriodFinish(uint256 timestamp) external onlyOwner {\n        _updateReward(address(0));\n        periodFinish = timestamp;\n    }\n\n    /**\n        @dev Added to support recovering tokens unintentionally sent to this contract.\n             Only the contract Owner may call this.\n        @dev It emits a `Recovered` event.\n    */\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    /**\n        @dev Only the contract Owner may call this.\n        @dev It emits a `RewardsDurationUpdated` event.\n    */\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(block.timestamp > periodFinish, \"R:PERIOD_NOT_FINISHED\");\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    /**\n        @dev Change the paused state of the contract. Only the contract Owner may call this.\n        @dev It emits a `PauseChanged` event.\n    */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        require(_paused != paused, \"R:ALREADY_SET\");\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (_paused) lastPauseTime = block.timestamp;\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "packages/protocol/contracts/interfaces/IERC2258.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IERC2258 {\n\n    // Increase the custody limit of a custodian either directly or via signed authorization\n    function increaseCustodyAllowance(address custodian, uint256 amount) external;\n\n    // Query individual custody limit and total custody limit across all custodians\n    function custodyAllowance(address account, address custodian) external view returns (uint256);\n    function totalCustodyAllowance(address account) external view returns (uint256);\n\n    // Allows a custodian to exercise their right to transfer custodied tokens\n    function transferByCustodian(address account, address receiver, uint256 amount) external;\n\n    // Custody Events\n    event CustodyTransfer(address custodian, address from, address to, uint256 amount);\n    event CustodyAllowanceChanged(address account, address custodian, uint256 oldAllowance, uint256 newAllowance);\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IOracle {\n\n    function priceFeed() external view returns (address);\n\n    function globals() external view returns (address);\n\n    function assetAddress() external view returns (address);\n\n    function manualOverride() external view returns (bool);\n\n    function manualPrice() external view returns (int256);\n\n    function getLatestPrice() external view returns (int256);\n    \n    function changeAggregator(address) external;\n\n    function getAssetAddress() external view returns (address);\n    \n    function getDenomination() external view returns (bytes32);\n    \n    function setManualPrice(int256) external;\n    \n    function setManualOverride(bool) external;\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/ISubFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface ISubFactory {\n\n    function factoryType() external view returns (uint8);\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IProtocolMapleToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IProtocolMapleToken {\n\n    function updateFundsReceived() external;\n\n}\n"
    },
    "packages/protocol/contracts/oracles/IChainlinkAggregatorV3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IChainlinkAggregatorV3 {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values,\n  // which could be misinterpreted as actual reported values.\n  \n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n        uint80  roundId,\n        int256  answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80  answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n        uint80  roundId,\n        int256  answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80  answeredInRound\n    );\n\n}\n"
    },
    "packages/token/contracts/interfaces/IMapleToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport { IERC2222 } from \"./IERC2222.sol\";\n\ninterface IMapleToken is IERC2222 {\n\n    function DOMAIN_SEPARATOR() external pure returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address) external view returns (uint256);\n\n    /**\n        @dev   Approve by signature.\n        @param owner    Owner address that signed the permit\n        @param spender  Spender of the permit\n        @param amount   Permit approval spend limit\n        @param deadline Deadline after which the permit is invalid\n        @param v        ECDSA signature v component\n        @param r        ECDSA signature r component\n        @param s        ECDSA signature s component\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n}\n"
    },
    "packages/token/contracts/ERC2222.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport { SafeMath }          from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { SignedSafeMath }    from \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport { ERC20 }             from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport { IntSafeMath }  from \"./libraries/IntSafeMath.sol\";\nimport { UintSafeMath } from \"./libraries/UintSafeMath.sol\";\n\nimport { IERC2222 } from \"./interfaces/IERC2222.sol\";\n\nabstract contract ERC2222 is IERC2222, ERC20 {\n\n    using SafeERC20      for  IERC20;\n    using SafeMath       for uint256;\n    using SignedSafeMath for  int256;\n    using IntSafeMath    for  int256;\n    using UintSafeMath   for uint256;\n\n    address public override fundsToken;\n    uint256 public override fundsTokenBalance;\n\n    uint256 internal constant pointsMultiplier = 2 ** 128;\n    uint256 internal          pointsPerShare;\n\n    mapping(address => int256)  internal pointsCorrection;\n    mapping(address => uint256) internal withdrawnFunds;\n\n    constructor(string memory name, string memory symbol, address _fundsToken) ERC20(name, symbol) public {\n        fundsToken = _fundsToken;\n    }\n\n    /**\n     * prev. distributeDividends\n     * @dev Distributes funds to token holders.\n     * @dev It reverts if the total supply of tokens is 0.\n     * It emits the `FundsDistributed` event if the amount of received ether is greater than 0.\n     * About undistributed funds:\n     *   In each distribution, there is a small amount of funds which does not get distributed,\n     *     which is `(msg.value * pointsMultiplier) % totalSupply()`.\n     *   With a well-chosen `pointsMultiplier`, the amount funds that are not getting distributed\n     *     in a distribution can be less than 1 (base unit).\n     *   We can actually keep track of the undistributed ether in a distribution\n     *     and try to distribute it in the next distribution ....... todo implement\n     */\n    function _distributeFunds(uint256 value) internal {\n        require(totalSupply() > 0, \"FDT:SUPPLY_EQ_ZERO\");\n\n        if (value > 0) {\n            pointsPerShare = pointsPerShare.add(value.mul(pointsMultiplier) / totalSupply());\n            emit FundsDistributed(msg.sender, value);\n            emit PointsPerShareUpdated(pointsPerShare);\n        }\n    }\n\n    /**\n     * @dev Prepares funds withdrawal\n     * @dev It emits a `FundsWithdrawn` event if the amount of withdrawn ether is greater than 0.\n     */\n    function _prepareWithdraw() internal returns (uint256) {\n        uint256 _withdrawableDividend = withdrawableFundsOf(msg.sender);\n\n        withdrawnFunds[msg.sender] = withdrawnFunds[msg.sender].add(_withdrawableDividend);\n\n        emit FundsWithdrawn(msg.sender, _withdrawableDividend, withdrawnFunds[msg.sender]);\n\n        return _withdrawableDividend;\n    }\n\n    /**\n     * @dev Prepares funds withdrawal on behalf of a user\n     * @dev It emits a `FundsWithdrawn` event if the amount of withdrawn ether is greater than 0.\n     */\n    function _prepareWithdrawOnBehalf(address user) internal returns (uint256) {\n        uint256 _withdrawableDividend = withdrawableFundsOf(user);\n\n        withdrawnFunds[user] = withdrawnFunds[user].add(_withdrawableDividend);\n\n        emit FundsWithdrawn(user, _withdrawableDividend, withdrawnFunds[user]);\n\n        return _withdrawableDividend;\n    }\n\n    function withdrawableFundsOf(address _owner) public view override returns (uint256) {\n        return accumulativeFundsOf(_owner).sub(withdrawnFunds[_owner]);\n    }\n\n    function withdrawnFundsOf(address _owner) public view override returns (uint256) {\n        return withdrawnFunds[_owner];\n    }\n\n    function accumulativeFundsOf(address _owner) public view override returns (uint256) {\n        return\n            pointsPerShare\n                .mul(balanceOf(_owner))\n                .toInt256Safe()\n                .add(pointsCorrection[_owner])\n                .toUint256Safe() / pointsMultiplier;\n    }\n\n    /**\n     * @dev   Internal function that transfer tokens from one address to another.\n     * @dev   Update pointsCorrection to keep funds unchanged.\n     * @param from  The address to transfer from.\n     * @param to    The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual override {\n        require(to != address(this), \"ERC20: transferring to token contract\");\n        super._transfer(from, to, value);\n\n        int256 _magCorrection = pointsPerShare.mul(value).toInt256Safe();\n        pointsCorrection[from] = pointsCorrection[from].add(_magCorrection);\n        pointsCorrection[to] = pointsCorrection[to].sub(_magCorrection);\n\n        emit PointsCorrectionUpdated(from, pointsCorrection[from]);\n        emit PointsCorrectionUpdated(to,   pointsCorrection[to]);\n    }\n\n    /**\n     * @dev   Internal function that mints tokens to an account.\n     * @dev   Update pointsCorrection to keep funds unchanged.\n     * @param account The account that will receive the created tokens.\n     * @param value   The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal virtual override {\n        super._mint(account, value);\n\n        pointsCorrection[account] = pointsCorrection[account].sub(\n            (pointsPerShare.mul(value)).toInt256Safe()\n        );\n\n        emit PointsCorrectionUpdated(account, pointsCorrection[account]);\n    }\n\n    /**\n     * @dev   Internal function that burns an amount of the token of a given account.\n     * @dev   Update pointsCorrection to keep funds unchanged.\n     * @param account The account whose tokens will be burnt.\n     * @param value   The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal virtual override {\n        super._burn(account, value);\n\n        pointsCorrection[account] = pointsCorrection[account].add(\n            (pointsPerShare.mul(value)).toInt256Safe()\n        );\n        emit PointsCorrectionUpdated(account, pointsCorrection[account]);\n    }\n\n    function withdrawFunds() public virtual override {\n        uint256 withdrawableFunds = _prepareWithdraw();\n\n        if (withdrawableFunds > uint256(0)) {\n            IERC20(fundsToken).safeTransfer(msg.sender, withdrawableFunds);\n\n            _updateFundsTokenBalance();\n        }\n    }\n\n    function withdrawFundsOnBehalf(address user) public virtual override {\n        uint256 withdrawableFunds = _prepareWithdrawOnBehalf(user);\n\n        if (withdrawableFunds > uint256(0)) {\n            IERC20(fundsToken).safeTransfer(user, withdrawableFunds);\n\n            _updateFundsTokenBalance();\n        }\n    }\n\n    /**\n     * @dev    Updates the current funds token balance and returns the difference of new and previous funds token balances\n     * @return A int256 representing the difference of the new and previous funds token balance\n     */\n    function _updateFundsTokenBalance() internal virtual returns (int256) {\n        uint256 _prevFundsTokenBalance = fundsTokenBalance;\n\n        fundsTokenBalance = IERC20(fundsToken).balanceOf(address(this));\n\n        return int256(fundsTokenBalance).sub(int256(_prevFundsTokenBalance));\n    }\n\n    function updateFundsReceived() public virtual override {\n        int256 newFunds = _updateFundsTokenBalance();\n\n        if (newFunds > 0) {\n            _distributeFunds(newFunds.toUint256Safe());\n        }\n    }\n\n}\n"
    },
    "packages/token/contracts/interfaces/IERC2222.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\n/// @title BasicFDT implements the basic level FDT functionality for accounting for revenues.\ninterface IERC2222 {\n\n    /**\n        @dev   This event emits when new funds are distributed.\n        @param by               The address of the sender that distributed funds.\n        @param fundsDistributed The amount of funds received for distribution.\n     */\n    event FundsDistributed(address indexed by, uint256 fundsDistributed);\n\n    /**\n        @dev   This event emits when distributed funds are withdrawn by a token holder.\n        @param by             The address of the receiver of funds.\n        @param fundsWithdrawn The amount of funds that were withdrawn.\n        @param totalWithdrawn The total amount of funds that were withdrawn.\n     */\n    event FundsWithdrawn(address indexed by, uint256 fundsWithdrawn, uint256 totalWithdrawn);\n\n    /**\n        @dev This event emits when the internal `pointsPerShare` is updated.\n        @dev First, and only, parameter is the new value of the internal `pointsPerShare`.\n     */\n    event PointsPerShareUpdated(uint256 pointsPerShare);\n\n    /**\n        @dev This event emits when an account's `pointsCorrection` is updated.\n        @dev First parameter is the address of some account.\n        @dev Second parameter is the new value of the account's `pointsCorrection`.\n     */\n    event PointsCorrectionUpdated(address account, int256 pointsCorrection);\n\n    /**\n        @dev    Returns the amount of funds that an account can withdraw.\n        @param  _owner The address of some FDT holder.\n        @return The amount funds that `_owner` can withdraw.\n     */\n    function withdrawableFundsOf(address _owner) external view returns (uint256);\n\n    /**\n        @dev Withdraws all available funds for the calling FDT holder.\n     */\n    function withdrawFunds() external;\n\n    /**\n     * @dev Withdraws all available funds for a token holder, on behalf of token holder\n     */\n    function withdrawFundsOnBehalf(address user) external;\n\n    /**\n        @dev    Returns the amount of funds that an account has withdrawn.\n        @param  _owner The address of a token holder.\n        @return The amount of funds that `_owner` has withdrawn.\n     */\n    function withdrawnFundsOf(address _owner) external view returns (uint256);\n\n    /**\n        @dev    Returns the amount of funds that an account has earned in total. \n        @dev    accumulativeFundsOf(_owner) = withdrawableFundsOf(_owner) + withdrawnFundsOf(_owner) \n                = (pointsPerShare * balanceOf(_owner) + pointsCorrection[_owner]) / pointsMultiplier \n        @param  _owner The address of a token holder.\n        @return The amount of funds that `_owner` has earned in total.\n     */\n    function accumulativeFundsOf(address _owner) external view returns (uint256);\n\n    /**\n        @dev Registers a payment of funds in tokens. \n        @dev May be called directly after a deposit is made. \n        @dev Calls _updateFundsTokenBalance(), whereby the contract computes the delta of the new and previous \n             `fundsToken` balance and increments the total received funds (cumulative), by delta, by calling _distributeFunds().\n     */\n    function updateFundsReceived() external;\n\n    /**\n        @dev The `fundsToken` (dividends).\n     */\n    function fundsToken() external view returns (address);\n\n    /**\n        @dev The amount of `fundsToken` currently present and accounted for in this contract.\n     */\n    function fundsTokenBalance() external view returns (uint256);\n\n}\n"
    },
    "packages/token/contracts/libraries/IntSafeMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nlibrary IntSafeMath {\n\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\n        require(a >= 0);\n        return uint256(a);\n    }\n\n}\n"
    },
    "packages/token/contracts/libraries/UintSafeMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nlibrary UintSafeMath {\n\n    function toInt256Safe(uint256 a) internal pure returns (int256) {\n        int256 b = int256(a);\n        require(b >= 0);\n        return b;\n    }\n\n}\n"
    },
    "packages/protocol/contracts/DebtLocker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILoan.sol\";\n\n/// @title DebtLocker holds custody of LoanFDT tokens.\ncontract DebtLocker {\n\n    using SafeMath  for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 constant WAD = 10 ** 18;\n\n    ILoan   public immutable loan;            // The Loan contract this locker is holding tokens for.\n    IERC20  public immutable liquidityAsset;  // The Liquidity Asset this locker can claim.\n    address public immutable pool;            // The owner of this Locker (the Pool).\n\n    uint256 public lastPrincipalPaid;    // Loan total principal   paid at last time claim() was called.\n    uint256 public lastInterestPaid;     // Loan total interest    paid at last time claim() was called.\n    uint256 public lastFeePaid;          // Loan total fees        paid at last time claim() was called.\n    uint256 public lastExcessReturned;   // Loan total excess  returned at last time claim() was called.\n    uint256 public lastDefaultSuffered;  // Loan total default suffered at last time claim() was called.\n    uint256 public lastAmountRecovered;  // Liquidity Asset (a.k.a. loan asset) recovered from liquidation of Loan collateral.\n\n    /**\n        @dev Checks that `msg.sender` is the Pool.\n    */\n    modifier isPool() {\n        require(msg.sender == pool, \"DL:NOT_P\");\n        _;\n    }\n\n    constructor(address _loan, address _pool) public {\n        loan           = ILoan(_loan);\n        pool           = _pool;\n        liquidityAsset = IERC20(ILoan(_loan).liquidityAsset());\n    }\n\n    // Note: If newAmt > 0, totalNewAmt will always be greater than zero.\n    function _calcAllotment(uint256 newAmt, uint256 totalClaim, uint256 totalNewAmt) internal pure returns (uint256) {\n        return newAmt == uint256(0) ? uint256(0) : newAmt.mul(totalClaim).div(totalNewAmt);\n    }\n\n    /**\n        @dev    Claims funds distribution for Loan via LoanFDT. Only the Pool can call this function.\n        @return [0] = Total Claimed\n                [1] = Interest Claimed\n                [2] = Principal Claimed\n                [3] = Pool Delegate Fee Claimed\n                [4] = Excess Returned Claimed\n                [5] = Amount Recovered (from Liquidation)\n                [6] = Default Suffered\n    */\n    function claim() external isPool returns (uint256[7] memory) {\n\n        uint256 newDefaultSuffered   = uint256(0);\n        uint256 loan_defaultSuffered = loan.defaultSuffered();\n\n        // If a default has occurred, update storage variable and update memory variable from zero for return.\n        // `newDefaultSuffered` represents the proportional loss that the DebtLocker registers based on its balance\n        // of LoanFDTs in comparison to the total supply of LoanFDTs.\n        // Default will occur only once, so below statement will only be `true` once.\n        if (lastDefaultSuffered == uint256(0) && loan_defaultSuffered > uint256(0)) {\n            newDefaultSuffered = lastDefaultSuffered = _calcAllotment(loan.balanceOf(address(this)), loan_defaultSuffered, loan.totalSupply());\n        }\n\n        // Account for any transfers into Loan that have occurred since last call.\n        loan.updateFundsReceived();\n\n        // Handles case where no claimable funds are present but a default must be registered (zero-collateralized loans defaulting).\n        if (loan.withdrawableFundsOf(address(this)) == uint256(0)) return([0, 0, 0, 0, 0, 0, newDefaultSuffered]);\n\n        // If there are claimable funds, calculate portions and claim using LoanFDT.\n\n        // Calculate payment deltas.\n        uint256 newInterest  = loan.interestPaid() - lastInterestPaid;    // `loan.interestPaid`  updated in `loan._makePayment()`\n        uint256 newPrincipal = loan.principalPaid() - lastPrincipalPaid;  // `loan.principalPaid` updated in `loan._makePayment()`\n\n        // Update storage variables for next delta calculation.\n        lastInterestPaid  = loan.interestPaid();\n        lastPrincipalPaid = loan.principalPaid();\n\n        // Calculate one-time deltas if storage variables have not yet been updated.\n        uint256 newFee             = lastFeePaid         == uint256(0) ? loan.feePaid()         : uint256(0);  // `loan.feePaid`          updated in `loan.drawdown()`\n        uint256 newExcess          = lastExcessReturned  == uint256(0) ? loan.excessReturned()  : uint256(0);  // `loan.excessReturned`   updated in `loan.unwind()` OR `loan.drawdown()` if `amt < fundingLockerBal`\n        uint256 newAmountRecovered = lastAmountRecovered == uint256(0) ? loan.amountRecovered() : uint256(0);  // `loan.amountRecovered`  updated in `loan.triggerDefault()`\n\n        // Update DebtLocker storage variables if Loan storage variables has been updated since last claim.\n        if (newFee > 0)             lastFeePaid         = newFee;\n        if (newExcess > 0)          lastExcessReturned  = newExcess;\n        if (newAmountRecovered > 0) lastAmountRecovered = newAmountRecovered;\n\n        // Withdraw all claimable funds via LoanFDT.\n        uint256 beforeBal = liquidityAsset.balanceOf(address(this));                 // Current balance of DebtLocker (accounts for direct inflows).\n        loan.withdrawFunds();                                                        // Transfer funds from Loan to DebtLocker.\n        uint256 claimBal  = liquidityAsset.balanceOf(address(this)).sub(beforeBal);  // Amount claimed from Loan using LoanFDT.\n\n        // Calculate sum of all deltas, to be used to calculate portions for metadata.\n        uint256 sum = newInterest.add(newPrincipal).add(newFee).add(newExcess).add(newAmountRecovered);\n\n        // Calculate payment portions based on LoanFDT claim.\n        newInterest  = _calcAllotment(newInterest,  claimBal, sum);\n        newPrincipal = _calcAllotment(newPrincipal, claimBal, sum);\n\n        // Calculate one-time portions based on LoanFDT claim.\n        newFee             = _calcAllotment(newFee,             claimBal, sum);\n        newExcess          = _calcAllotment(newExcess,          claimBal, sum);\n        newAmountRecovered = _calcAllotment(newAmountRecovered, claimBal, sum);\n\n        liquidityAsset.safeTransfer(pool, claimBal);  // Transfer entire amount claimed using LoanFDT.\n\n        // Return claim amount plus all relevant metadata, to be used by Pool for further claim logic.\n        // Note: newInterest + newPrincipal + newFee + newExcess + newAmountRecovered = claimBal - dust\n        //       The dust on the right side of the equation gathers in the pool after transfers are made.\n        return([claimBal, newInterest, newPrincipal, newFee, newExcess, newAmountRecovered, newDefaultSuffered]);\n    }\n\n    /**\n        @dev Liquidates a Loan that is held by this contract. Only the Pool can call this function.\n    */\n    function triggerDefault() external isPool {\n        loan.triggerDefault();\n    }\n\n}\n"
    },
    "packages/protocol/contracts/FundingLocker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/// @title FundingLocker holds custody of Liquidity Asset tokens during the funding period of a Loan.\ncontract FundingLocker {\n\n    using SafeERC20 for IERC20;\n\n    IERC20  public immutable liquidityAsset;  // Asset the Loan was funded with.\n    address public immutable loan;            // Loan this FundingLocker has funded.\n\n    constructor(address _liquidityAsset, address _loan) public {\n        liquidityAsset = IERC20(_liquidityAsset);\n        loan           = _loan;\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Loan.\n    */\n    modifier isLoan() {\n        require(msg.sender == loan, \"FL:NOT_L\");\n        _;\n    }\n\n    /**\n        @dev   Transfers amount of Liquidity Asset to a destination account. Only the Loan can call this function.\n        @param dst Destination to transfer Liquidity Asset to.\n        @param amt Amount of Liquidity Asset to transfer.\n    */\n    function pull(address dst, uint256 amt) isLoan external {\n        liquidityAsset.safeTransfer(dst, amt);\n    }\n\n    /**\n        @dev Transfers entire amount of Liquidity Asset held in escrow to the Loan. Only the Loan can call this function.\n    */\n    function drain() isLoan external {\n        uint256 amt = liquidityAsset.balanceOf(address(this));\n        liquidityAsset.safeTransfer(loan, amt);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/LiquidityLocker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILoan.sol\";\n\n/// @title LiquidityLocker holds custody of Liquidity Asset tokens for a given Pool.\ncontract LiquidityLocker {\n\n    using SafeERC20 for IERC20;\n\n    address public immutable pool;            // The Pool that owns this LiquidityLocker.\n    IERC20  public immutable liquidityAsset;  // The Liquidity Asset which this LiquidityLocker will escrow.\n\n    constructor(address _liquidityAsset, address _pool) public {\n        liquidityAsset = IERC20(_liquidityAsset);\n        pool           = _pool;\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Pool.\n    */\n    modifier isPool() {\n        require(msg.sender == pool, \"LL:NOT_P\");\n        _;\n    }\n\n    /**\n        @dev   Transfers amount of Liquidity Asset to a destination account. Only the Pool can call this function.\n        @param dst Destination to transfer Liquidity Asset to.\n        @param amt Amount of Liquidity Asset to transfer.\n    */\n    function transfer(address dst, uint256 amt) external isPool {\n        require(dst != address(0), \"LL:NULL_DST\");\n        liquidityAsset.safeTransfer(dst, amt);\n    }\n\n    /**\n        @dev   Funds a Loan using available assets in this LiquidityLocker. Only the Pool can call this function.\n        @param loan       The Loan to fund.\n        @param debtLocker The DebtLocker that will escrow debt tokens.\n        @param amt        Amount of Liquidity Asset to fund the Loan for.\n    */\n    function fundLoan(address loan, address debtLocker, uint256 amt) external isPool {\n        liquidityAsset.safeApprove(loan, amt);\n        ILoan(loan).fundLoan(debtLocker, amt);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/Pool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/IBPool.sol\";\nimport \"./interfaces/IDebtLocker.sol\";\nimport \"./interfaces/IMapleGlobals.sol\";\nimport \"./interfaces/ILiquidityLocker.sol\";\nimport \"./interfaces/ILiquidityLockerFactory.sol\";\nimport \"./interfaces/ILoan.sol\";\nimport \"./interfaces/ILoanFactory.sol\";\nimport \"./interfaces/IPoolFactory.sol\";\nimport \"./interfaces/IStakeLocker.sol\";\nimport \"./interfaces/IStakeLockerFactory.sol\";\n\nimport \"./library/PoolLib.sol\";\n\nimport \"./token/PoolFDT.sol\";\n\n/// @title Pool maintains all accounting and functionality related to Pools.\ncontract Pool is PoolFDT {\n\n    using SafeMath  for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 constant WAD = 10 ** 18;\n\n    uint8 public constant DL_FACTORY = 1;  // Factory type of `DebtLockerFactory`.\n\n    IERC20  public immutable liquidityAsset;  // The asset deposited by Lenders into the LiquidityLocker, for funding Loans.\n\n    address public immutable poolDelegate;     // The Pool Delegate address, maintains full authority over the Pool.\n    address public immutable liquidityLocker;  // The LiquidityLocker owned by this contract\n    address public immutable stakeAsset;       // The address of the asset deposited by Stakers into the StakeLocker (BPTs), for liquidation during default events.\n    address public immutable stakeLocker;      // The address of the StakeLocker, escrowing `stakeAsset`.\n    address public immutable superFactory;     // The factory that deployed this Loan.\n\n    uint256 private immutable liquidityAssetDecimals;  // The precision for the Liquidity Asset (i.e. `decimals()`).\n\n    uint256 public           stakingFee;   // The fee Stakers earn            (in basis points).\n    uint256 public immutable delegateFee;  // The fee the Pool Delegate earns (in basis points).\n\n    uint256 public principalOut;  // The sum of all outstanding principal on Loans.\n    uint256 public liquidityCap;  // The amount of liquidity tokens accepted by the Pool.\n    uint256 public lockupPeriod;  // The period of time from an account's deposit date during which they cannot withdraw any funds.\n\n    bool public openToPublic;  // Boolean opening Pool to public for LP deposits\n\n    enum State { Initialized, Finalized, Deactivated }\n    State public poolState;\n\n    mapping(address => uint256)                     public depositDate;                // Used for withdraw penalty calculation.\n    mapping(address => mapping(address => address)) public debtLockers;                // Address of the DebtLocker corresponding to `[Loan][DebtLockerFactory]`.\n    mapping(address => bool)                        public poolAdmins;                 // The Pool Admin addresses that have permission to do certain operations in case of disaster management.\n    mapping(address => bool)                        public allowedLiquidityProviders;  // Mapping that contains the list of addresses that have early access to the pool.\n    mapping(address => uint256)                     public withdrawCooldown;           // The timestamp of when individual LPs have notified of their intent to withdraw.\n    mapping(address => mapping(address => uint256)) public custodyAllowance;           // The amount of PoolFDTs that are \"locked\" at a certain address.\n    mapping(address => uint256)                     public totalCustodyAllowance;      // The total amount of PoolFDTs that are \"locked\" for a given account. Cannot be greater than an account's balance.\n\n    event                   LoanFunded(address indexed loan, address debtLocker, uint256 amountFunded);\n    event                        Claim(address indexed loan, uint256 interest, uint256 principal, uint256 fee, uint256 stakeLockerPortion, uint256 poolDelegatePortion);\n    event               BalanceUpdated(address indexed liquidityProvider, address indexed token, uint256 balance);\n    event              CustodyTransfer(address indexed custodian, address indexed from, address indexed to, uint256 amount);\n    event      CustodyAllowanceChanged(address indexed liquidityProvider, address indexed custodian, uint256 oldAllowance, uint256 newAllowance);\n    event              LPStatusChanged(address indexed liquidityProvider, bool status);\n    event              LiquidityCapSet(uint256 newLiquidityCap);\n    event              LockupPeriodSet(uint256 newLockupPeriod);\n    event                StakingFeeSet(uint256 newStakingFee);\n    event             PoolStateChanged(State state);\n    event                     Cooldown(address indexed liquidityProvider, uint256 cooldown);\n    event           PoolOpenedToPublic(bool isOpen);\n    event                 PoolAdminSet(address indexed poolAdmin, bool allowed);\n    event           DepositDateUpdated(address indexed liquidityProvider, uint256 depositDate);\n    event TotalCustodyAllowanceUpdated(address indexed liquidityProvider, uint256 newTotalAllowance);\n\n    event DefaultSuffered(\n        address indexed loan,\n        uint256 defaultSuffered,\n        uint256 bptsBurned,\n        uint256 bptsReturned,\n        uint256 liquidityAssetRecoveredFromBurn\n    );\n\n    /**\n        Universal accounting law:\n                                       fdtTotalSupply = liquidityLockerBal + principalOut - interestSum + poolLosses\n            fdtTotalSupply + interestSum - poolLosses = liquidityLockerBal + principalOut\n    */\n\n    /**\n        @dev   Constructor for a Pool.\n        @dev   It emits a `PoolStateChanged` event.\n        @param _poolDelegate   Address that has manager privileges of the Pool.\n        @param _liquidityAsset Asset used to fund the Pool, It gets escrowed in LiquidityLocker.\n        @param _stakeAsset     Asset escrowed in StakeLocker.\n        @param _slFactory      Factory used to instantiate the StakeLocker.\n        @param _llFactory      Factory used to instantiate the LiquidityLocker.\n        @param _stakingFee     Fee that Stakers earn on interest, in basis points.\n        @param _delegateFee    Fee that the Pool Delegate earns on interest, in basis points.\n        @param _liquidityCap   Max amount of Liquidity Asset accepted by the Pool.\n        @param name            Name of Pool token.\n        @param symbol          Symbol of Pool token.\n    */\n    constructor(\n        address _poolDelegate,\n        address _liquidityAsset,\n        address _stakeAsset,\n        address _slFactory,\n        address _llFactory,\n        uint256 _stakingFee,\n        uint256 _delegateFee,\n        uint256 _liquidityCap,\n        string memory name,\n        string memory symbol\n    ) PoolFDT(name, symbol) public {\n\n        // Conduct sanity checks on Pool parameters.\n        PoolLib.poolSanityChecks(_globals(msg.sender), _liquidityAsset, _stakeAsset, _stakingFee, _delegateFee);\n\n        // Assign variables relating to the Liquidity Asset.\n        liquidityAsset         = IERC20(_liquidityAsset);\n        liquidityAssetDecimals = ERC20(_liquidityAsset).decimals();\n\n        // Assign state variables.\n        stakeAsset   = _stakeAsset;\n        poolDelegate = _poolDelegate;\n        stakingFee   = _stakingFee;\n        delegateFee  = _delegateFee;\n        superFactory = msg.sender;\n        liquidityCap = _liquidityCap;\n\n        // Instantiate the LiquidityLocker and the StakeLocker.\n        stakeLocker     = address(IStakeLockerFactory(_slFactory).newLocker(_stakeAsset, _liquidityAsset));\n        liquidityLocker = address(ILiquidityLockerFactory(_llFactory).newLocker(_liquidityAsset));\n\n        lockupPeriod = 180 days;\n\n        emit PoolStateChanged(State.Initialized);\n    }\n\n    /*******************************/\n    /*** Pool Delegate Functions ***/\n    /*******************************/\n\n    /**\n        @dev Finalizes the Pool, enabling deposits. Checks the amount the Pool Delegate deposited to the StakeLocker.\n             Only the Pool Delegate can call this function.\n        @dev It emits a `PoolStateChanged` event.\n    */\n    function finalize() external {\n        _isValidDelegateAndProtocolNotPaused();\n        _isValidState(State.Initialized);\n        (,, bool stakeSufficient,,) = getInitialStakeRequirements();\n        require(stakeSufficient, \"P:INSUF_STAKE\");\n        poolState = State.Finalized;\n        emit PoolStateChanged(poolState);\n    }\n\n    /**\n        @dev   Funds a Loan for an amount, utilizing the supplied DebtLockerFactory for DebtLockers.\n               Only the Pool Delegate can call this function.\n        @dev   It emits a `LoanFunded` event.\n        @dev   It emits a `BalanceUpdated` event.\n        @param loan      Address of the Loan to fund.\n        @param dlFactory Address of the DebtLockerFactory to utilize.\n        @param amt       Amount to fund the Loan.\n    */\n    function fundLoan(address loan, address dlFactory, uint256 amt) external {\n        _isValidDelegateAndProtocolNotPaused();\n        _isValidState(State.Finalized);\n        principalOut = principalOut.add(amt);\n        PoolLib.fundLoan(debtLockers, superFactory, liquidityLocker, loan, dlFactory, amt);\n        _emitBalanceUpdatedEvent();\n    }\n\n    /**\n        @dev   Liquidates a Loan. The Pool Delegate could liquidate the Loan only when the Loan completes its grace period.\n               The Pool Delegate can claim its proportion of recovered funds from the liquidation using the `claim()` function.\n               Only the Pool Delegate can call this function.\n        @param loan      Address of the Loan to liquidate.\n        @param dlFactory Address of the DebtLockerFactory that is used to pull corresponding DebtLocker.\n    */\n    function triggerDefault(address loan, address dlFactory) external {\n        _isValidDelegateAndProtocolNotPaused();\n        IDebtLocker(debtLockers[loan][dlFactory]).triggerDefault();\n    }\n\n    /**\n        @dev    Claims available funds for the Loan through a specified DebtLockerFactory. Only the Pool Delegate or a Pool Admin can call this function.\n        @dev    It emits two `BalanceUpdated` events.\n        @dev    It emits a `Claim` event.\n        @param  loan      Address of the loan to claim from.\n        @param  dlFactory Address of the DebtLockerFactory.\n        @return claimInfo The claim details.\n                    claimInfo [0] = Total amount claimed\n                    claimInfo [1] = Interest  portion claimed\n                    claimInfo [2] = Principal portion claimed\n                    claimInfo [3] = Fee       portion claimed\n                    claimInfo [4] = Excess    portion claimed\n                    claimInfo [5] = Recovered portion claimed (from liquidations)\n                    claimInfo [6] = Default suffered\n    */\n    function claim(address loan, address dlFactory) external returns (uint256[7] memory claimInfo) {\n        _whenProtocolNotPaused();\n        _isValidDelegateOrPoolAdmin();\n        claimInfo = IDebtLocker(debtLockers[loan][dlFactory]).claim();\n\n        (uint256 poolDelegatePortion, uint256 stakeLockerPortion, uint256 principalClaim, uint256 interestClaim) = PoolLib.calculateClaimAndPortions(claimInfo, delegateFee, stakingFee);\n\n        // Subtract outstanding principal by the principal claimed plus excess returned.\n        // Considers possible `principalClaim` overflow if Liquidity Asset is transferred directly into the Loan.\n        if (principalClaim <= principalOut) {\n            principalOut = principalOut - principalClaim;\n        } else {\n            interestClaim  = interestClaim.add(principalClaim - principalOut);  // Distribute `principalClaim` overflow as interest to LPs.\n            principalClaim = principalOut;                                      // Set `principalClaim` to `principalOut` so correct amount gets transferred.\n            principalOut   = 0;                                                 // Set `principalOut` to zero to avoid subtraction overflow.\n        }\n\n        // Accounts for rounding error in StakeLocker / Pool Delegate / LiquidityLocker interest split.\n        interestSum = interestSum.add(interestClaim);\n\n        _transferLiquidityAsset(poolDelegate, poolDelegatePortion);  // Transfer the fee and portion of interest to the Pool Delegate.\n        _transferLiquidityAsset(stakeLocker,  stakeLockerPortion);   // Transfer the portion of interest to the StakeLocker.\n\n        // Transfer remaining claim (remaining interest + principal + excess + recovered) to the LiquidityLocker.\n        // Dust will accrue in the Pool, but this ensures that state variables are in sync with the LiquidityLocker balance updates.\n        // Not using `balanceOf` in case of external address transferring the Liquidity Asset directly into Pool.\n        // Ensures that internal accounting is exactly reflective of balance change.\n        _transferLiquidityAsset(liquidityLocker, principalClaim.add(interestClaim));\n\n        // Handle default if defaultSuffered > 0.\n        if (claimInfo[6] > 0) _handleDefault(loan, claimInfo[6]);\n\n        // Update funds received for StakeLockerFDTs.\n        IStakeLocker(stakeLocker).updateFundsReceived();\n\n        // Update funds received for PoolFDTs.\n        updateFundsReceived();\n\n        _emitBalanceUpdatedEvent();\n        emit BalanceUpdated(stakeLocker, address(liquidityAsset), liquidityAsset.balanceOf(stakeLocker));\n\n        emit Claim(loan, interestClaim, principalClaim, claimInfo[3], stakeLockerPortion, poolDelegatePortion);\n    }\n\n    /**\n        @dev   Handles if a claim has been made and there is a non-zero defaultSuffered amount.\n        @dev   It emits a `DefaultSuffered` event.\n        @param loan            Address of a Loan that has defaulted.\n        @param defaultSuffered Losses suffered from default after liquidation.\n    */\n    function _handleDefault(address loan, uint256 defaultSuffered) internal {\n\n        (uint256 bptsBurned, uint256 postBurnBptBal, uint256 liquidityAssetRecoveredFromBurn) = PoolLib.handleDefault(liquidityAsset, stakeLocker, stakeAsset, defaultSuffered);\n\n        // If BPT burn is not enough to cover full default amount, pass on losses to LPs with PoolFDT loss accounting.\n        if (defaultSuffered > liquidityAssetRecoveredFromBurn) {\n            poolLosses = poolLosses.add(defaultSuffered - liquidityAssetRecoveredFromBurn);\n            updateLossesReceived();\n        }\n\n        // Transfer Liquidity Asset from burn to LiquidityLocker.\n        liquidityAsset.safeTransfer(liquidityLocker, liquidityAssetRecoveredFromBurn);\n\n        principalOut = principalOut.sub(defaultSuffered);  // Subtract rest of the Loan's principal from `principalOut`.\n\n        emit DefaultSuffered(\n            loan,                            // The Loan that suffered the default.\n            defaultSuffered,                 // Total default suffered from the Loan by the Pool after liquidation.\n            bptsBurned,                      // Amount of BPTs burned from StakeLocker.\n            postBurnBptBal,                  // Remaining BPTs in StakeLocker post-burn.\n            liquidityAssetRecoveredFromBurn  // Amount of Liquidity Asset recovered from burning BPTs.\n        );\n    }\n\n    /**\n        @dev Triggers deactivation, permanently shutting down the Pool. Must have less than 100 USD worth of Liquidity Asset `principalOut`.\n             Only the Pool Delegate can call this function.\n        @dev It emits a `PoolStateChanged` event.\n    */\n    function deactivate() external {\n        _isValidDelegateAndProtocolNotPaused();\n        _isValidState(State.Finalized);\n        PoolLib.validateDeactivation(_globals(superFactory), principalOut, address(liquidityAsset));\n        poolState = State.Deactivated;\n        emit PoolStateChanged(poolState);\n    }\n\n    /**************************************/\n    /*** Pool Delegate Setter Functions ***/\n    /**************************************/\n\n    /**\n        @dev   Sets the liquidity cap. Only the Pool Delegate or a Pool Admin can call this function.\n        @dev   It emits a `LiquidityCapSet` event.\n        @param newLiquidityCap New liquidity cap value.\n    */\n    function setLiquidityCap(uint256 newLiquidityCap) external {\n        _whenProtocolNotPaused();\n        _isValidDelegateOrPoolAdmin();\n        liquidityCap = newLiquidityCap;\n        emit LiquidityCapSet(newLiquidityCap);\n    }\n\n    /**\n        @dev   Sets the lockup period. Only the Pool Delegate can call this function.\n        @dev   It emits a `LockupPeriodSet` event.\n        @param newLockupPeriod New lockup period used to restrict the withdrawals.\n    */\n    function setLockupPeriod(uint256 newLockupPeriod) external {\n        _isValidDelegateAndProtocolNotPaused();\n        require(newLockupPeriod <= lockupPeriod, \"P:BAD_VALUE\");\n        lockupPeriod = newLockupPeriod;\n        emit LockupPeriodSet(newLockupPeriod);\n    }\n\n    /**\n        @dev   Sets the staking fee. Only the Pool Delegate can call this function.\n        @dev   It emits a `StakingFeeSet` event.\n        @param newStakingFee New staking fee.\n    */\n    function setStakingFee(uint256 newStakingFee) external {\n        _isValidDelegateAndProtocolNotPaused();\n        require(newStakingFee.add(delegateFee) <= 10_000, \"P:BAD_FEE\");\n        stakingFee = newStakingFee;\n        emit StakingFeeSet(newStakingFee);\n    }\n\n    /**\n        @dev   Sets the account status in the Pool's allowlist. Only the Pool Delegate can call this function.\n        @dev   It emits an `LPStatusChanged` event.\n        @param account The address to set status for.\n        @param status  The status of an account in the allowlist.\n    */\n    function setAllowList(address account, bool status) external {\n        _isValidDelegateAndProtocolNotPaused();\n        allowedLiquidityProviders[account] = status;\n        emit LPStatusChanged(account, status);\n    }\n\n    /**\n        @dev   Sets a Pool Admin. Only the Pool Delegate can call this function.\n        @dev   It emits a `PoolAdminSet` event.\n        @param poolAdmin An address being allowed or disallowed as a Pool Admin.\n        @param allowed Status of a Pool Admin.\n    */\n    function setPoolAdmin(address poolAdmin, bool allowed) external {\n        _isValidDelegateAndProtocolNotPaused();\n        poolAdmins[poolAdmin] = allowed;\n        emit PoolAdminSet(poolAdmin, allowed);\n    }\n\n    /**\n        @dev   Sets whether the Pool is open to the public. Only the Pool Delegate can call this function.\n        @dev   It emits a `PoolOpenedToPublic` event.\n        @param open Public pool access status.\n    */\n    function setOpenToPublic(bool open) external {\n        _isValidDelegateAndProtocolNotPaused();\n        openToPublic = open;\n        emit PoolOpenedToPublic(open);\n    }\n\n    /************************************/\n    /*** Liquidity Provider Functions ***/\n    /************************************/\n\n    /**\n        @dev   Handles Liquidity Providers depositing of Liquidity Asset into the LiquidityLocker, minting PoolFDTs.\n        @dev   It emits a `DepositDateUpdated` event.\n        @dev   It emits a `BalanceUpdated` event.\n        @dev   It emits a `Cooldown` event.\n        @param amt Amount of Liquidity Asset to deposit.\n    */\n    function deposit(uint256 amt) external {\n        _whenProtocolNotPaused();\n        _isValidState(State.Finalized);\n        require(isDepositAllowed(amt), \"P:DEP_NOT_ALLOWED\");\n\n        withdrawCooldown[msg.sender] = uint256(0);  // Reset the LP's withdraw cooldown if they had previously intended to withdraw.\n\n        uint256 wad = _toWad(amt);\n        PoolLib.updateDepositDate(depositDate, balanceOf(msg.sender), wad, msg.sender);\n\n        liquidityAsset.safeTransferFrom(msg.sender, liquidityLocker, amt);\n        _mint(msg.sender, wad);\n\n        _emitBalanceUpdatedEvent();\n        emit Cooldown(msg.sender, uint256(0));\n    }\n\n    /**\n        @dev Activates the cooldown period to withdraw. It can't be called if the account is not providing liquidity.\n        @dev It emits a `Cooldown` event.\n    **/\n    function intendToWithdraw() external {\n        require(balanceOf(msg.sender) != uint256(0), \"P:ZERO_BAL\");\n        withdrawCooldown[msg.sender] = block.timestamp;\n        emit Cooldown(msg.sender, block.timestamp);\n    }\n\n    /**\n        @dev Cancels an initiated withdrawal by resetting the account's withdraw cooldown.\n        @dev It emits a `Cooldown` event.\n    **/\n    function cancelWithdraw() external {\n        require(withdrawCooldown[msg.sender] != uint256(0), \"P:NOT_WITHDRAWING\");\n        withdrawCooldown[msg.sender] = uint256(0);\n        emit Cooldown(msg.sender, uint256(0));\n    }\n\n    /**\n        @dev   Checks that the account can withdraw an amount.\n        @param account The address of the account.\n        @param wad     The amount to withdraw.\n    */\n    function _canWithdraw(address account, uint256 wad) internal view {\n        require(depositDate[account].add(lockupPeriod) <= block.timestamp,     \"P:FUNDS_LOCKED\");     // Restrict withdrawal during lockup period\n        require(balanceOf(account).sub(wad) >= totalCustodyAllowance[account], \"P:INSUF_TRANS_BAL\");  // Account can only withdraw tokens that aren't custodied\n    }\n\n    /**\n        @dev   Handles Liquidity Providers withdrawing of Liquidity Asset from the LiquidityLocker, burning PoolFDTs.\n        @dev   It emits two `BalanceUpdated` event.\n        @param amt Amount of Liquidity Asset to withdraw.\n    */\n    function withdraw(uint256 amt) external {\n        _whenProtocolNotPaused();\n        uint256 wad = _toWad(amt);\n        (uint256 lpCooldownPeriod, uint256 lpWithdrawWindow) = _globals(superFactory).getLpCooldownParams();\n\n        _canWithdraw(msg.sender, wad);\n        require((block.timestamp - (withdrawCooldown[msg.sender] + lpCooldownPeriod)) <= lpWithdrawWindow, \"P:WITHDRAW_NOT_ALLOWED\");\n\n        _burn(msg.sender, wad);  // Burn the corresponding PoolFDTs balance.\n        withdrawFunds();         // Transfer full entitled interest, decrement `interestSum`.\n\n        // Transfer amount that is due after realized losses are accounted for.\n        // Recognized losses are absorbed by the LP.\n        _transferLiquidityLockerFunds(msg.sender, amt.sub(_recognizeLosses()));\n\n        _emitBalanceUpdatedEvent();\n    }\n\n    /**\n        @dev   Transfers PoolFDTs.\n        @param from Address sending   PoolFDTs.\n        @param to   Address receiving PoolFDTs.\n        @param wad  Amount of PoolFDTs to transfer.\n    */\n    function _transfer(address from, address to, uint256 wad) internal override {\n        _whenProtocolNotPaused();\n\n        (uint256 lpCooldownPeriod, uint256 lpWithdrawWindow) = _globals(superFactory).getLpCooldownParams();\n\n        _canWithdraw(from, wad);\n        require(block.timestamp > (withdrawCooldown[to] + lpCooldownPeriod + lpWithdrawWindow), \"P:TO_NOT_ALLOWED\");  // Recipient must not be currently withdrawing.\n        require(recognizableLossesOf(from) == uint256(0),                                       \"P:RECOG_LOSSES\");    // If an LP has unrecognized losses, they must recognize losses using `withdraw`.\n\n        PoolLib.updateDepositDate(depositDate, balanceOf(to), wad, to);\n        super._transfer(from, to, wad);\n    }\n\n    /**\n        @dev Withdraws all claimable interest from the LiquidityLocker for an account using `interestSum` accounting.\n        @dev It emits a `BalanceUpdated` event.\n    */\n    function withdrawFunds() public override {\n        _whenProtocolNotPaused();\n        uint256 withdrawableFunds = _prepareWithdraw();\n\n        if (withdrawableFunds == uint256(0)) return;\n\n        _transferLiquidityLockerFunds(msg.sender, withdrawableFunds);\n        _emitBalanceUpdatedEvent();\n\n        interestSum = interestSum.sub(withdrawableFunds);\n\n        _updateFundsTokenBalance();\n    }\n\n    /**\n        @dev   Increases the custody allowance for a given Custodian corresponding to the calling account (`msg.sender`).\n        @dev   It emits a `CustodyAllowanceChanged` event.\n        @dev   It emits a `TotalCustodyAllowanceUpdated` event.\n        @param custodian Address which will act as Custodian of a given amount for an account.\n        @param amount    Number of additional FDTs to be custodied by the Custodian.\n    */\n    function increaseCustodyAllowance(address custodian, uint256 amount) external {\n        uint256 oldAllowance      = custodyAllowance[msg.sender][custodian];\n        uint256 newAllowance      = oldAllowance.add(amount);\n        uint256 newTotalAllowance = totalCustodyAllowance[msg.sender].add(amount);\n\n        PoolLib.increaseCustodyAllowanceChecks(custodian, amount, newTotalAllowance, balanceOf(msg.sender));\n\n        custodyAllowance[msg.sender][custodian] = newAllowance;\n        totalCustodyAllowance[msg.sender]       = newTotalAllowance;\n        emit CustodyAllowanceChanged(msg.sender, custodian, oldAllowance, newAllowance);\n        emit TotalCustodyAllowanceUpdated(msg.sender, newTotalAllowance);\n    }\n\n    /**\n        @dev   Transfers custodied PoolFDTs back to the account.\n        @dev   `from` and `to` should always be equal in this implementation.\n        @dev   This means that the Custodian can only decrease their own allowance and unlock funds for the original owner.\n        @dev   It emits a `CustodyTransfer` event.\n        @dev   It emits a `CustodyAllowanceChanged` event.\n        @dev   It emits a `TotalCustodyAllowanceUpdated` event.\n        @param from   Address which holds the PoolFDTs.\n        @param to     Address which will be the new owner of the amount of PoolFDTs.\n        @param amount Amount of PoolFDTs transferred.\n    */\n    function transferByCustodian(address from, address to, uint256 amount) external {\n        uint256 oldAllowance = custodyAllowance[from][msg.sender];\n        uint256 newAllowance = oldAllowance.sub(amount);\n\n        PoolLib.transferByCustodianChecks(from, to, amount);\n\n        custodyAllowance[from][msg.sender] = newAllowance;\n        uint256 newTotalAllowance          = totalCustodyAllowance[from].sub(amount);\n        totalCustodyAllowance[from]        = newTotalAllowance;\n        emit CustodyTransfer(msg.sender, from, to, amount);\n        emit CustodyAllowanceChanged(from, msg.sender, oldAllowance, newAllowance);\n        emit TotalCustodyAllowanceUpdated(msg.sender, newTotalAllowance);\n    }\n\n    /**************************/\n    /*** Governor Functions ***/\n    /**************************/\n\n    /**\n        @dev   Transfers any locked funds to the Governor. Only the Governor can call this function.\n        @param token Address of the token to be reclaimed.\n    */\n    function reclaimERC20(address token) external {\n        PoolLib.reclaimERC20(token, address(liquidityAsset), _globals(superFactory));\n    }\n\n    /*************************/\n    /*** Getter Functions ***/\n    /*************************/\n\n    /**\n        @dev    Calculates the value of BPT in units of Liquidity Asset.\n        @param  _bPool          Address of Balancer pool.\n        @param  _liquidityAsset Asset used by Pool for liquidity to fund Loans.\n        @param  _staker         Address that deposited BPTs to StakeLocker.\n        @param  _stakeLocker    Escrows BPTs deposited by Staker.\n        @return USDC value of staker BPTs.\n    */\n    function BPTVal(\n        address _bPool,\n        address _liquidityAsset,\n        address _staker,\n        address _stakeLocker\n    ) external view returns (uint256) {\n        return PoolLib.BPTVal(_bPool, _liquidityAsset, _staker, _stakeLocker);\n    }\n\n    /**\n        @dev   Checks that the given deposit amount is acceptable based on current liquidityCap.\n        @param depositAmt Amount of tokens (i.e liquidityAsset type) the account is trying to deposit.\n    */\n    function isDepositAllowed(uint256 depositAmt) public view returns (bool) {\n        return (openToPublic || allowedLiquidityProviders[msg.sender]) &&\n               _balanceOfLiquidityLocker().add(principalOut).add(depositAmt) <= liquidityCap;\n    }\n\n    /**\n        @dev    Returns information on the stake requirements.\n        @return [0] = Min amount of Liquidity Asset coverage from staking required.\n                [1] = Present amount of Liquidity Asset coverage from the Pool Delegate stake.\n                [2] = If enough stake is present from the Pool Delegate for finalization.\n                [3] = Staked BPTs required for minimum Liquidity Asset coverage.\n                [4] = Current staked BPTs.\n    */\n    function getInitialStakeRequirements() public view returns (uint256, uint256, bool, uint256, uint256) {\n        return PoolLib.getInitialStakeRequirements(_globals(superFactory), stakeAsset, address(liquidityAsset), poolDelegate, stakeLocker);\n    }\n\n    /**\n        @dev    Calculates BPTs required if burning BPTs for the Liquidity Asset, given supplied `tokenAmountOutRequired`.\n        @param  _bPool                        The Balancer pool that issues the BPTs.\n        @param  _liquidityAsset               Swap out asset (e.g. USDC) to receive when burning BPTs.\n        @param  _staker                       Address that deposited BPTs to StakeLocker.\n        @param  _stakeLocker                  Escrows BPTs deposited by Staker.\n        @param  _liquidityAssetAmountRequired Amount of Liquidity Asset required to recover.\n        @return [0] = poolAmountIn required.\n                [1] = poolAmountIn currently staked.\n    */\n    function getPoolSharesRequired(\n        address _bPool,\n        address _liquidityAsset,\n        address _staker,\n        address _stakeLocker,\n        uint256 _liquidityAssetAmountRequired\n    ) external view returns (uint256, uint256) {\n        return PoolLib.getPoolSharesRequired(_bPool, _liquidityAsset, _staker, _stakeLocker, _liquidityAssetAmountRequired);\n    }\n\n    /**\n      @dev    Checks that the Pool state is `Finalized`.\n      @return bool Boolean value indicating if Pool is in a Finalized state.\n    */\n    function isPoolFinalized() external view returns (bool) {\n        return poolState == State.Finalized;\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /**\n        @dev   Converts to WAD precision.\n        @param amt Amount to convert.\n    */\n    function _toWad(uint256 amt) internal view returns (uint256) {\n        return amt.mul(WAD).div(10 ** liquidityAssetDecimals);\n    }\n\n    /**\n        @dev    Returns the balance of this Pool's LiquidityLocker.\n        @return Balance of LiquidityLocker.\n    */\n    function _balanceOfLiquidityLocker() internal view returns (uint256) {\n        return liquidityAsset.balanceOf(liquidityLocker);\n    }\n\n    /**\n        @dev   Checks that the current state of Pool matches the provided state.\n        @param _state Enum of desired Pool state.\n    */\n    function _isValidState(State _state) internal view {\n        require(poolState == _state, \"P:BAD_STATE\");\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Pool Delegate.\n    */\n    function _isValidDelegate() internal view {\n        require(msg.sender == poolDelegate, \"P:NOT_DEL\");\n    }\n\n    /**\n        @dev Returns the MapleGlobals instance.\n    */\n    function _globals(address poolFactory) internal view returns (IMapleGlobals) {\n        return IMapleGlobals(IPoolFactory(poolFactory).globals());\n    }\n\n    /**\n        @dev Emits a `BalanceUpdated` event for LiquidityLocker.\n        @dev It emits a `BalanceUpdated` event.\n    */\n    function _emitBalanceUpdatedEvent() internal {\n        emit BalanceUpdated(liquidityLocker, address(liquidityAsset), _balanceOfLiquidityLocker());\n    }\n\n    /**\n        @dev   Transfers Liquidity Asset to given `to` address, from self (i.e. `address(this)`).\n        @param to    Address to transfer liquidityAsset.\n        @param value Amount of liquidity asset that gets transferred.\n    */\n    function _transferLiquidityAsset(address to, uint256 value) internal {\n        liquidityAsset.safeTransfer(to, value);\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Pool Delegate or a Pool Admin.\n    */\n    function _isValidDelegateOrPoolAdmin() internal view {\n        require(msg.sender == poolDelegate || poolAdmins[msg.sender], \"P:NOT_DEL_OR_ADMIN\");\n    }\n\n    /**\n        @dev Checks that the protocol is not in a paused state.\n    */\n    function _whenProtocolNotPaused() internal view {\n        require(!_globals(superFactory).protocolPaused(), \"P:PROTO_PAUSED\");\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Pool Delegate and that the protocol is not in a paused state.\n    */\n    function _isValidDelegateAndProtocolNotPaused() internal view {\n        _isValidDelegate();\n        _whenProtocolNotPaused();\n    }\n\n    function _transferLiquidityLockerFunds(address to, uint256 value) internal {\n        ILiquidityLocker(liquidityLocker).transfer(to, value);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IDebtLocker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IDebtLocker {\n\n    function loan() external view returns (address);\n\n    function liquidityAsset() external view returns (address);\n\n    function pool() external view returns (address);\n\n    function lastPrincipalPaid() external view returns (uint256);\n\n    function lastInterestPaid() external view returns (uint256);\n\n    function lastFeePaid() external view returns (uint256);\n\n    function lastExcessReturned() external view returns (uint256);\n\n    function lastDefaultSuffered() external view returns (uint256);\n\n    function lastAmountRecovered() external view returns (uint256);\n\n    function claim() external returns (uint256[7] memory);\n    \n    function triggerDefault() external;\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/ILiquidityLockerFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface ILiquidityLockerFactory {\n\n    function owner(address) external view returns (address);\n    \n    function isLocker(address) external view returns (bool);\n\n    function factoryType() external view returns (uint8);\n\n    function newLocker(address) external returns (address);\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IStakeLockerFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IStakeLockerFactory {\n\n    function owner(address) external returns (address);\n\n    function isLocker(address) external returns (bool);\n\n    function factoryType() external returns (uint8);\n\n    function newLocker(address, address) external returns (address);\n\n}\n"
    },
    "packages/protocol/contracts/library/PoolLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/ILoan.sol\";\nimport \"../interfaces/IBPool.sol\";\nimport \"../interfaces/IMapleGlobals.sol\";\nimport \"../interfaces/ILiquidityLocker.sol\";\nimport \"../interfaces/IERC20Details.sol\";\nimport \"../interfaces/ILoanFactory.sol\";\nimport \"../interfaces/IStakeLocker.sol\";\nimport \"../interfaces/IDebtLockerFactory.sol\";\n\n/// @title PoolLib is a library of utility functions used by Pool.\nlibrary PoolLib {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX_UINT256 = uint256(-1);\n    uint256 public constant WAD         = 10 ** 18;\n    uint8   public constant DL_FACTORY  = 1;         // Factory type of DebtLockerFactory\n\n    event         LoanFunded(address indexed loan, address debtLocker, uint256 amountFunded);\n    event DepositDateUpdated(address indexed liquidityProvider, uint256 depositDate);\n\n    /***************************************/\n    /*** Pool Delegate Utility Functions ***/\n    /***************************************/\n\n    /**\n        @dev   Conducts sanity checks for Pools in the constructor.\n        @param globals        Instance of a MapleGlobals.\n        @param liquidityAsset Asset used by Pool for liquidity to fund loans.\n        @param stakeAsset     Asset escrowed in StakeLocker.\n        @param stakingFee     Fee that the Stakers earn on interest, in basis points.\n        @param delegateFee    Fee that the Pool Delegate earns on interest, in basis points.\n    */\n    function poolSanityChecks(\n        IMapleGlobals globals,\n        address liquidityAsset,\n        address stakeAsset,\n        uint256 stakingFee,\n        uint256 delegateFee\n    ) external view {\n        IBPool bPool = IBPool(stakeAsset);\n\n        require(globals.isValidLiquidityAsset(liquidityAsset), \"P:INVALID_LIQ_ASSET\");\n        require(stakingFee.add(delegateFee) <= 10_000,         \"P:INVALID_FEES\");\n        require(\n            globals.isValidBalancerPool(address(stakeAsset)) &&\n            bPool.isBound(globals.mpl())                     &&\n            bPool.isBound(liquidityAsset)                    &&\n            bPool.isFinalized(),\n            \"P:INVALID_BALANCER_POOL\"\n        );\n    }\n\n    /**\n        @dev   Funds a Loan for an amount, utilizing the supplied DebtLockerFactory for DebtLockers.\n        @dev   It emits a `LoanFunded` event.\n        @param debtLockers     Mapping contains the DebtLocker contract address corresponding to the DebtLockerFactory and Loan.\n        @param superFactory    Address of the PoolFactory.\n        @param liquidityLocker Address of the LiquidityLocker contract attached with this Pool.\n        @param loan            Address of the Loan to fund.\n        @param dlFactory       The DebtLockerFactory to utilize.\n        @param amt             Amount to fund the Loan.\n    */\n    function fundLoan(\n        mapping(address => mapping(address => address)) storage debtLockers,\n        address superFactory,\n        address liquidityLocker,\n        address loan,\n        address dlFactory,\n        uint256 amt\n    ) external {\n        IMapleGlobals globals = IMapleGlobals(ILoanFactory(superFactory).globals());\n        address loanFactory   = ILoan(loan).superFactory();\n\n        // Auth checks.\n        require(globals.isValidLoanFactory(loanFactory),                        \"P:INVALID_LF\");\n        require(ILoanFactory(loanFactory).isLoan(loan),                         \"P:INVALID_L\");\n        require(globals.isValidSubFactory(superFactory, dlFactory, DL_FACTORY), \"P:INVALID_DLF\");\n\n        address debtLocker = debtLockers[loan][dlFactory];\n\n        // Instantiate DebtLocker if it doesn't exist withing this factory\n        if (debtLocker == address(0)) {\n            debtLocker = IDebtLockerFactory(dlFactory).newLocker(loan);\n            debtLockers[loan][dlFactory] = debtLocker;\n        }\n\n        // Fund the Loan.\n        ILiquidityLocker(liquidityLocker).fundLoan(loan, debtLocker, amt);\n\n        emit LoanFunded(loan, debtLocker, amt);\n    }\n\n    /**\n        @dev    Helper function used by Pool `claim` function, for when if a default has occurred.\n        @param  liquidityAsset                  IERC20 of Liquidity Asset.\n        @param  stakeLocker                     Address of StakeLocker.\n        @param  stakeAsset                      Address of BPTs.\n        @param  defaultSuffered                 Amount of shortfall in defaulted Loan after liquidation.\n        @return bptsBurned                      Amount of BPTs burned to cover shortfall.\n        @return postBurnBptBal                  Amount of BPTs returned to StakeLocker after burn.\n        @return liquidityAssetRecoveredFromBurn Amount of Liquidity Asset recovered from burn.\n    */\n    function handleDefault(\n        IERC20  liquidityAsset,\n        address stakeLocker,\n        address stakeAsset,\n        uint256 defaultSuffered\n    )\n        external\n        returns (\n            uint256 bptsBurned,\n            uint256 postBurnBptBal,\n            uint256 liquidityAssetRecoveredFromBurn\n        )\n    {\n\n        IBPool bPool = IBPool(stakeAsset);  // stakeAsset = Balancer Pool Tokens\n\n        // Check amount of Liquidity Asset coverage that exists in the StakeLocker.\n        uint256 availableSwapOut = getSwapOutValueLocker(stakeAsset, address(liquidityAsset), stakeLocker);\n\n        // Pull BPTs from StakeLocker.\n        IStakeLocker(stakeLocker).pull(address(this), bPool.balanceOf(stakeLocker));\n\n        // To maintain accounting, account for direct transfers into Pool.\n        uint256 preBurnLiquidityAssetBal = liquidityAsset.balanceOf(address(this));\n        uint256 preBurnBptBal            = bPool.balanceOf(address(this));\n\n        // Burn enough BPTs for Liquidity Asset to cover default suffered.\n        bPool.exitswapExternAmountOut(\n            address(liquidityAsset),\n            availableSwapOut >= defaultSuffered ? defaultSuffered : availableSwapOut,  // Burn BPTs up to defaultSuffered amount\n            preBurnBptBal\n        );\n\n        // Return remaining BPTs to StakeLocker.\n        postBurnBptBal = bPool.balanceOf(address(this));\n        bptsBurned     = preBurnBptBal.sub(postBurnBptBal);\n        bPool.transfer(stakeLocker, postBurnBptBal);\n        liquidityAssetRecoveredFromBurn = liquidityAsset.balanceOf(address(this)).sub(preBurnLiquidityAssetBal);\n        IStakeLocker(stakeLocker).updateLosses(bptsBurned);  // Update StakeLockerFDT loss accounting for BPTs\n    }\n\n    /**\n        @dev    Calculates portions of claim from DebtLocker to be used by Pool `claim` function.\n        @param  claimInfo           [0] = Total Claimed\n                                    [1] = Interest Claimed\n                                    [2] = Principal Claimed\n                                    [3] = Fee Claimed\n                                    [4] = Excess Returned Claimed\n                                    [5] = Amount Recovered (from Liquidation)\n                                    [6] = Default Suffered\n        @param  delegateFee         Portion of interest (basis points) that goes to the Pool Delegate.\n        @param  stakingFee          Portion of interest (basis points) that goes to the StakeLocker.\n        @return poolDelegatePortion Total funds to send to the Pool Delegate.\n        @return stakeLockerPortion  Total funds to send to the StakeLocker.\n        @return principalClaim      Total principal claim.\n        @return interestClaim       Total interest claim.\n    */\n    function calculateClaimAndPortions(\n        uint256[7] calldata claimInfo,\n        uint256 delegateFee,\n        uint256 stakingFee\n    )\n        external\n        pure\n        returns (\n            uint256 poolDelegatePortion,\n            uint256 stakeLockerPortion,\n            uint256 principalClaim,\n            uint256 interestClaim\n        )\n    {\n        poolDelegatePortion = claimInfo[1].mul(delegateFee).div(10_000).add(claimInfo[3]);  // Pool Delegate portion of interest plus fee.\n        stakeLockerPortion  = claimInfo[1].mul(stakingFee).div(10_000);                     // StakeLocker portion of interest.\n\n        principalClaim = claimInfo[2].add(claimInfo[4]).add(claimInfo[5]);                                     // principal + excess + amountRecovered\n        interestClaim  = claimInfo[1].sub(claimInfo[1].mul(delegateFee).div(10_000)).sub(stakeLockerPortion);  // leftover interest\n    }\n\n    /**\n        @dev   Checks that the deactivation is allowed.\n        @param globals        Instance of a MapleGlobals.\n        @param principalOut   Amount of funds that are already funded to Loans.\n        @param liquidityAsset Liquidity Asset of the Pool.\n    */\n    function validateDeactivation(IMapleGlobals globals, uint256 principalOut, address liquidityAsset) external view {\n        require(principalOut <= _convertFromUsd(globals, liquidityAsset, 100), \"P:PRINCIPAL_OUTSTANDING\");\n    }\n\n    /********************************************/\n    /*** Liquidity Provider Utility Functions ***/\n    /********************************************/\n\n    /**\n        @dev   Updates the effective deposit date based on how much new capital has been added.\n               If more capital is added, the deposit date moves closer to the current timestamp.\n        @dev   It emits a `DepositDateUpdated` event.\n        @param amt     Total deposit amount.\n        @param account Address of account depositing.\n    */\n    function updateDepositDate(mapping(address => uint256) storage depositDate, uint256 balance, uint256 amt, address account) internal {\n        uint256 prevDate = depositDate[account];\n\n        // prevDate + (now - prevDate) * (amt / (balance + amt))\n        // NOTE: prevDate = 0 implies balance = 0, and equation reduces to now\n        uint256 newDate = (balance + amt) > 0\n            ? prevDate.add(block.timestamp.sub(prevDate).mul(amt).div(balance + amt))\n            : prevDate;\n\n        depositDate[account] = newDate;\n        emit DepositDateUpdated(account, newDate);\n    }\n\n    /**\n        @dev Performs all necessary checks for a `transferByCustodian` call.\n        @dev From and to must always be equal.\n    */\n    function transferByCustodianChecks(address from, address to, uint256 amount) external pure {\n        require(to == from,                 \"P:INVALID_RECEIVER\");\n        require(amount != uint256(0),       \"P:INVALID_AMT\");\n    }\n\n    /**\n        @dev Performs all necessary checks for an `increaseCustodyAllowance` call.\n    */\n    function increaseCustodyAllowanceChecks(address custodian, uint256 amount, uint256 newTotalAllowance, uint256 fdtBal) external pure {\n        require(custodian != address(0),     \"P:INVALID_CUSTODIAN\");\n        require(amount    != uint256(0),     \"P:INVALID_AMT\");\n        require(newTotalAllowance <= fdtBal, \"P:INSUF_BALANCE\");\n    }\n\n    /**********************************/\n    /*** Governor Utility Functions ***/\n    /**********************************/\n\n    /**\n        @dev   Transfers any locked funds to the Governor. Only the Governor can call this function.\n        @param token          Address of the token to be reclaimed.\n        @param liquidityAsset Address of Liquidity Asset that is supported by the Pool.\n        @param globals        Instance of a MapleGlobals.\n    */\n    function reclaimERC20(address token, address liquidityAsset, IMapleGlobals globals) external {\n        require(msg.sender == globals.governor(), \"P:NOT_GOV\");\n        require(token != liquidityAsset && token != address(0), \"P:INVALID_TOKEN\");\n        IERC20(token).safeTransfer(msg.sender, IERC20(token).balanceOf(address(this)));\n    }\n\n    /************************/\n    /*** Getter Functions ***/\n    /************************/\n\n    /**\n        @dev Official Balancer pool bdiv() function. Does synthetic float with 10^-18 precision.\n    */\n    function _bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"P:DIV_ZERO\");\n        uint256 c0 = a * WAD;\n        require(a == 0 || c0 / a == WAD, \"P:DIV_INTERNAL\");  // bmul overflow\n        uint256 c1 = c0 + (b / 2);\n        require(c1 >= c0, \"P:DIV_INTERNAL\");  //  badd require\n        return c1 / b;\n    }\n\n    /**\n        @dev    Calculates the value of BPT in units of Liquidity Asset.\n        @dev    Vulnerable to flash-loan attacks where the attacker can artificially inflate the BPT price by swapping a large amount\n                of Liquidity Asset into the Pool and swapping back after this function is called.\n        @param  _bPool         Address of Balancer pool.\n        @param  liquidityAsset Asset used by Pool for liquidity to fund Loans.\n        @param  staker         Address that deposited BPTs to StakeLocker.\n        @param  stakeLocker    Escrows BPTs deposited by Staker.\n        @return USDC value of Staker BPTs.\n    */\n    function BPTVal(\n        address _bPool,\n        address liquidityAsset,\n        address staker,\n        address stakeLocker\n    ) external view returns (uint256) {\n        IBPool bPool = IBPool(_bPool);\n\n        // StakeLockerFDTs are minted 1:1 (in wei) in the StakeLocker when staking BPTs, thus representing stake amount.\n        // These are burned when withdrawing staked BPTs, thus representing the current stake amount.\n        uint256 amountStakedBPT       = IERC20(stakeLocker).balanceOf(staker);\n        uint256 totalSupplyBPT        = IERC20(_bPool).totalSupply();\n        uint256 liquidityAssetBalance = bPool.getBalance(liquidityAsset);\n        uint256 liquidityAssetWeight  = bPool.getNormalizedWeight(liquidityAsset);\n\n        // liquidityAsset value = (amountStaked/totalSupply) * (liquidityAssetBalance/liquidityAssetWeight)\n        return _bdiv(amountStakedBPT, totalSupplyBPT).mul(_bdiv(liquidityAssetBalance, liquidityAssetWeight)).div(WAD);\n    }\n\n    /**\n        @dev    Calculates Liquidity Asset swap out value of staker BPT balance escrowed in StakeLocker.\n        @param  _bPool         Balancer pool that issues the BPTs.\n        @param  liquidityAsset Swap out asset (e.g. USDC) to receive when burning BPTs.\n        @param  staker         Address that deposited BPTs to StakeLocker.\n        @param  stakeLocker    Escrows BPTs deposited by Staker.\n        @return liquidityAsset Swap out value of staker BPTs.\n    */\n    function getSwapOutValue(\n        address _bPool,\n        address liquidityAsset,\n        address staker,\n        address stakeLocker\n    ) public view returns (uint256) {\n        return _getSwapOutValue(_bPool, liquidityAsset, IERC20(stakeLocker).balanceOf(staker));\n    }\n\n    /**\n        @dev    Calculates Liquidity Asset swap out value of entire BPT balance escrowed in StakeLocker.\n        @param  _bPool         Balancer pool that issues the BPTs.\n        @param  liquidityAsset Swap out asset (e.g. USDC) to receive when burning BPTs.\n        @param  stakeLocker    Escrows BPTs deposited by Staker.\n        @return liquidityAsset Swap out value of StakeLocker BPTs.\n    */\n    function getSwapOutValueLocker(\n        address _bPool,\n        address liquidityAsset,\n        address stakeLocker\n    ) public view returns (uint256) {\n        return _getSwapOutValue(_bPool, liquidityAsset, IBPool(_bPool).balanceOf(stakeLocker));\n    }\n\n    function _getSwapOutValue(\n        address _bPool,\n        address liquidityAsset,\n        uint256 poolAmountIn\n    ) internal view returns (uint256) {\n        // Fetch Balancer pool token information\n        IBPool bPool            = IBPool(_bPool);\n        uint256 tokenBalanceOut = bPool.getBalance(liquidityAsset);\n        uint256 tokenWeightOut  = bPool.getDenormalizedWeight(liquidityAsset);\n        uint256 poolSupply      = bPool.totalSupply();\n        uint256 totalWeight     = bPool.getTotalDenormalizedWeight();\n        uint256 swapFee         = bPool.getSwapFee();\n\n        // Returns the amount of liquidityAsset that can be recovered from BPT burning\n        uint256 tokenAmountOut = bPool.calcSingleOutGivenPoolIn(\n            tokenBalanceOut,\n            tokenWeightOut,\n            poolSupply,\n            totalWeight,\n            poolAmountIn,\n            swapFee\n        );\n\n        // Max amount that can be swapped based on amount of liquidityAsset in the Balancer Pool\n        uint256 maxSwapOut = tokenBalanceOut.mul(bPool.MAX_OUT_RATIO()).div(WAD);\n\n        return tokenAmountOut <= maxSwapOut ? tokenAmountOut : maxSwapOut;\n    }\n\n    /**\n        @dev    Calculates BPTs required if burning BPTs for liquidityAsset, given supplied tokenAmountOutRequired.\n        @dev    Vulnerable to flash-loan attacks where the attacker can artificially inflate the BPT price by swapping a large amount\n                of liquidityAsset into the pool and swapping back after this function is called.\n        @param  _bPool                       Balancer pool that issues the BPTs.\n        @param  liquidityAsset               Swap out asset (e.g. USDC) to receive when burning BPTs.\n        @param  staker                       Address that deposited BPTs to stakeLocker.\n        @param  stakeLocker                  Escrows BPTs deposited by staker.\n        @param  liquidityAssetAmountRequired Amount of liquidityAsset required to recover.\n        @return poolAmountInRequired         poolAmountIn required.\n        @return stakerBalance                poolAmountIn currently staked.\n    */\n    function getPoolSharesRequired(\n        address _bPool,\n        address liquidityAsset,\n        address staker,\n        address stakeLocker,\n        uint256 liquidityAssetAmountRequired\n    ) public view returns (uint256 poolAmountInRequired, uint256 stakerBalance) {\n        // Fetch Balancer pool token information.\n        IBPool bPool = IBPool(_bPool);\n\n        uint256 tokenBalanceOut = bPool.getBalance(liquidityAsset);\n        uint256 tokenWeightOut  = bPool.getDenormalizedWeight(liquidityAsset);\n        uint256 poolSupply      = bPool.totalSupply();\n        uint256 totalWeight     = bPool.getTotalDenormalizedWeight();\n        uint256 swapFee         = bPool.getSwapFee();\n\n        // Fetch amount of BPTs required to burn to receive Liquidity Asset amount required.\n        poolAmountInRequired = bPool.calcPoolInGivenSingleOut(\n            tokenBalanceOut,\n            tokenWeightOut,\n            poolSupply,\n            totalWeight,\n            liquidityAssetAmountRequired,\n            swapFee\n        );\n\n        // Fetch amount staked in StakeLocker by Staker.\n        stakerBalance = IERC20(stakeLocker).balanceOf(staker);\n    }\n\n    /**\n        @dev    Returns information on the stake requirements.\n        @param  globals                    Instance of a MapleGlobals.\n        @param  balancerPool               Address of Balancer pool.\n        @param  liquidityAsset             Address of Liquidity Asset, to be returned from swap out.\n        @param  poolDelegate               Address of Pool Delegate.\n        @param  stakeLocker                Address of StakeLocker.\n        @return swapOutAmountRequired      Min amount of Liquidity Asset coverage from staking required (in Liquidity Asset units).\n        @return currentPoolDelegateCover   Present amount of Liquidity Asset coverage from Pool Delegate stake (in Liquidity Asset units).\n        @return enoughStakeForFinalization If enough stake is present from Pool Delegate for Pool finalization.\n        @return poolAmountInRequired       BPTs required for minimum Liquidity Asset coverage.\n        @return poolAmountPresent          Current staked BPTs.\n    */\n    function getInitialStakeRequirements(IMapleGlobals globals, address balancerPool, address liquidityAsset, address poolDelegate, address stakeLocker) external view returns (\n        uint256 swapOutAmountRequired,\n        uint256 currentPoolDelegateCover,\n        bool    enoughStakeForFinalization,\n        uint256 poolAmountInRequired,\n        uint256 poolAmountPresent\n    ) {\n        swapOutAmountRequired = _convertFromUsd(globals, liquidityAsset, globals.swapOutRequired());\n        (\n            poolAmountInRequired,\n            poolAmountPresent\n        ) = getPoolSharesRequired(balancerPool, liquidityAsset, poolDelegate, stakeLocker, swapOutAmountRequired);\n\n        currentPoolDelegateCover   = getSwapOutValue(balancerPool, liquidityAsset, poolDelegate, stakeLocker);\n        enoughStakeForFinalization = poolAmountPresent >= poolAmountInRequired;\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /**\n        @dev   Converts from WAD precision to Liquidity Asset precision.\n        @param amt                    Amount to convert.\n        @param liquidityAssetDecimals Liquidity Asset decimal.\n    */\n    function fromWad(uint256 amt, uint256 liquidityAssetDecimals) external pure returns (uint256) {\n        return amt.mul(10 ** liquidityAssetDecimals).div(WAD);\n    }\n\n    /**\n        @dev    Returns Liquidity Asset in Liquidity Asset units when given integer USD (E.g., $100 = 100).\n        @param  globals        Instance of a MapleGlobals.\n        @param  liquidityAsset Liquidity Asset of the pool.\n        @param  usdAmount      USD amount to convert, in integer units (e.g., $100 = 100).\n        @return usdAmount worth of Liquidity Asset, in Liquidity Asset units.\n    */\n    function _convertFromUsd(IMapleGlobals globals, address liquidityAsset, uint256 usdAmount) internal view returns (uint256) {\n        return usdAmount\n            .mul(10 ** 8)                                         // Cancel out 10 ** 8 decimals from oracle.\n            .mul(10 ** IERC20Details(liquidityAsset).decimals())  // Convert to Liquidity Asset precision.\n            .div(globals.getLatestPrice(liquidityAsset));         // Convert to Liquidity Asset value.\n    }\n}\n"
    },
    "packages/protocol/contracts/token/PoolFDT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./ExtendedFDT.sol\";\n\n/// @title PoolFDT inherits ExtendedFDT and accounts for gains/losses for Liquidity Providers.\nabstract contract PoolFDT is ExtendedFDT {\n    using SafeMath       for uint256;\n    using SafeMathUint   for uint256;\n    using SignedSafeMath for  int256;\n    using SafeMathInt    for  int256;\n\n    uint256 public interestSum;  // Sum of all withdrawable interest.\n    uint256 public poolLosses;   // Sum of all unrecognized losses.\n\n    uint256 public interestBalance;  // The amount of earned interest present and accounted for in this contract.\n    uint256 public lossesBalance;    // The amount of losses present and accounted for in this contract.\n\n    constructor(string memory name, string memory symbol) ExtendedFDT(name, symbol) public { }\n\n    /**\n        @dev Realizes losses incurred to LPs.\n    */\n    function _recognizeLosses() internal override returns (uint256 losses) {\n        losses = _prepareLossesWithdraw();\n\n        poolLosses = poolLosses.sub(losses);\n\n        _updateLossesBalance();\n    }\n\n    /**\n        @dev    Updates the current losses balance and returns the difference of the new and previous losses balance.\n        @return A int256 representing the difference of the new and previous losses balance.\n    */\n    function _updateLossesBalance() internal override returns (int256) {\n        uint256 _prevLossesTokenBalance = lossesBalance;\n\n        lossesBalance = poolLosses;\n\n        return int256(lossesBalance).sub(int256(_prevLossesTokenBalance));\n    }\n\n    /**\n        @dev    Updates the current interest balance and returns the difference of the new and previous interest balance.\n        @return A int256 representing the difference of the new and previous interest balance.\n    */\n    function _updateFundsTokenBalance() internal override returns (int256) {\n        uint256 _prevFundsTokenBalance = interestBalance;\n\n        interestBalance = interestSum;\n\n        return int256(interestBalance).sub(int256(_prevFundsTokenBalance));\n    }\n}\n"
    },
    "packages/protocol/contracts/interfaces/IDebtLockerFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IDebtLockerFactory {\n\n    function owner(address) external view returns (address);\n\n    function isLocker(address) external view returns (bool);\n\n    function factoryType() external view returns (uint8);\n\n    function newLocker(address) external returns (address);\n\n}\n"
    },
    "packages/protocol/contracts/token/ExtendedFDT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./BasicFDT.sol\";\n\n/// @title ExtendedFDT implements FDT functionality for accounting for losses.\nabstract contract ExtendedFDT is BasicFDT {\n    using SafeMath       for uint256;\n    using SafeMathUint   for uint256;\n    using SignedSafeMath for  int256;\n    using SafeMathInt    for  int256;\n\n    uint256 internal lossesPerShare;\n\n    mapping(address => int256)  internal lossesCorrection;\n    mapping(address => uint256) internal recognizedLosses;\n\n    event   LossesPerShareUpdated(uint256 lossesPerShare);\n    event LossesCorrectionUpdated(address indexed account, int256 lossesCorrection);\n\n    /**\n        @dev   This event emits when new losses are distributed.\n        @param by                The address of the account that has distributed losses.\n        @param lossesDistributed The amount of losses received for distribution.\n    */\n    event LossesDistributed(address indexed by, uint256 lossesDistributed);\n\n    /**\n        @dev   This event emits when distributed losses are recognized by a token holder.\n        @param by                    The address of the receiver of losses.\n        @param lossesRecognized      The amount of losses that were recognized.\n        @param totalLossesRecognized The total amount of losses that are recognized.\n    */\n    event LossesRecognized(address indexed by, uint256 lossesRecognized, uint256 totalLossesRecognized);\n\n    constructor(string memory name, string memory symbol) BasicFDT(name, symbol) public { }\n\n    /**\n        @dev Distributes losses to token holders.\n        @dev It reverts if the total supply of tokens is 0.\n        @dev It emits a `LossesDistributed` event if the amount of received losses is greater than 0.\n        @dev It emits a `LossesPerShareUpdated` event if the amount of received losses is greater than 0.\n             About undistributed losses:\n                In each distribution, there is a small amount of losses which do not get distributed,\n                which is `(value * pointsMultiplier) % totalSupply()`.\n             With a well-chosen `pointsMultiplier`, the amount losses that are not getting distributed\n                in a distribution can be less than 1 (base unit).\n             We can actually keep track of the undistributed losses in a distribution\n                and try to distribute it in the next distribution.\n    */\n    function _distributeLosses(uint256 value) internal {\n        require(totalSupply() > 0, \"FDT:ZERO_SUPPLY\");\n\n        if (value == 0) return;\n\n        uint256 _lossesPerShare = lossesPerShare.add(value.mul(pointsMultiplier) / totalSupply());\n        lossesPerShare          = _lossesPerShare;\n\n        emit LossesDistributed(msg.sender, value);\n        emit LossesPerShareUpdated(_lossesPerShare);\n    }\n\n    /**\n        @dev    Prepares losses for a withdrawal.\n        @dev    It emits a `LossesWithdrawn` event if the amount of withdrawn losses is greater than 0.\n        @return recognizableDividend The amount of dividend losses that can be recognized.\n    */\n    function _prepareLossesWithdraw() internal returns (uint256 recognizableDividend) {\n        recognizableDividend = recognizableLossesOf(msg.sender);\n\n        uint256 _recognizedLosses    = recognizedLosses[msg.sender].add(recognizableDividend);\n        recognizedLosses[msg.sender] = _recognizedLosses;\n\n        emit LossesRecognized(msg.sender, recognizableDividend, _recognizedLosses);\n    }\n\n    /**\n        @dev    Returns the amount of losses that an address can withdraw.\n        @param  _owner The address of a token holder.\n        @return The amount of losses that `_owner` can withdraw.\n    */\n    function recognizableLossesOf(address _owner) public view returns (uint256) {\n        return accumulativeLossesOf(_owner).sub(recognizedLosses[_owner]);\n    }\n\n    /**\n        @dev    Returns the amount of losses that an address has recognized.\n        @param  _owner The address of a token holder\n        @return The amount of losses that `_owner` has recognized\n    */\n    function recognizedLossesOf(address _owner) external view returns (uint256) {\n        return recognizedLosses[_owner];\n    }\n\n    /**\n        @dev    Returns the amount of losses that an address has earned in total.\n        @dev    accumulativeLossesOf(_owner) = recognizableLossesOf(_owner) + recognizedLossesOf(_owner)\n                = (lossesPerShare * balanceOf(_owner) + lossesCorrection[_owner]) / pointsMultiplier\n        @param  _owner The address of a token holder\n        @return The amount of losses that `_owner` has earned in total\n    */\n    function accumulativeLossesOf(address _owner) public view returns (uint256) {\n        return\n            lossesPerShare\n                .mul(balanceOf(_owner))\n                .toInt256Safe()\n                .add(lossesCorrection[_owner])\n                .toUint256Safe() / pointsMultiplier;\n    }\n\n    /**\n        @dev   Transfers tokens from one account to another. Updates pointsCorrection to keep funds unchanged.\n        @dev         It emits two `LossesCorrectionUpdated` events, one for the sender and one for the receiver.\n        @param from  The address to transfer from.\n        @param to    The address to transfer to.\n        @param value The amount to be transferred.\n    */\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual override {\n        super._transfer(from, to, value);\n\n        int256 _lossesCorrection    = lossesPerShare.mul(value).toInt256Safe();\n        int256 lossesCorrectionFrom = lossesCorrection[from].add(_lossesCorrection);\n        lossesCorrection[from]      = lossesCorrectionFrom;\n        int256 lossesCorrectionTo   = lossesCorrection[to].sub(_lossesCorrection);\n        lossesCorrection[to]        = lossesCorrectionTo;\n\n        emit LossesCorrectionUpdated(from, lossesCorrectionFrom);\n        emit LossesCorrectionUpdated(to,   lossesCorrectionTo);\n    }\n\n    /**\n        @dev   Mints tokens to an account. Updates lossesCorrection to keep losses unchanged.\n        @dev   It emits a `LossesCorrectionUpdated` event.\n        @param account The account that will receive the created tokens.\n        @param value   The amount that will be created.\n    */\n    function _mint(address account, uint256 value) internal virtual override {\n        super._mint(account, value);\n\n        int256 _lossesCorrection = lossesCorrection[account].sub(\n            (lossesPerShare.mul(value)).toInt256Safe()\n        );\n\n        lossesCorrection[account] = _lossesCorrection;\n\n        emit LossesCorrectionUpdated(account, _lossesCorrection);\n    }\n\n    /**\n        @dev   Burns an amount of the token of a given account. Updates lossesCorrection to keep losses unchanged.\n        @dev   It emits a `LossesCorrectionUpdated` event.\n        @param account The account from which tokens will be burnt.\n        @param value   The amount that will be burnt.\n    */\n    function _burn(address account, uint256 value) internal virtual override {\n        super._burn(account, value);\n\n        int256 _lossesCorrection = lossesCorrection[account].add(\n            (lossesPerShare.mul(value)).toInt256Safe()\n        );\n\n        lossesCorrection[account] = _lossesCorrection;\n\n        emit LossesCorrectionUpdated(account, _lossesCorrection);\n    }\n\n    /**\n        @dev Registers a loss. May be called directly after a shortfall after BPT burning occurs.\n        @dev Calls _updateLossesTokenBalance(), whereby the contract computes the delta of the new and previous\n             losses balance and increments the total losses (cumulative), by delta, by calling _distributeLosses().\n    */\n    function updateLossesReceived() public virtual {\n        int256 newLosses = _updateLossesBalance();\n\n        if (newLosses <= 0) return;\n\n        _distributeLosses(newLosses.toUint256Safe());\n    }\n\n    /**\n        @dev Recognizes all recognizable losses for an account using loss accounting.\n    */\n    function _recognizeLosses() internal virtual returns (uint256 losses) { }\n\n    /**\n        @dev    Updates the current losses balance and returns the difference of the new and previous losses balance.\n        @return A int256 representing the difference of the new and previous losses balance.\n    */\n    function _updateLossesBalance() internal virtual returns (int256) { }\n}\n"
    },
    "packages/protocol/contracts/StakeLocker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport \"./interfaces/IMapleGlobals.sol\";\nimport \"./interfaces/IPool.sol\";\nimport \"./interfaces/IPoolFactory.sol\";\n\nimport \"./token/StakeLockerFDT.sol\";\n\n/// @title StakeLocker holds custody of stakeAsset tokens for a given Pool and earns revenue from interest.\ncontract StakeLocker is StakeLockerFDT, Pausable {\n\n    using SafeMathInt    for int256;\n    using SignedSafeMath for int256;\n    using SafeERC20      for IERC20;\n\n    uint256 constant WAD = 10 ** 18;  // Scaling factor for synthetic float division.\n\n    IERC20  public immutable stakeAsset;  // The asset deposited by Stakers into this contract, for liquidation during defaults.\n\n    address public immutable liquidityAsset;  // The Liquidity Asset for the Pool as well as the dividend token for StakeLockerFDT interest.\n    address public immutable pool;            // The parent Pool.\n\n    uint256 public lockupPeriod;  // Number of seconds for which unstaking is not allowed.\n\n    mapping(address => uint256)                     public stakeDate;              // Map of account addresses to effective stake date.\n    mapping(address => uint256)                     public unstakeCooldown;        // The timestamp of when a Staker called `cooldown()`.\n    mapping(address => bool)                        public allowed;                // Map of addresses to allowed status.\n    mapping(address => mapping(address => uint256)) public custodyAllowance;       // Amount of StakeLockerFDTs that are \"locked\" at a certain address.\n    mapping(address => uint256)                     public totalCustodyAllowance;  // Total amount of StakeLockerFDTs that are \"locked\" for a given account, cannot be greater than balance.\n\n    bool public openToPublic;  // Boolean opening StakeLocker to public for staking BPTs\n\n    event            StakeLockerOpened();\n    event               BalanceUpdated(address indexed staker, address indexed token, uint256 balance);\n    event             AllowListUpdated(address indexed staker, bool status);\n    event             StakeDateUpdated(address indexed staker, uint256 stakeDate);\n    event          LockupPeriodUpdated(uint256 lockupPeriod);\n    event                     Cooldown(address indexed staker, uint256 cooldown);\n    event                        Stake(address indexed staker, uint256 amount);\n    event                      Unstake(address indexed staker, uint256 amount);\n    event              CustodyTransfer(address indexed custodian, address indexed from, address indexed to, uint256 amount);\n    event      CustodyAllowanceChanged(address indexed staker, address indexed custodian, uint256 oldAllowance, uint256 newAllowance);\n    event TotalCustodyAllowanceUpdated(address indexed staker, uint256 newTotalAllowance);\n\n    constructor(\n        address _stakeAsset,\n        address _liquidityAsset,\n        address _pool\n    ) StakeLockerFDT(\"Maple StakeLocker\", \"MPLSTAKE\", _liquidityAsset) public {\n        liquidityAsset = _liquidityAsset;\n        stakeAsset     = IERC20(_stakeAsset);\n        pool           = _pool;\n        lockupPeriod   = 180 days;\n    }\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    /**\n        @dev Checks that an account can unstake given the following conditions:\n                 1. The Account is not the Pool Delegate and the Pool is in Finalized state.\n                 2. The Pool is in Initialized or Deactivated state.\n    */\n    modifier canUnstake(address from) {\n        IPool _pool = IPool(pool);\n\n        // The Pool cannot be finalized, but if it is, account cannot be the Pool Delegate.\n        require(!_pool.isPoolFinalized() || from != _pool.poolDelegate(), \"SL:STAKE_LOCKED\");\n        _;\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Governor.\n    */\n    modifier isGovernor() {\n        require(msg.sender == _globals().governor(), \"SL:NOT_GOV\");\n        _;\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Pool.\n    */\n    modifier isPool() {\n        require(msg.sender == pool, \"SL:NOT_P\");\n        _;\n    }\n\n    /**********************/\n    /*** Pool Functions ***/\n    /**********************/\n\n    /**\n        @dev   Updates Staker status on the allowlist. Only the Pool Delegate can call this function.\n        @dev   It emits an `AllowListUpdated` event.\n        @param staker The address of the Staker to set status for.\n        @param status The status of the Staker on allowlist.\n    */\n    function setAllowlist(address staker, bool status) public {\n        _whenProtocolNotPaused();\n        _isValidPoolDelegate();\n        allowed[staker] = status;\n        emit AllowListUpdated(staker, status);\n    }\n\n    /**\n        @dev Sets the StakeLocker as open to the public. Only the Pool Delegate can call this function.\n        @dev It emits a `StakeLockerOpened` event.\n    */\n    function openStakeLockerToPublic() external {\n        _whenProtocolNotPaused();\n        _isValidPoolDelegate();\n        openToPublic = true;\n        emit StakeLockerOpened();\n    }\n\n    /**\n        @dev   Sets the lockup period. Only the Pool Delegate can call this function.\n        @dev   It emits a `LockupPeriodUpdated` event.\n        @param newLockupPeriod New lockup period used to restrict unstaking.\n    */\n    function setLockupPeriod(uint256 newLockupPeriod) external {\n        _whenProtocolNotPaused();\n        _isValidPoolDelegate();\n        require(newLockupPeriod <= lockupPeriod, \"SL:INVALID_VALUE\");\n        lockupPeriod = newLockupPeriod;\n        emit LockupPeriodUpdated(newLockupPeriod);\n    }\n\n    /**\n        @dev   Transfers an amount of Stake Asset to a destination account. Only the Pool can call this function.\n        @param dst Destination to transfer Stake Asset to.\n        @param amt Amount of Stake Asset to transfer.\n    */\n    function pull(address dst, uint256 amt) isPool external {\n        stakeAsset.safeTransfer(dst, amt);\n    }\n\n    /**\n        @dev   Updates loss accounting for StakeLockerFDTs after BPTs have been burned. Only the Pool can call this function.\n        @param bptsBurned Amount of BPTs that have been burned.\n    */\n    function updateLosses(uint256 bptsBurned) isPool external {\n        bptLosses = bptLosses.add(bptsBurned);\n        updateLossesReceived();\n    }\n\n    /************************/\n    /*** Staker Functions ***/\n    /************************/\n\n    /**\n        @dev   Handles a Staker's depositing of an amount of Stake Asset, minting them StakeLockerFDTs.\n        @dev   It emits a `StakeDateUpdated` event.\n        @dev   It emits a `Stake` event.\n        @dev   It emits a `Cooldown` event.\n        @dev   It emits a `BalanceUpdated` event.\n        @param amt Amount of Stake Asset (BPTs) to deposit.\n    */\n    function stake(uint256 amt) whenNotPaused external {\n        _whenProtocolNotPaused();\n        _isAllowed(msg.sender);\n\n        unstakeCooldown[msg.sender] = uint256(0);  // Reset account's unstake cooldown if Staker had previously intended to unstake.\n\n        _updateStakeDate(msg.sender, amt);\n\n        stakeAsset.safeTransferFrom(msg.sender, address(this), amt);\n        _mint(msg.sender, amt);\n\n        emit Stake(msg.sender, amt);\n        emit Cooldown(msg.sender, uint256(0));\n        emit BalanceUpdated(address(this), address(stakeAsset), stakeAsset.balanceOf(address(this)));\n    }\n\n    /**\n        @dev   Updates information used to calculate unstake delay.\n        @dev   It emits a `StakeDateUpdated` event.\n        @param account The Staker that deposited BPTs.\n        @param amt     Amount of BPTs the Staker has deposited.\n    */\n    function _updateStakeDate(address account, uint256 amt) internal {\n        uint256 prevDate = stakeDate[account];\n        uint256 balance = balanceOf(account);\n\n        // stakeDate + (now - stakeDate) * (amt / (balance + amt))\n        // NOTE: prevDate = 0 implies balance = 0, and equation reduces to now.\n        uint256 newDate = (balance + amt) > 0\n            ? prevDate.add(block.timestamp.sub(prevDate).mul(amt).div(balance + amt))\n            : prevDate;\n\n        stakeDate[account] = newDate;\n        emit StakeDateUpdated(account, newDate);\n    }\n\n    /**\n        @dev Activates the cooldown period to unstake. It can't be called if the account is not staking.\n        @dev It emits a `Cooldown` event.\n    **/\n    function intendToUnstake() external {\n        require(balanceOf(msg.sender) != uint256(0), \"SL:ZERO_BALANCE\");\n        unstakeCooldown[msg.sender] = block.timestamp;\n        emit Cooldown(msg.sender, block.timestamp);\n    }\n\n    /**\n        @dev Cancels an initiated unstake by resetting the calling account's unstake cooldown.\n        @dev It emits a `Cooldown` event.\n    */\n    function cancelUnstake() external {\n        require(unstakeCooldown[msg.sender] != uint256(0), \"SL:NOT_UNSTAKING\");\n        unstakeCooldown[msg.sender] = 0;\n        emit Cooldown(msg.sender, uint256(0));\n    }\n\n    /**\n        @dev   Handles a Staker's withdrawing of an amount of Stake Asset, minus any losses. It also claims interest and burns StakeLockerFDTs for the calling account.\n        @dev   It emits an `Unstake` event.\n        @dev   It emits a `BalanceUpdated` event.\n        @param amt Amount of Stake Asset (BPTs) to withdraw.\n    */\n    function unstake(uint256 amt) external canUnstake(msg.sender) {\n        _whenProtocolNotPaused();\n\n        require(balanceOf(msg.sender).sub(amt) >= totalCustodyAllowance[msg.sender], \"SL:INSUF_UNSTAKEABLE_BAL\");  // Account can only unstake tokens that aren't custodied\n        require(isUnstakeAllowed(msg.sender),                                        \"SL:OUTSIDE_COOLDOWN\");\n        require(stakeDate[msg.sender].add(lockupPeriod) <= block.timestamp,          \"SL:FUNDS_LOCKED\");\n\n        updateFundsReceived();   // Account for any funds transferred into contract since last call.\n        _burn(msg.sender, amt);  // Burn the corresponding StakeLockerFDTs balance.\n        withdrawFunds();         // Transfer the full entitled Liquidity Asset interest.\n\n        stakeAsset.safeTransfer(msg.sender, amt.sub(_recognizeLosses()));  // Unstake amount minus losses.\n\n        emit Unstake(msg.sender, amt);\n        emit BalanceUpdated(address(this), address(stakeAsset), stakeAsset.balanceOf(address(this)));\n    }\n\n    /**\n        @dev Withdraws all claimable interest earned from the StakeLocker for an account.\n        @dev It emits a `BalanceUpdated` event if there are withdrawable funds.\n    */\n    function withdrawFunds() public override {\n        _whenProtocolNotPaused();\n\n        uint256 withdrawableFunds = _prepareWithdraw();\n\n        if (withdrawableFunds == uint256(0)) return;\n\n        fundsToken.safeTransfer(msg.sender, withdrawableFunds);\n        emit BalanceUpdated(address(this), address(fundsToken), fundsToken.balanceOf(address(this)));\n\n        _updateFundsTokenBalance();\n    }\n\n    /**\n        @dev   Increases the custody allowance for a given Custodian corresponding to the account (`msg.sender`).\n        @dev   It emits a `CustodyAllowanceChanged` event.\n        @dev   It emits a `TotalCustodyAllowanceUpdated` event.\n        @param custodian Address which will act as Custodian of a given amount for an account.\n        @param amount    Number of additional FDTs to be custodied by the Custodian.\n    */\n    function increaseCustodyAllowance(address custodian, uint256 amount) external {\n        uint256 oldAllowance      = custodyAllowance[msg.sender][custodian];\n        uint256 newAllowance      = oldAllowance.add(amount);\n        uint256 newTotalAllowance = totalCustodyAllowance[msg.sender].add(amount);\n\n        require(custodian != address(0),                    \"SL:INVALID_CUSTODIAN\");\n        require(amount    != uint256(0),                    \"SL:INVALID_AMT\");\n        require(newTotalAllowance <= balanceOf(msg.sender), \"SL:INSUF_BALANCE\");\n\n        custodyAllowance[msg.sender][custodian] = newAllowance;\n        totalCustodyAllowance[msg.sender]       = newTotalAllowance;\n        emit CustodyAllowanceChanged(msg.sender, custodian, oldAllowance, newAllowance);\n        emit TotalCustodyAllowanceUpdated(msg.sender, newTotalAllowance);\n    }\n\n    /**\n        @dev   Transfers custodied StakeLockerFDTs back to the account.\n        @dev   `from` and `to` should always be equal in this implementation.\n        @dev   This means that the Custodian can only decrease their own allowance and unlock funds for the original owner.\n        @dev   It emits a `CustodyTransfer` event.\n        @dev   It emits a `CustodyAllowanceChanged` event.\n        @dev   It emits a `TotalCustodyAllowanceUpdated` event.\n        @param from   Address which holds the StakeLockerFDTs.\n        @param to     Address which will be the new owner of the amount of StakeLockerFDTs.\n        @param amount Amount of StakeLockerFDTs transferred.\n    */\n    function transferByCustodian(address from, address to, uint256 amount) external {\n        uint256 oldAllowance = custodyAllowance[from][msg.sender];\n        uint256 newAllowance = oldAllowance.sub(amount);\n\n        require(to == from,             \"SL:INVALID_RECEIVER\");\n        require(amount != uint256(0),   \"SL:INVALID_AMT\");\n\n        custodyAllowance[from][msg.sender] = newAllowance;\n        uint256 newTotalAllowance          = totalCustodyAllowance[from].sub(amount);\n        totalCustodyAllowance[from]        = newTotalAllowance;\n        emit CustodyTransfer(msg.sender, from, to, amount);\n        emit CustodyAllowanceChanged(from, msg.sender, oldAllowance, newAllowance);\n        emit TotalCustodyAllowanceUpdated(msg.sender, newTotalAllowance);\n    }\n\n    /**\n        @dev   Transfers StakeLockerFDTs.\n        @param from Address sending   StakeLockerFDTs.\n        @param to   Address receiving StakeLockerFDTs.\n        @param wad  Amount of StakeLockerFDTs to transfer.\n    */\n    function _transfer(address from, address to, uint256 wad) internal override canUnstake(from) {\n        _whenProtocolNotPaused();\n        require(stakeDate[from].add(lockupPeriod) <= block.timestamp,    \"SL:FUNDS_LOCKED\");            // Restrict withdrawal during lockup period\n        require(balanceOf(from).sub(wad) >= totalCustodyAllowance[from], \"SL:INSUF_TRANSFERABLE_BAL\");  // Account can only transfer tokens that aren't custodied\n        require(isReceiveAllowed(unstakeCooldown[to]),                   \"SL:RECIPIENT_NOT_ALLOWED\");   // Recipient must not be currently unstaking\n        require(recognizableLossesOf(from) == uint256(0),                \"SL:RECOG_LOSSES\");            // If a staker has unrecognized losses, they must recognize losses through unstake\n        _updateStakeDate(to, wad);                                                                      // Update stake date of recipient\n        super._transfer(from, to, wad);\n    }\n\n    /***********************/\n    /*** Admin Functions ***/\n    /***********************/\n\n    /**\n        @dev Triggers paused state. Halts functionality for certain functions. Only the Pool Delegate or a Pool Admin can call this function.\n    */\n    function pause() external {\n        _isValidPoolDelegateOrPoolAdmin();\n        super._pause();\n    }\n\n    /**\n        @dev Triggers unpaused state. Restores functionality for certain functions. Only the Pool Delegate or a Pool Admin can call this function.\n    */\n    function unpause() external {\n        _isValidPoolDelegateOrPoolAdmin();\n        super._unpause();\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /**\n        @dev Returns if the unstake cooldown period has passed for `msg.sender` and if they are in the unstake window.\n    */\n    function isUnstakeAllowed(address from) public view returns (bool) {\n        IMapleGlobals globals = _globals();\n        return (block.timestamp - (unstakeCooldown[from] + globals.stakerCooldownPeriod())) <= globals.stakerUnstakeWindow();\n    }\n\n    /**\n        @dev Returns if an account is allowed to receive a transfer.\n             This is only possible if they have zero cooldown or they are past their unstake window.\n    */\n    function isReceiveAllowed(uint256 _unstakeCooldown) public view returns (bool) {\n        IMapleGlobals globals = _globals();\n        return block.timestamp > (_unstakeCooldown + globals.stakerCooldownPeriod() + globals.stakerUnstakeWindow());\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Pool Delegate or a Pool Admin.\n    */\n    function _isValidPoolDelegateOrPoolAdmin() internal view {\n        require(msg.sender == IPool(pool).poolDelegate() || IPool(pool).poolAdmins(msg.sender), \"SL:NOT_DELEGATE_OR_ADMIN\");\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Pool Delegate.\n    */\n    function _isValidPoolDelegate() internal view {\n        require(msg.sender == IPool(pool).poolDelegate(), \"SL:NOT_DELEGATE\");\n    }\n\n    /**\n        @dev Checks that `msg.sender` is allowed to stake.\n    */\n    function _isAllowed(address account) internal view {\n        require(\n            openToPublic || allowed[account] || account == IPool(pool).poolDelegate(),\n            \"SL:NOT_ALLOWED\"\n        );\n    }\n\n    /**\n        @dev Returns the MapleGlobals instance.\n    */\n    function _globals() internal view returns (IMapleGlobals) {\n        return IMapleGlobals(IPoolFactory(IPool(pool).superFactory()).globals());\n    }\n\n    /**\n        @dev Checks that the protocol is not in a paused state.\n    */\n    function _whenProtocolNotPaused() internal view {\n        require(!_globals().protocolPaused(), \"SL:PROTO_PAUSED\");\n    }\n\n}\n"
    },
    "packages/protocol/contracts/token/StakeLockerFDT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./ExtendedFDT.sol\";\n\n/// @title StakeLockerFDT inherits ExtendedFDT and accounts for gains/losses for Stakers.\nabstract contract StakeLockerFDT is ExtendedFDT {\n    using SafeMath       for uint256;\n    using SafeMathUint   for uint256;\n    using SignedSafeMath for  int256;\n    using SafeMathInt    for  int256;\n\n    IERC20 public immutable fundsToken;\n\n    uint256 public bptLosses;          // Sum of all unrecognized losses.\n    uint256 public lossesBalance;      // The amount of losses present and accounted for in this contract.\n    uint256 public fundsTokenBalance;  // The amount of `fundsToken` (Liquidity Asset) currently present and accounted for in this contract.\n\n    constructor(string memory name, string memory symbol, address _fundsToken) ExtendedFDT(name, symbol) public {\n        fundsToken = IERC20(_fundsToken);\n    }\n\n    /**\n        @dev    Updates loss accounting for `msg.sender`, recognizing losses.\n        @return losses Amount to be subtracted from a withdraw amount.\n    */\n    function _recognizeLosses() internal override returns (uint256 losses) {\n        losses = _prepareLossesWithdraw();\n\n        bptLosses = bptLosses.sub(losses);\n\n        _updateLossesBalance();\n    }\n\n    /**\n        @dev    Updates the current losses balance and returns the difference of the new and previous losses balance.\n        @return A int256 representing the difference of the new and previous losses balance.\n    */\n    function _updateLossesBalance() internal override returns (int256) {\n        uint256 _prevLossesTokenBalance = lossesBalance;\n\n        lossesBalance = bptLosses;\n\n        return int256(lossesBalance).sub(int256(_prevLossesTokenBalance));\n    }\n\n    /**\n        @dev    Updates the current interest balance and returns the difference of the new and previous interest balance.\n        @return A int256 representing the difference of the new and previous interest balance.\n    */\n    function _updateFundsTokenBalance() internal virtual override returns (int256) {\n        uint256 _prevFundsTokenBalance = fundsTokenBalance;\n\n        fundsTokenBalance = fundsToken.balanceOf(address(this));\n\n        return int256(fundsTokenBalance).sub(int256(_prevFundsTokenBalance));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/StakeLockerFactory.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract StakeLockerFactoryTest is TestUtil {\n\n    function setUp() public {\n        setUpGlobals();\n        createStakeLockerFactory();\n    }\n\n    function test_newLocker() public {\n        StakeLocker sl = StakeLocker(slFactory.newLocker(address(mpl), USDC));\n\n        // Validate the storage of slfactory.\n        assertEq(slFactory.owner(address(sl)), address(this));\n        assertTrue(slFactory.isLocker(address(sl)));\n\n        // Validate the storage of sl.\n        assertEq(address(sl.stakeAsset()), address(mpl),     \"Incorrect stake asset address\");\n        assertEq(sl.liquidityAsset(),      USDC,             \"Incorrect address of loan asset\");\n        assertEq(sl.pool(),                address(this),    \"Incorrect pool address\");\n    }\n}\n"
    },
    "packages/protocol/contracts/test/StakeLockerCustodial.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\nimport \"./user/Custodian.sol\";\n\ncontract StakeLockerCustodialTest is TestUtil {\n\n    using SafeMath for uint256;\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpActors();\n        createBalancerPool();\n        transferBptsToPoolDelegateAndStakers();\n        setUpLiquidityPool();\n    }\n\n    function test_custody_and_transfer(uint256 stakeAmt, uint256 custodyAmt1, uint256 custodyAmt2) public {\n        Custodian custodian1 = new Custodian();  // Custodial contract for StakeLockerFDTs - will start out as liquidity mining but could be broader DeFi eventually\n        Custodian custodian2 = new Custodian();  // Custodial contract for StakeLockerFDTs - will start out as liquidity mining but could be broader DeFi eventually\n\n        stakeAmt    = constrictToRange(stakeAmt,    100, bPool.balanceOf(address(sam)), true);  // 100 wei - whole BPT bal (Sid and Sam have the same BPT balance)\n        custodyAmt1 = constrictToRange(custodyAmt1,  40, stakeAmt / 2,                  true);  //  40 wei - half of stake\n        custodyAmt2 = constrictToRange(custodyAmt2,  40, stakeAmt / 2,                  true);  //  40 wei - half of stake\n\n        // Make StakeLocker public and stake tokens\n        pat.openStakeLockerToPublic(address(stakeLocker));\n        sam.approve(address(bPool), address(stakeLocker), stakeAmt);\n        sid.approve(address(bPool), address(stakeLocker), stakeAmt);\n        sam.stake(address(stakeLocker),                   stakeAmt);\n        sid.stake(address(stakeLocker),                   stakeAmt);\n\n        pat.setStakeLockerLockupPeriod(address(stakeLocker), 0);\n\n        // Testing failure modes with Sam\n        assertTrue(!sam.try_increaseCustodyAllowance(address(stakeLocker), address(0),              stakeAmt));  // P:INVALID_ADDRESS\n        assertTrue(!sam.try_increaseCustodyAllowance(address(stakeLocker), address(custodian1),            0));  // P:INVALID_AMT\n        assertTrue(!sam.try_increaseCustodyAllowance(address(stakeLocker), address(custodian1), stakeAmt + 1));  // P:INSUF_BALANCE\n        assertTrue( sam.try_increaseCustodyAllowance(address(stakeLocker), address(custodian1),     stakeAmt));  // Sam can custody entire balance\n\n        // Testing state transition and transfers with Sid\n        assertEq(stakeLocker.custodyAllowance(address(sid), address(custodian1)), 0);\n        assertEq(stakeLocker.totalCustodyAllowance(address(sid)),                 0);\n\n        sid.increaseCustodyAllowance(address(stakeLocker), address(custodian1), custodyAmt1);\n\n        assertEq(stakeLocker.custodyAllowance(address(sid), address(custodian1)), custodyAmt1);  // Sid gives custody to custodian 1\n        assertEq(stakeLocker.totalCustodyAllowance(address(sid)),                 custodyAmt1);  // Total custody allowance goes up\n\n        sid.increaseCustodyAllowance(address(stakeLocker), address(custodian2), custodyAmt2);\n\n        assertEq(stakeLocker.custodyAllowance(address(sid), address(custodian2)),               custodyAmt2);  // Sid gives custody to custodian 2\n        assertEq(stakeLocker.totalCustodyAllowance(address(sid)),                 custodyAmt1 + custodyAmt2);  // Total custody allowance goes up\n\n        uint256 transferableAmt = stakeAmt - custodyAmt1 - custodyAmt2;\n\n        assertEq(stakeLocker.balanceOf(address(sid)), stakeAmt);\n        assertEq(stakeLocker.balanceOf(address(sue)),        0);\n\n        assertTrue(!sid.try_transfer(address(stakeLocker), address(sue), transferableAmt + 1));  // Sid cannot transfer more than balance - totalCustodyAllowance\n        assertTrue( sid.try_transfer(address(stakeLocker), address(sue),     transferableAmt));  // Sid can transfer transferableAmt\n\n        assertEq(stakeLocker.balanceOf(address(sid)), stakeAmt - transferableAmt);\n        assertEq(stakeLocker.balanceOf(address(sue)), transferableAmt);\n    }\n\n    function test_custody_and_unstake(uint256 stakeAmt, uint256 custodyAmt) public {\n        Custodian custodian = new Custodian();\n\n        uint256 startingBptBal = bPool.balanceOf(address(sam));\n\n        stakeAmt   = constrictToRange(stakeAmt,   1, startingBptBal, true);  // 1 wei - whole BPT bal\n        custodyAmt = constrictToRange(custodyAmt, 1, stakeAmt,       true);  // 1 wei - stakeAmt\n\n        // Make StakeLocker public and stake tokens\n        pat.openStakeLockerToPublic(address(stakeLocker));\n        sam.approve(address(bPool), address(stakeLocker), stakeAmt);\n        sam.stake(address(stakeLocker),                   stakeAmt);\n\n        pat.setStakeLockerLockupPeriod(address(stakeLocker), 0);\n\n        assertEq(stakeLocker.custodyAllowance(address(sam), address(custodian)), 0);\n        assertEq(stakeLocker.totalCustodyAllowance(address(sam)),                0);\n\n        sam.increaseCustodyAllowance(address(stakeLocker), address(custodian), custodyAmt);\n\n        assertEq(stakeLocker.custodyAllowance(address(sam), address(custodian)), custodyAmt);\n        assertEq(stakeLocker.totalCustodyAllowance(address(sam)),                custodyAmt);\n\n        uint256 unstakeableAmt = stakeAmt - custodyAmt;\n\n        assertEq(stakeLocker.balanceOf(address(sam)), stakeAmt);\n\n        make_unstakeable(sam, stakeLocker);\n\n        assertTrue(!sam.try_unstake(address(stakeLocker), unstakeableAmt + 1));\n        assertTrue( sam.try_unstake(address(stakeLocker),     unstakeableAmt));\n\n        assertEq(stakeLocker.balanceOf(address(sam)),                  custodyAmt);\n        assertEq(bPool.balanceOf(address(sam)),       startingBptBal - custodyAmt);\n    }\n\n    function test_transferByCustodian(uint256 stakeAmt, uint256 custodyAmt) public {\n        Custodian custodian = new Custodian();  // Custodial contract for PoolFDTs - will start out as liquidity mining but could be broader DeFi eventually\n\n        stakeAmt   = constrictToRange(stakeAmt,   1, bPool.balanceOf(address(sam)), true);  // 1 wei - whole BPT bal\n        custodyAmt = constrictToRange(custodyAmt, 1, stakeAmt,                      true);  // 1 wei - stakeAmt\n\n        // Make StakeLocker public and stake tokens\n        pat.openStakeLockerToPublic(address(stakeLocker));\n        sam.approve(address(bPool), address(stakeLocker), stakeAmt);\n        sam.stake(address(stakeLocker),                   stakeAmt);\n\n        sam.increaseCustodyAllowance(address(stakeLocker), address(custodian), custodyAmt);\n\n        assertEq(stakeLocker.custodyAllowance(address(sam), address(custodian)), custodyAmt);  // Sam gives custody to custodian\n        assertEq(stakeLocker.totalCustodyAllowance(address(sam)),                custodyAmt);  // Total custody allowance goes up\n\n        assertTrue(!custodian.try_transferByCustodian(address(stakeLocker), address(sam), address(sid),     custodyAmt));  // P:INVALID_RECEIVER\n        assertTrue(!custodian.try_transferByCustodian(address(stakeLocker), address(sam), address(sam),              0));  // P:INVALID_AMT\n        assertTrue(!custodian.try_transferByCustodian(address(stakeLocker), address(sam), address(sam), custodyAmt + 1));  // P:INSUF_ALLOWANCE\n        assertTrue( custodian.try_transferByCustodian(address(stakeLocker), address(sam), address(sam),     custodyAmt));  // Able to transfer custody amount back\n\n        assertEq(stakeLocker.custodyAllowance(address(sam), address(custodian)), 0);  // Custodian allowance has been reduced\n        assertEq(stakeLocker.totalCustodyAllowance(address(sam)),                0);  // Total custody allowance has been reduced, giving Sam access to funds again\n    }\n}\n"
    },
    "packages/protocol/contracts/test/user/Custodian.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/IPool.sol\";\n\ncontract Custodian {\n\n    /************************/\n    /*** DIRECT FUNCTIONS ***/\n    /************************/\n\n    function transferByCustodian(address erc2258, address from, address to, uint256 amt) external {\n        IPool(erc2258).transferByCustodian(from, to, amt);\n    }\n\n    /*********************/\n    /*** TRY FUNCTIONS ***/\n    /*********************/\n\n    function try_transferByCustodian(address erc2258, address from, address to, uint256 amt) external returns (bool ok) {\n        string memory sig = \"transferByCustodian(address,address,uint256)\";\n        (ok,) = address(erc2258).call(abi.encodeWithSignature(sig, from, to, amt));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/user/Lender.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/ILoan.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Lender {\n\n    /************************/\n    /*** DIRECT FUNCTIONS ***/\n    /************************/\n\n    function fundLoan(address loan, uint256 amt, address account) external {\n        ILoan(loan).fundLoan(account, amt);\n    }\n\n    function approve(address token, address account, uint256 amt) external {\n        IERC20(token).approve(account, amt);\n    }\n\n    function transfer(address token, address account, uint256 amt) external {\n        IERC20(token).transfer(account, amt);\n    }\n\n    function triggerDefault(address loan) public {\n        ILoan(loan).triggerDefault();\n    }\n\n    function withdrawFunds(address loan) public {\n        ILoan(loan).withdrawFunds();\n    }\n\n\n    /*********************/\n    /*** TRY FUNCTIONS ***/\n    /*********************/\n\n    // To assert failures\n    function try_drawdown(address loan, uint256 amt) external returns (bool ok) {\n        string memory sig = \"drawdown(uint256)\";\n        (ok,) = address(loan).call(abi.encodeWithSignature(sig, amt));\n    }\n\n    function try_fundLoan(address loan, address mintTo, uint256 amt) external returns (bool ok) {\n        string memory sig = \"fundLoan(address,uint256)\";\n        (ok,) = address(loan).call(abi.encodeWithSignature(sig, mintTo, amt));\n    }\n\n    function try_trigger_default(address loan) external returns (bool ok) {\n        string memory sig = \"triggerDefault()\";\n        (ok,) = loan.call(abi.encodeWithSignature(sig));\n    }\n\n    function try_withdrawFunds(address loan) external returns (bool ok) {\n        string memory sig = \"withdrawFunds()\";\n        (ok,) = loan.call(abi.encodeWithSignature(sig));\n    }\n\n    function try_triggerDefault(address loan) external returns (bool ok) {\n        string memory sig = \"triggerDefault()\";\n        (ok,) = address(loan).call(abi.encodeWithSignature(sig));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/PoolCustodial.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\nimport \"./user/Custodian.sol\";\n\ncontract PoolCustodialTest is TestUtil {\n\n    using SafeMath for uint256;\n\n    uint256 principalOut;        // Total outstanding principal of Pool\n    uint256 liquidityLockerBal;  // Total liquidityAsset balance of LiquidityLocker\n    uint256 fdtTotalSupply;      // PoolFDT total supply\n    uint256 interestSum;         // FDT accounting of interest earned\n    uint256 poolLosses;          // FDT accounting of recognizable losses\n\n    TestObj withdrawableFundsOf_fay;  // FDT accounting of interest\n    TestObj withdrawableFundsOf_fez;  // FDT accounting of interest\n    TestObj withdrawableFundsOf_fox;  // FDT accounting of interest\n\n    TestObj mplEarnings_fay;  // MPL earnings from yield farming\n    TestObj mplEarnings_fez;  // MPL earnings from yield farming\n    TestObj mplEarnings_fox;  // MPL earnings from yield farming\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpActors();\n        createBalancerPool(100_000 * USD, 10_000 * USD);\n        transferBptsToPoolDelegates();\n        setUpLiquidityPool();\n        setUpMplRewardsFactory();\n        setUpMplRewards();\n        createFarmers();\n    }\n\n    function updateState() internal {\n        // Update pre state\n        withdrawableFundsOf_fay.pre = withdrawableFundsOf_fay.post;\n        withdrawableFundsOf_fez.pre = withdrawableFundsOf_fez.post;\n        withdrawableFundsOf_fox.pre = withdrawableFundsOf_fox.post;\n\n        mplEarnings_fay.pre = mplEarnings_fay.post;\n        mplEarnings_fez.pre = mplEarnings_fez.post;\n        mplEarnings_fox.pre = mplEarnings_fox.post;\n\n        // Update post state\n        principalOut       = pool.principalOut();\n        liquidityLockerBal = usdc.balanceOf(pool.liquidityLocker());\n        fdtTotalSupply     = pool.totalSupply();\n        interestSum        = pool.interestSum();\n        poolLosses         = pool.poolLosses();\n\n        withdrawableFundsOf_fay.post = pool.withdrawableFundsOf(address(fay));\n        withdrawableFundsOf_fez.post = pool.withdrawableFundsOf(address(fez));\n        withdrawableFundsOf_fox.post = pool.withdrawableFundsOf(address(fox));\n\n        mplEarnings_fay.post = mplRewards.earned(address(fay));\n        mplEarnings_fez.post = mplRewards.earned(address(fez));\n        mplEarnings_fox.post = mplRewards.earned(address(fox));\n    }\n\n    function test_interest_plus_farming(uint256 depositAmt1, uint256 depositAmt2, uint256 depositAmt3) public {\n        uint256 start = block.timestamp;\n\n        // Set up fuzzing amounts\n        depositAmt1 = constrictToRange(depositAmt1, 1000 * USD, 10_000_000 * USD, true);\n        depositAmt2 = constrictToRange(depositAmt2, 1000 * USD, 10_000_000 * USD, true);\n        depositAmt3 = constrictToRange(depositAmt3, 1000 * USD, 10_000_000 * USD, true);\n\n        /**********************************************************************/\n        /*** Fay and Fez both deposit into the pool and start yield farming ***/\n        /**********************************************************************/\n        setUpFarming(300_000 * WAD, 180 days);\n\n        mintFundsAndDepositIntoPool(fay, pool, depositAmt1, depositAmt1);\n        stakeIntoFarm(fay, toWad(depositAmt1));\n\n        mintFundsAndDepositIntoPool(fez, pool, depositAmt2, depositAmt2);\n        stakeIntoFarm(fez, toWad(depositAmt2));\n\n        uint256 totalDeposits = depositAmt1 + depositAmt2;\n\n        /**********************/\n        /*** Pre-Loan State ***/\n        /**********************/\n        updateState();\n\n        assertEq(withdrawableFundsOf_fay.post, 0);\n        assertEq(withdrawableFundsOf_fez.post, 0);\n        assertEq(withdrawableFundsOf_fox.post, 0);\n\n        assertEq(mplEarnings_fay.post, 0);\n        assertEq(mplEarnings_fez.post, 0);\n        assertEq(mplEarnings_fox.post, 0);\n\n        /*************************************************************/\n        /*** Create Loan, draw down, make payment, claim from Pool ***/\n        /*************************************************************/\n        {\n            uint256[5] memory specs = [500, 180, 30, totalDeposits, 2000];\n            createLoan(specs);\n            pat.fundLoan(address(pool), address(loan), address(dlFactory), totalDeposits);\n            drawdown(loan, bob, totalDeposits);\n            hevm.warp(loan.nextPaymentDue());  // Will affect yield farming\n            doPartialLoanPayment(loan, bob);\n            pat.claim(address(pool), address(loan), address(dlFactory));\n        }\n\n        // Update variables to reflect change in accounting from last dTime\n        updateState();\n        uint256 dTime = block.timestamp - start;\n\n        uint256 interest          = interestSum;\n        uint256 totalMplDisbursed = mplRewards.rewardRate() * dTime;\n\n        uint256 poolApy = toApy(interest,          totalDeposits, dTime);\n        uint256 mplApy  = toApy(totalMplDisbursed, toWad(totalDeposits), dTime);\n\n        /***********************************/\n        /*** Post One Loan Payment State ***/\n        /***********************************/\n        withinPrecision(withdrawableFundsOf_fay.post, calcPortion(depositAmt1, interestSum, totalDeposits), 6);\n        withinPrecision(withdrawableFundsOf_fez.post, calcPortion(depositAmt2, interestSum, totalDeposits), 6);\n\n        assertEq(withdrawableFundsOf_fox.post, 0);\n\n        withinPrecision(mplEarnings_fay.post, calcPortion(depositAmt1, totalMplDisbursed, totalDeposits), 10);\n        withinPrecision(mplEarnings_fez.post, calcPortion(depositAmt2, totalMplDisbursed, totalDeposits), 10);\n\n        assertEq(mplEarnings_fox.post, 0);\n\n        withinDiff(toApy(withdrawableFundsOf_fay.post, depositAmt1, dTime), poolApy, 1);\n        withinDiff(toApy(withdrawableFundsOf_fez.post, depositAmt2, dTime), poolApy, 1);\n\n        withinDiff(toApy(mplEarnings_fay.post, toWad(depositAmt1), dTime), mplApy, 1);\n        withinDiff(toApy(mplEarnings_fez.post, toWad(depositAmt2), dTime), mplApy, 1);\n\n        /***********************************************************/\n        /*** Fox deposits into the pool and starts yield farming ***/\n        /***********************************************************/\n        mintFundsAndDepositIntoPool(fox, pool, depositAmt3, depositAmt3);\n        stakeIntoFarm(fox, toWad(depositAmt3));\n\n        totalDeposits = totalDeposits + depositAmt3;\n\n        /********************************************/\n        /*** Make second payment, claim from Pool ***/\n        /********************************************/\n        hevm.warp(loan.nextPaymentDue() - 6 hours);  // Will affect yield farming (using a different timestamp just for the sake of yield farming assertions)\n        doPartialLoanPayment(loan, bob);\n        pat.claim(address(pool), address(loan), address(dlFactory));\n\n        // Update variables to reflect change in accounting from last dTime\n        updateState();\n        dTime = block.timestamp - start - dTime;\n\n        totalMplDisbursed = mplRewards.rewardRate() * dTime;\n        interest          = interestSum - interest;\n\n        poolApy = toApy(interest,          totalDeposits, dTime);\n        mplApy  = toApy(totalMplDisbursed, toWad(totalDeposits), dTime);\n\n        /***********************************/\n        /*** Post One Loan Payment State ***/\n        /***********************************/\n        withinPrecision(withdrawableFundsOf_fay.post, withdrawableFundsOf_fay.pre + calcPortion(depositAmt1, interest, totalDeposits), 6);\n        withinPrecision(withdrawableFundsOf_fez.post, withdrawableFundsOf_fez.pre + calcPortion(depositAmt2, interest, totalDeposits), 6);\n        withinPrecision(withdrawableFundsOf_fox.post,                               calcPortion(depositAmt3, interest, totalDeposits), 6);\n\n        withinPrecision(mplEarnings_fay.post, mplEarnings_fay.pre + calcPortion(depositAmt1, totalMplDisbursed, totalDeposits), 10);\n        withinPrecision(mplEarnings_fez.post, mplEarnings_fez.pre + calcPortion(depositAmt2, totalMplDisbursed, totalDeposits), 10);\n        withinPrecision(mplEarnings_fox.post,                       calcPortion(depositAmt3, totalMplDisbursed, totalDeposits), 10);\n\n        withinDiff(toApy(withdrawableFundsOf_fay.post - withdrawableFundsOf_fay.pre, depositAmt1, dTime), poolApy, 1);\n        withinDiff(toApy(withdrawableFundsOf_fez.post - withdrawableFundsOf_fez.pre, depositAmt2, dTime), poolApy, 1);\n        withinDiff(toApy(withdrawableFundsOf_fox.post,                               depositAmt3, dTime), poolApy, 1);\n\n        withinDiff(toApy(mplEarnings_fay.post - mplEarnings_fay.pre, toWad(depositAmt1), dTime), mplApy, 1);\n        withinDiff(toApy(mplEarnings_fez.post - mplEarnings_fez.pre, toWad(depositAmt2), dTime), mplApy, 1);\n        withinDiff(toApy(mplEarnings_fox.post,                       toWad(depositAmt3), dTime), mplApy, 1);\n    }\n\n    function test_custody_and_transfer(uint256 depositAmt, uint256 custodyAmt1, uint256 custodyAmt2) public {\n        Custodian custodian1 = new Custodian();  // Custodial contract for PoolFDTs - will start out as liquidity mining but could be broader DeFi eventually\n        Custodian custodian2 = new Custodian();  // Custodial contract for PoolFDTs - will start out as liquidity mining but could be broader DeFi eventually\n\n        depositAmt  = constrictToRange(depositAmt,  100, 1E9,            true);  // $1 - $1b\n        custodyAmt1 = constrictToRange(custodyAmt1,  40, depositAmt / 2, true);  // $1 - half of deposit\n        custodyAmt2 = constrictToRange(custodyAmt2,  40, depositAmt / 2, true);  // $1 - half of deposit\n\n        mintFundsAndDepositIntoPool(fay, pool, depositAmt * USD, depositAmt * USD);\n        mintFundsAndDepositIntoPool(fez, pool, depositAmt * USD, depositAmt * USD);\n\n        pat.setLockupPeriod(address(pool), 0);\n\n        // Convert all amounts to WAD, USD not needed for the rest of the test\n        depositAmt  *= WAD;\n        custodyAmt1 *= WAD;\n        custodyAmt2 *= WAD;\n\n        // Testing failure modes with Fay\n        assertTrue(!fay.try_increaseCustodyAllowance(address(pool), address(0),              depositAmt));  // P:INVALID_ADDRESS\n        assertTrue(!fay.try_increaseCustodyAllowance(address(pool), address(custodian1),              0));  // P:INVALID_AMT\n        assertTrue(!fay.try_increaseCustodyAllowance(address(pool), address(custodian1), depositAmt + 1));  // P:INSUF_BALANCE\n        assertTrue( fay.try_increaseCustodyAllowance(address(pool), address(custodian1),     depositAmt));  // Fay can custody entire balance\n\n        // Testing state transition and transfers with Fez\n        assertEq(pool.custodyAllowance(address(fez), address(custodian1)), 0);\n        assertEq(pool.totalCustodyAllowance(address(fez)),                 0);\n\n        fez.increaseCustodyAllowance(address(pool), address(custodian1), custodyAmt1);\n\n        assertEq(pool.custodyAllowance(address(fez), address(custodian1)), custodyAmt1);  // Fez gives custody to custodian 1\n        assertEq(pool.totalCustodyAllowance(address(fez)),                 custodyAmt1);  // Total custody allowance goes up\n\n        fez.increaseCustodyAllowance(address(pool), address(custodian2), custodyAmt2);\n\n        assertEq(pool.custodyAllowance(address(fez), address(custodian2)),               custodyAmt2);  // Fez gives custody to custodian 2\n        assertEq(pool.totalCustodyAllowance(address(fez)),                 custodyAmt1 + custodyAmt2);  // Total custody allowance goes up\n\n        uint256 transferableAmt = depositAmt - custodyAmt1 - custodyAmt2;\n\n        assertEq(pool.balanceOf(address(fez)), depositAmt);\n        assertEq(pool.balanceOf(address(fox)),          0);\n\n        assertTrue(!fez.try_transfer(address(pool), address(fox), transferableAmt + 1));  // Fez cannot transfer more than balance - totalCustodyAllowance\n        assertTrue( fez.try_transfer(address(pool), address(fox),     transferableAmt));  // Fez can transfer transferableAmt\n\n        assertEq(pool.balanceOf(address(fez)), depositAmt - transferableAmt);\n        assertEq(pool.balanceOf(address(fox)), transferableAmt);\n    }\n\n    function test_custody_and_withdraw(uint256 depositAmt, uint256 custodyAmt) public {\n        Custodian custodian = new Custodian();\n\n        depositAmt = constrictToRange(depositAmt, 1, 1E9,        true);  // $1 - $1b\n        custodyAmt = constrictToRange(custodyAmt, 1, depositAmt, true);  // $1 - deposit\n\n        mintFundsAndDepositIntoPool(fez, pool, depositAmt * USD, depositAmt * USD);\n\n        pat.setLockupPeriod(address(pool), 0);\n\n        assertEq(pool.custodyAllowance(address(fez), address(custodian)), 0);\n        assertEq(pool.totalCustodyAllowance(address(fez)),                0);\n\n        fez.increaseCustodyAllowance(address(pool), address(custodian), custodyAmt * WAD);\n\n        assertEq(pool.custodyAllowance(address(fez), address(custodian)), custodyAmt * WAD);\n        assertEq(pool.totalCustodyAllowance(address(fez)),                custodyAmt * WAD);\n\n        uint256 withdrawableAmt = (depositAmt - custodyAmt) * USD;\n\n        assertEq(pool.balanceOf(address(fez)), depositAmt * WAD);\n\n        make_withdrawable(fez, pool);\n\n        assertTrue(!fez.try_withdraw(address(pool), withdrawableAmt + 1));\n        assertTrue( fez.try_withdraw(address(pool),     withdrawableAmt));\n\n        assertEq(pool.balanceOf(address(fez)), custodyAmt * WAD);\n        assertEq(usdc.balanceOf(address(fez)), withdrawableAmt);\n    }\n\n    function test_transferByCustodian(uint256 depositAmt, uint256 custodyAmt) public {\n        Custodian custodian = new Custodian();  // Custodial contract for PoolFDTs - will start out as liquidity mining but could be broader DeFi eventually\n\n        depositAmt  = constrictToRange(depositAmt, 1, 1E9,        true);  // $1 - $1b\n        custodyAmt  = constrictToRange(custodyAmt, 1, depositAmt, true);  // $1 - deposit\n\n        mintFundsAndDepositIntoPool(fay, pool, depositAmt * USD, depositAmt * USD);\n\n        depositAmt  *= WAD;\n        custodyAmt  *= WAD;\n\n        fay.increaseCustodyAllowance(address(pool), address(custodian), custodyAmt);\n\n        assertEq(pool.custodyAllowance(address(fay), address(custodian)), custodyAmt);  // Fay gives custody to custodian\n        assertEq(pool.totalCustodyAllowance(address(fay)),                custodyAmt);  // Total custody allowance goes up\n\n        assertTrue(!custodian.try_transferByCustodian(address(pool), address(fay), address(fox),     custodyAmt));  // P:INVALID_RECEIVER\n        assertTrue(!custodian.try_transferByCustodian(address(pool), address(fay), address(fay),              0));  // P:INVALID_AMT\n        assertTrue(!custodian.try_transferByCustodian(address(pool), address(fay), address(fay), custodyAmt + 1));  // P:INSUF_ALLOWANCE\n        assertTrue( custodian.try_transferByCustodian(address(pool), address(fay), address(fay),     custodyAmt));  // Able to transfer custody amount back\n\n        assertEq(pool.custodyAllowance(address(fay), address(custodian)), 0);  // Custodian allowance has been reduced\n        assertEq(pool.totalCustodyAllowance(address(fay)),                0);  // Total custody allowance has been reduced, giving Fay access to funds again\n    }\n}\n"
    },
    "packages/protocol/contracts/test/StakeLocker.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract Treasury { }\n\ncontract StakeLockerTest is TestUtil {\n\n    using SafeMath for uint256;\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpActors();\n        setUpBalancerPoolForStakers();\n        setUpLiquidityPool();\n        createLoan();\n    }\n\n    function getNewStakeDate(address account, uint256 amt) public returns (uint256 newStakeDate) {\n        // Keeping original test logic different from counterpart code to ensure continued expected behavior (for now)\n        uint256 prevDate = stakeLocker.stakeDate(account);\n        if (prevDate == uint256(0)) {\n            newStakeDate = block.timestamp;\n        } else {\n            uint256 dTime = block.timestamp - prevDate;\n            newStakeDate  = prevDate + (dTime * amt / (stakeLocker.balanceOf(account) + amt));  // stakeDate + (now - stakeDate) * (amt / (balance + amt))\n        }\n    }\n\n    function makePublicAndStake(uint256 stakeAmount) internal {\n        // Make StakeLocker public and stake tokens\n        pat.openStakeLockerToPublic(address(stakeLocker));\n        sam.approve(address(bPool), address(stakeLocker), stakeAmount);\n        sam.stake(address(stakeLocker), stakeAmount);\n    }\n\n    function populateStakeLockerPreState(\n        TestObj memory stakeLockerBal, \n        TestObj memory fdtTotalSupply, \n        TestObj memory stakerBPTBal, \n        TestObj memory stakerFDTBal, \n        TestObj memory stakerStakeDate\n    ) \n        internal \n    {\n        stakeLockerBal.pre  = bPool.balanceOf(address(stakeLocker));\n        fdtTotalSupply.pre  = stakeLocker.totalSupply();\n        stakerBPTBal.pre    = bPool.balanceOf(address(sam));\n        stakerFDTBal.pre    = stakeLocker.balanceOf(address(sam));\n        stakerStakeDate.pre = stakeLocker.stakeDate(address(sam));\n    }\n\n    function populateStakeLockerPostState(\n        TestObj memory stakeLockerBal, \n        TestObj memory fdtTotalSupply, \n        TestObj memory stakerBPTBal, \n        TestObj memory stakerFDTBal, \n        TestObj memory stakerStakeDate\n    ) \n        internal \n    {\n        stakeLockerBal.post  = bPool.balanceOf(address(stakeLocker));\n        fdtTotalSupply.post  = stakeLocker.totalSupply();\n        stakerBPTBal.post    = bPool.balanceOf(address(sam));\n        stakerFDTBal.post    = stakeLocker.balanceOf(address(sam));\n        stakerStakeDate.post = stakeLocker.stakeDate(address(sam));\n    }\n\n    function test_stake_to_measure_effect_on_stake_date(uint256 initialStake, uint256 additionalStake, uint256 transferStake, uint256 warpTime) external {\n        TestObj memory stakeLockerBal;   // StakeLocker total balance of BPTs\n        TestObj memory fdtTotalSupply;   // Total Supply of FDTs\n        TestObj memory stakerBPTBal;     // Staker Balancer Pool BPT balance\n        TestObj memory stakerFDTBal;     // Staker StakeLocker FDT balance\n        TestObj memory stakerStakeDate;  // Staker stakeDate\n\n        uint256 bptMin = WAD / 10_000_000;\n        initialStake    = constrictToRange(initialStake, bptMin, (bPool.balanceOf(address(sam)) / 2) - 1, true);  // 12.5 WAD max, 1/10m WAD min, or zero (min is roughly equal to 10 cents) (non-zero)\n        additionalStake = constrictToRange(additionalStake, bptMin, (bPool.balanceOf(address(sam)) / 2) - 1, true);  // 12.5 WAD max, 1/10m WAD min, or zero (min is roughly equal to 10 cents) (non-zero)\n        transferStake   = constrictToRange(transferStake, bptMin, bPool.balanceOf(address(sid)), true);\n        warpTime        = constrictToRange(warpTime, 1 days, 365 days, true);\n\n        pat.setAllowlist(address(stakeLocker), address(sam), true);\n        pat.setAllowlist(address(stakeLocker), address(sid), true);\n        sam.approve(address(bPool), address(stakeLocker), uint256(-1));\n        sid.approve(address(bPool), address(stakeLocker), uint256(-1));\n        pat.setStakeLockerLockupPeriod(address(stakeLocker), 0);\n\n        uint256 startDate = block.timestamp;\n\n        populateStakeLockerPreState(stakeLockerBal, fdtTotalSupply, stakerBPTBal, stakerFDTBal, stakerStakeDate);\n        sam.stake(address(stakeLocker), initialStake);\n        populateStakeLockerPostState(stakeLockerBal, fdtTotalSupply, stakerBPTBal, stakerFDTBal, stakerStakeDate);\n\n        assertEq(stakeLockerBal.post, stakeLockerBal.pre + initialStake, \"stakeLockerBal  = previous + initialStake\");\n        assertEq(fdtTotalSupply.post, fdtTotalSupply.pre + initialStake, \"fdtTotalSupply  = previous + initialStake\");\n        assertEq(stakerBPTBal.post, stakerBPTBal.pre - initialStake,     \"stakerBPTBal    = previous - initialStake\");\n        assertEq(stakerFDTBal.post, stakerFDTBal.pre + initialStake,     \"stakerFDTBal    = previous + initialStake\");\n        assertEq(stakerStakeDate.post, startDate,                        \"stakerStakeDate = current block timestamp\");\n\n        // Warp into the future and stake again\n        hevm.warp(startDate + warpTime);\n        uint256 newStakeDate = getNewStakeDate(address(sam), additionalStake);\n\n        populateStakeLockerPreState(stakeLockerBal, fdtTotalSupply, stakerBPTBal, stakerFDTBal, stakerStakeDate);\n        sam.stake(address(stakeLocker), additionalStake);\n        populateStakeLockerPostState(stakeLockerBal, fdtTotalSupply, stakerBPTBal, stakerFDTBal, stakerStakeDate);\n\n        assertEq(stakeLockerBal.post, stakeLockerBal.pre + additionalStake, \"stakeLockerBal  = previous + additionalStake\");\n        assertEq(fdtTotalSupply.post, fdtTotalSupply.pre + additionalStake, \"fdtTotalSupply  = previous + additionalStake\");\n        assertEq(stakerBPTBal.post, stakerBPTBal.pre - additionalStake,     \"stakerBPTBal    = previous - additionalStake\");\n        assertEq(stakerFDTBal.post, stakerFDTBal.pre + additionalStake,     \"stakerFDTBal    = previous + additionalStake\");\n        assertEq(stakerStakeDate.post, newStakeDate,                        \"stakerStakeDate = expected newStakeDate\");\n\n        // Warp into the future and receive an FDT transfer\n        hevm.warp(startDate + warpTime);\n        newStakeDate = getNewStakeDate(address(sam), transferStake);\n\n        populateStakeLockerPreState(stakeLockerBal, fdtTotalSupply, stakerBPTBal, stakerFDTBal, stakerStakeDate);\n        sid.stake(address(stakeLocker), transferStake);\n        sid.transfer(address(stakeLocker), address(sam), transferStake);\n        populateStakeLockerPostState(stakeLockerBal, fdtTotalSupply, stakerBPTBal, stakerFDTBal, stakerStakeDate);\n\n        assertEq(stakeLockerBal.post, stakeLockerBal.pre + transferStake, \"stakeLockerBal  = previous + transferStake\");\n        assertEq(fdtTotalSupply.post, fdtTotalSupply.pre + transferStake, \"fdtTotalSupply  = previous + transferStake\");\n        assertEq(stakerBPTBal.post, stakerBPTBal.pre,                     \"stakerBPTBal    = previous\");\n        assertEq(stakerFDTBal.post, stakerFDTBal.pre + transferStake,     \"stakerFDTBal    = previous + transferStake\");\n        assertEq(stakerStakeDate.post, newStakeDate,                      \"stakerStakeDate = expected newStakeDate\");\n    }\n\n    function test_stake_paused() public {\n        pat.setAllowlist(address(stakeLocker), address(sam), true);\n        sam.approve(address(bPool), address(stakeLocker), 20 * WAD);\n\n        // Pause StakeLocker and attempt stake()\n        assertTrue( pat.try_pause(address(stakeLocker)));\n        assertTrue(!sam.try_stake(address(stakeLocker), 10 * WAD));\n        assertEq(stakeLocker.balanceOf(address(sam)),    0 * WAD);\n\n        // Unpause StakeLocker and stake()\n        assertTrue(pat.try_unpause(address(stakeLocker)));\n        assertTrue(sam.try_stake(address(stakeLocker), 10 * WAD));\n        assertEq(stakeLocker.balanceOf(address(sam)),  10 * WAD);\n\n        // Pause protocol and attempt to stake()\n        assertTrue( emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!sam.try_stake(address(stakeLocker), 10 * WAD));\n        assertEq(stakeLocker.balanceOf(address(sam)),   10 * WAD);\n\n        // Unpause protocol and stake()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(sam.try_stake(address(stakeLocker), 10 * WAD));\n        assertEq(stakeLocker.balanceOf(address(sam)),  20 * WAD);\n    }\n\n    function test_stake() public {\n        uint256 startDate = block.timestamp;\n\n        assertTrue(!sam.try_stake(address(stakeLocker),   25 * WAD));  // Hasn't approved BPTs\n        sam.approve(address(bPool), address(stakeLocker), 25 * WAD);\n\n        assertTrue(!sam.try_stake(address(stakeLocker),   25 * WAD));  // Isn't yet allowlisted\n\n        pat.setAllowlist(address(stakeLocker), address(sam), true);\n\n        // Check whether PD is allowed to transferFrom or not.\n        assertEq(stakeLocker.balanceOf(address(pat)), 50 * WAD);\n        pat.approve(address(stakeLocker), address(sam), 50 * WAD);\n        assertTrue(!sam.try_transferFrom(address(stakeLocker), address(pat), address(sam), 50 * WAD));\n\n        assertEq(bPool.balanceOf(address(sam)),         25 * WAD);\n        assertEq(bPool.balanceOf(address(stakeLocker)), 50 * WAD);  // PD stake\n        assertEq(stakeLocker.totalSupply(),             50 * WAD);\n        assertEq(stakeLocker.balanceOf(address(sam)),          0);\n        assertEq(stakeLocker.stakeDate(address(sam)),          0);\n\n        assertTrue(sam.try_stake(address(stakeLocker), 25 * WAD));\n\n        assertEq(bPool.balanceOf(address(sam)),                 0);\n        assertEq(bPool.balanceOf(address(stakeLocker)),  75 * WAD);  // PD + Staker stake\n        assertEq(stakeLocker.totalSupply(),              75 * WAD);\n        assertEq(stakeLocker.balanceOf(address(sam)),    25 * WAD);\n        assertEq(stakeLocker.stakeDate(address(sam)),   startDate);\n\n        sid.approve(address(bPool), address(stakeLocker), 25 * WAD);\n\n        assertTrue(!sid.try_stake(address(stakeLocker), 25 * WAD)); // Isn't allowlisted\n\n        // Open StakeLocker to public\n        assertTrue(!stakeLocker.openToPublic());\n        assertTrue(!pam.try_openStakeLockerToPublic(address(stakeLocker)));\n        assertTrue( pat.try_openStakeLockerToPublic(address(stakeLocker)));\n        assertTrue( stakeLocker.openToPublic());\n        assertTrue(!stakeLocker.allowed(address(sid)));  // Sid is not an allowed Staker, but StakeLocker is now open to public\n\n        assertEq(bPool.balanceOf(address(sid)),         25 * WAD);\n        assertEq(bPool.balanceOf(address(stakeLocker)), 75 * WAD);  // PD stake\n        assertEq(stakeLocker.totalSupply(),             75 * WAD);\n        assertEq(stakeLocker.balanceOf(address(sid)),          0);\n        assertEq(stakeLocker.stakeDate(address(sid)),          0);\n\n        assertTrue(sid.try_stake(address(stakeLocker), 25 * WAD));\n\n        assertEq(bPool.balanceOf(address(sid)),                 0);\n        assertEq(bPool.balanceOf(address(stakeLocker)), 100 * WAD);  // PD + Staker stake\n        assertEq(stakeLocker.totalSupply(),             100 * WAD);\n        assertEq(stakeLocker.balanceOf(address(sid)),    25 * WAD);\n        assertEq(stakeLocker.stakeDate(address(sid)),   startDate);\n    }\n\n    function test_withdrawFunds_paused() public {\n        // Make StakeLocker public and stake tokens\n        pat.openStakeLockerToPublic(address(stakeLocker));\n        sam.approve(address(bPool), address(stakeLocker), 25 * WAD);\n        sam.stake(address(stakeLocker), 25 * WAD);\n\n        // Pause protocol and attempt withdrawFunds()\n        assertTrue( emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!sam.try_withdrawFunds(address(stakeLocker)));\n\n        // Unpause protocol and withdrawFunds()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(sam.try_withdrawFunds(address(stakeLocker)));\n    }\n\n    function test_unstake_cooldown() public {\n        makePublicAndStake(15 * WAD);\n\n        hevm.warp(block.timestamp + stakeLocker.lockupPeriod());  // Warp to end of lockup for test\n\n        gov.setStakerCooldownPeriod(10 days);\n\n        uint256 amt = 5 * WAD; // 1/3 of stake so unstake can happen thrice\n\n        uint256 start = block.timestamp;\n\n        assertTrue(!sam.try_unstake(address(stakeLocker), amt),    \"Should fail to unstake 10 WAD because account has to intendToWithdraw\");\n        assertTrue( sam.try_intendToUnstake(address(stakeLocker)), \"Failed to intend to unstake\");\n        assertEq(stakeLocker.unstakeCooldown(address(sam)), start);\n        assertTrue(!sam.try_unstake(address(stakeLocker), amt),    \"Should fail to unstake before cooldown period has passed\");\n\n        // Just before cooldown ends\n        hevm.warp(start + globals.stakerCooldownPeriod() - 1);\n        assertTrue(!sam.try_unstake(address(stakeLocker), amt), \"Should fail to unstake before cooldown period has passed\");\n\n        // Right when cooldown ends\n        hevm.warp(start + globals.stakerCooldownPeriod());\n        assertTrue(sam.try_unstake(address(stakeLocker), amt), \"Should be able to unstake during unstake window\");\n\n        // Still within Staker unstake window\n        hevm.warp(start + globals.stakerCooldownPeriod() + 1);\n        assertTrue(sam.try_unstake(address(stakeLocker), amt), \"Should be able to unstake funds again during cooldown window\");\n\n        // Second after Staker unstake window ends\n        hevm.warp(start + globals.stakerCooldownPeriod() + globals.stakerUnstakeWindow() + 1);\n        assertTrue(!sam.try_unstake(address(stakeLocker), amt), \"Should fail to unstake funds because now past unstake window\");\n\n        uint256 newStart = block.timestamp;\n\n        // Intend to unstake\n        assertTrue(sam.try_intendToUnstake(address(stakeLocker)), \"Failed to intend to unstake\");\n\n        // After cooldown ends but after unstake window\n        hevm.warp(newStart + globals.stakerCooldownPeriod() + globals.stakerUnstakeWindow() + 1);\n        assertTrue(!sam.try_unstake(address(stakeLocker), amt), \"Should fail to unstake after unstake window has passed\");\n\n        // Last second of Staker unstake window\n        hevm.warp(newStart + globals.stakerCooldownPeriod() + globals.stakerUnstakeWindow());\n        assertTrue(sam.try_unstake(address(stakeLocker), amt), \"Should be able to unstake during unstake window\");\n    }\n\n    function test_stake_transfer_paused() public {\n        makePublicAndStake(25 * WAD);\n        pat.setStakeLockerLockupPeriod(address(stakeLocker), 0);\n\n        // Pause protocol and attempt to transfer FDTs\n        assertTrue( emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!sam.try_transfer(address(stakeLocker), address(leo), 1 * WAD));\n\n        // Unpause protocol and transfer FDTs\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(sam.try_transfer(address(stakeLocker), address(leo), 1 * WAD));\n    }\n\n    function test_stake_transfer_lockup_period(uint256 stakeAmount) public {\n        uint256 startDate = block.timestamp;\n        stakeAmount = constrictToRange(stakeAmount, 1 wei, bPool.balanceOf(address(sam)), true);\n\n        makePublicAndStake(stakeAmount);\n\n        // Will fail because lockup period hasn't passed yet\n        assertTrue(!sam.try_transfer(address(stakeLocker), address(sid), stakeAmount));\n\n        // Warp to just before lockup period ends\n        hevm.warp(startDate + pool.lockupPeriod() - 1);\n        assertTrue(!sam.try_transfer(address(stakeLocker), address(sid), stakeAmount));\n\n        // Warp to after lockup period and transfer\n        hevm.warp(startDate + stakeLocker.lockupPeriod());\n        uint256 newStakeDate = getNewStakeDate(address(sid), stakeAmount);\n        assertTrue(sam.try_transfer(address(stakeLocker), address(sid), stakeAmount));\n\n        // Check balances and deposit dates are correct\n        assertEq(stakeLocker.balanceOf(address(sam)), 0);\n        assertEq(stakeLocker.balanceOf(address(sid)), stakeAmount);\n        assertEq(stakeLocker.stakeDate(address(sam)), startDate);     // Stays the same\n        assertEq(stakeLocker.stakeDate(address(sid)), newStakeDate);  // Gets updated\n    }\n\n    function test_stake_transfer_recipient_withdrawing() public {\n        uint256 start = block.timestamp;\n        uint256 stakeAmount = 25 * WAD;\n\n        makePublicAndStake(stakeAmount);\n        pat.setStakeLockerLockupPeriod(address(stakeLocker), 0);\n\n        sid.approve(address(bPool), address(stakeLocker), stakeAmount);\n        sid.stake(address(stakeLocker), stakeAmount);\n\n        // Staker 1 initiates unstake\n        assertTrue(sid.try_intendToUnstake(address(stakeLocker)));\n        assertEq(stakeLocker.unstakeCooldown(address(sid)), start);\n\n        // Staker 2 fails to transfer to Staker 1 that is currently unstaking\n        assertTrue(!sam.try_transfer(address(stakeLocker), address(sid), stakeAmount));\n        hevm.warp(start + globals.stakerCooldownPeriod() + globals.stakerUnstakeWindow());  // Very end of Staker unstake window\n        assertTrue(!sam.try_transfer(address(stakeLocker), address(sid), stakeAmount));\n\n        // Staker 2 successfully transfers to Staker 1 that is now outside unstake window\n        hevm.warp(start + globals.stakerCooldownPeriod() + globals.stakerUnstakeWindow() + 1);  // Second after Staker unstake window ends\n        uint256 newStakeDate = getNewStakeDate(address(sid), stakeAmount);\n        assertTrue(sam.try_transfer(address(stakeLocker), address(sid), stakeAmount));\n\n        // Check balances and stake dates are correct\n        assertEq(stakeLocker.balanceOf(address(sam)), 0);\n        assertEq(stakeLocker.balanceOf(address(sid)), stakeAmount * 2);\n        assertEq(stakeLocker.stakeDate(address(sam)), start);         // Stays the same\n        assertEq(stakeLocker.stakeDate(address(sid)), newStakeDate);  // Gets updated\n    }\n\n    function setUpLoanAndRepay() public {\n        mint(\"USDC\", address(leo), 10_000_000 * USD);  // Mint USDC to LP\n        leo.approve(USDC, address(pool), MAX_UINT);    // LP approves USDC\n\n        leo.deposit(address(pool), 10_000_000 * USD);                                      // LP deposits 10m USDC to Pool\n        pat.fundLoan(address(pool), address(loan), address(dlFactory), 10_000_000 * USD);  // PD funds loan for 10m USDC\n\n        uint256 cReq = loan.collateralRequiredForDrawdown(10_000_000 * USD);  // WETH required for 100_000_000 USDC drawdown on loan\n        mint(\"WETH\", address(bob), cReq);                                  // Mint WETH to borrower\n        bob.approve(WETH, address(loan), MAX_UINT);                        // Borrower approves WETH\n        bob.drawdown(address(loan), 10_000_000 * USD);                     // Borrower draws down 10m USDC\n\n        mint(\"USDC\", address(bob), 10_000_000 * USD);  // Mint USDC to Borrower for repayment plus interest\n        bob.approve(USDC, address(loan), MAX_UINT);    // Borrower approves USDC\n        bob.makeFullPayment(address(loan));            // Borrower makes full payment, which includes interest\n\n        pat.claim(address(pool), address(loan),  address(dlFactory));  // PD claims interest, distributing funds to stakeLocker\n    }\n\n    function test_unstake(uint256 stakeAmount) public {\n        uint256 bptMin = WAD / 10_000_000;\n        stakeAmount = constrictToRange(stakeAmount, bptMin, bPool.balanceOf(address(sam)), true);  // 25 WAD max, 1/10m WAD min, or zero (min is roughly equal to 10 cents) (non-zero)\n\n        uint256 stakeDate = block.timestamp;\n\n        makePublicAndStake(stakeAmount);\n\n        assertEq(IERC20(USDC).balanceOf(address(sam)),                         0);\n        assertEq(bPool.balanceOf(address(sam)),         (25 * WAD) - stakeAmount);\n        assertEq(bPool.balanceOf(address(stakeLocker)), (50 * WAD) + stakeAmount);  // PD + Staker stake\n        assertEq(stakeLocker.totalSupply(),             (50 * WAD) + stakeAmount);\n        assertEq(stakeLocker.balanceOf(address(sam)),                stakeAmount);\n        assertEq(stakeLocker.stakeDate(address(sam)),                  stakeDate);\n\n        setUpLoanAndRepay();\n        assertTrue(!sue.try_intendToUnstake(address(stakeLocker)));  // Unstake will not work as sue doesn't possess any balance.\n        assertTrue( sam.try_intendToUnstake(address(stakeLocker)));\n\n        hevm.warp(stakeDate + globals.stakerCooldownPeriod() - 1);\n        assertTrue(!sam.try_unstake(address(stakeLocker), stakeAmount));  // Staker cannot unstake BPTs until stakerCooldownPeriod has passed\n\n        hevm.warp(stakeDate + globals.stakerCooldownPeriod());\n        assertTrue(!sam.try_unstake(address(stakeLocker), stakeAmount));  // Still cannot unstake because of lockup period\n\n        hevm.warp(stakeDate + stakeLocker.lockupPeriod() - globals.stakerCooldownPeriod());  // Warp to first time that account can cooldown and unstake and will be after lockup\n        uint256 cooldownTimestamp = block.timestamp;\n        assertTrue(sam.try_intendToUnstake(address(stakeLocker)));\n\n        hevm.warp(cooldownTimestamp + globals.stakerCooldownPeriod() - 1);\n        assertTrue(!sam.try_unstake(address(stakeLocker), stakeAmount));  // Staker cannot unstake BPTs until stakerCooldownPeriod has passed\n\n        hevm.warp(cooldownTimestamp + globals.stakerCooldownPeriod());  // Now account is able to unstake\n\n        uint256 totalStakerEarnings    = IERC20(USDC).balanceOf(address(stakeLocker));\n        uint256 samStakerEarnings_FDT  = stakeLocker.withdrawableFundsOf(address(sam));\n        uint256 samStakerEarnings_calc = totalStakerEarnings * (stakeAmount) / ((50 * WAD) + stakeAmount);  // Staker's portion of staker earnings\n\n        assertTrue(sam.try_unstake(address(stakeLocker), stakeAmount));  // Staker unstakes all BPTs\n\n        withinPrecision(samStakerEarnings_FDT, samStakerEarnings_calc, 9);\n\n        assertEq(IERC20(USDC).balanceOf(address(sam)),                               samStakerEarnings_FDT);  // Staker got portion of interest\n        assertEq(IERC20(USDC).balanceOf(address(stakeLocker)), totalStakerEarnings - samStakerEarnings_FDT);  // Interest was transferred out of SL\n\n        assertEq(bPool.balanceOf(address(sam)),          25 * WAD);  // Staker's unstaked BPTs\n        assertEq(bPool.balanceOf(address(stakeLocker)),  50 * WAD);  // PD + Staker stake\n        assertEq(stakeLocker.totalSupply(),              50 * WAD);  // Total supply of staked tokens has decreased\n        assertEq(stakeLocker.balanceOf(address(sam)),           0);  // Staker has no staked tokens after unstake\n        assertEq(stakeLocker.stakeDate(address(sam)),   stakeDate);  // StakeDate remains unchanged (doesn't matter since balanceOf == 0 on next stake)\n    }\n\n    function test_unstake_paused() public {\n        makePublicAndStake(10 * WAD);\n        hevm.warp(block.timestamp + stakeLocker.lockupPeriod());  // Warp to the end of the lockup\n        sam.intendToUnstake(address(stakeLocker));\n        hevm.warp(block.timestamp + globals.stakerCooldownPeriod());  // Warp to the end of the unstake cooldown\n\n        // Pause protocol and attempt to unstake()\n        assertTrue( emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!sam.try_unstake(address(stakeLocker), 10 * WAD));\n        assertEq(stakeLocker.balanceOf(address(sam)),     10 * WAD);\n\n        // Unpause protocol and unstake()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(sam.try_unstake(address(stakeLocker), 10 * WAD));\n        assertEq(stakeLocker.balanceOf(address(sam)),     0 * WAD);\n    }\n\n    function test_staker_fdt_accounting(uint256 stakeAmount) public {\n        TestObj memory stakeLockerBal;        // StakeLocker total balance of BPTs\n        TestObj memory fdtTotalSupply;        // Total Supply of FDTs\n        TestObj memory stakerFDTBal;          // Staker FDT balance\n        TestObj memory fundsTokenBal;         // FDT accounting of interest earned\n        TestObj memory withdrawableFundsOf;   // Interest earned by Staker\n        TestObj memory bptLosses;             // FDT accounting of losses from burning\n        TestObj memory recognizableLossesOf;  // Recognizable losses of Staker\n\n        uint256 bptMin = WAD / 10_000_000;\n\n        stakeAmount = constrictToRange(stakeAmount,  bptMin, bPool.balanceOf(address(sam)), true);  // 25 WAD max, 1/10m WAD min, or zero (min is roughly equal to 10 cents) (non-zero)\n\n        pat.setAllowlist(address(stakeLocker), address(sam), true);\n        pat.setAllowlist(address(stakeLocker), address(sid), true);\n        pat.setAllowlist(address(stakeLocker), address(sue), true);\n\n        sam.approve(address(bPool), address(stakeLocker), MAX_UINT);\n        sid.approve(address(bPool), address(stakeLocker), MAX_UINT);\n        sue.approve(address(bPool), address(stakeLocker), MAX_UINT);\n\n        sam.stake(address(stakeLocker), stakeAmount);  // Sam stakes before default, unstakes min amount\n        sid.stake(address(stakeLocker), 25 * WAD);     // Sid stakes before default, unstakes full amount\n\n        uint256 interestPaid = setUpLoanMakeOnePaymentAndDefault();  // This does not affect any Pool accounting\n\n        /*****************************************************/\n        /*** Make Claim, Update StakeLocker FDT Accounting ***/\n        /*****************************************************/\n\n        // Pre-claim FDT and StakeLocker checks (Sam only)\n        stakeLockerBal.pre       = bPool.balanceOf(address(stakeLocker));\n        fdtTotalSupply.pre       = stakeLocker.totalSupply();\n        stakerFDTBal.pre         = stakeLocker.balanceOf(address(sam));\n        fundsTokenBal.pre        = IERC20(USDC).balanceOf(address(stakeLocker));\n        withdrawableFundsOf.pre  = stakeLocker.withdrawableFundsOf(address(sam));\n        bptLosses.pre            = stakeLocker.bptLosses();\n        recognizableLossesOf.pre = stakeLocker.recognizableLossesOf(address(sam));\n\n        assertEq(stakeLockerBal.pre,      stakeAmount + 75 * WAD);  // PD + Sam + Sid stake\n        assertEq(fdtTotalSupply.pre,      stakeAmount + 75 * WAD);  // FDT Supply == amount staked\n        assertEq(stakerFDTBal.pre,                   stakeAmount);  // Sam FDT balance == amount staked\n        assertEq(fundsTokenBal.pre,                            0);  // Claim hasn't been made yet - interest not realized\n        assertEq(withdrawableFundsOf.pre,                      0);  // Claim hasn't been made yet - interest not realized\n        assertEq(bptLosses.pre,                                0);  // Claim hasn't been made yet - losses   not realized\n        assertEq(recognizableLossesOf.pre,                     0);  // Claim hasn't been made yet - losses   not realized\n\n        pat.claim(address(pool), address(loan),  address(dlFactory));  // Pool Delegate claims funds, updating accounting for interest and losses from Loan\n\n        // Post-claim FDT and StakeLocker checks (Sam only)\n        stakeLockerBal.post       = bPool.balanceOf(address(stakeLocker));\n        fdtTotalSupply.post       = stakeLocker.totalSupply();\n        stakerFDTBal.post         = stakeLocker.balanceOf(address(sam));\n        fundsTokenBal.post        = IERC20(USDC).balanceOf(address(stakeLocker));\n        withdrawableFundsOf.post  = stakeLocker.withdrawableFundsOf(address(sam));\n        bptLosses.post            = stakeLocker.bptLosses();\n        recognizableLossesOf.post = stakeLocker.recognizableLossesOf(address(sam));\n\n        uint256 stakingRevenue = interestPaid * pool.stakingFee() / 10_000;  // Portion of interest that goes to the StakeLocker\n\n        assertTrue(stakeLockerBal.post < stakeLockerBal.pre);  // BPTs were burned to cover losses\n\n        assertEq(fdtTotalSupply.post,                                   stakeAmount + 75 * WAD);  // FDT Supply == total amount staked\n        assertEq(stakerFDTBal.post,                                                stakeAmount);  // Sam FDT balance == amount staked\n        assertEq(fundsTokenBal.post,                                            stakingRevenue);  // Interest claimed\n        assertEq(withdrawableFundsOf.post,  stakingRevenue * stakeAmount / fdtTotalSupply.post);  // Sam claim on interest\n        assertEq(bptLosses.post,                      stakeLockerBal.pre - stakeLockerBal.post);  // Losses registered in StakeLocker\n        assertEq(recognizableLossesOf.post, bptLosses.post * stakeAmount / fdtTotalSupply.post);  // Sam's recognizable losses\n\n        /**************************************************************/\n        /*** Staker Post-Loss Minimum Unstake Accounting (Sam Only) ***/\n        /**************************************************************/\n\n        // Pre-unstake FDT and StakeLocker checks (update variables)\n        stakeLockerBal.pre       = stakeLockerBal.post;\n        fdtTotalSupply.pre       = fdtTotalSupply.post;\n        stakerFDTBal.pre         = stakerFDTBal.post;\n        fundsTokenBal.pre        = fundsTokenBal.post;\n        withdrawableFundsOf.pre  = withdrawableFundsOf.post;\n        bptLosses.pre            = bptLosses.post;\n        recognizableLossesOf.pre = recognizableLossesOf.post;\n\n        assertEq(bPool.balanceOf(address(sam)),        25 * WAD - stakeAmount);  // Starting balance minus staked amount\n        assertEq(IERC20(USDC).balanceOf(address(sam)),                      0);  // USDC balance\n\n        assertEq(withdrawableFundsOf.pre,  fundsTokenBal.pre * stakeAmount / fdtTotalSupply.pre);  // Assert FDT interest accounting\n        assertEq(recognizableLossesOf.pre,     bptLosses.pre * stakeAmount / fdtTotalSupply.pre);  // Assert FDT loss     accounting\n\n        // re-using the variable to avoid stack too deep issue.\n        interestPaid = block.timestamp;\n\n        assertTrue(sam.try_intendToUnstake(address(stakeLocker)));\n        assertEq(stakeLocker.unstakeCooldown(address(sam)), interestPaid);\n        hevm.warp(interestPaid + globals.stakerCooldownPeriod());\n        assertTrue(!sam.try_unstake(address(stakeLocker), recognizableLossesOf.pre - 1));  // Cannot withdraw less than the losses incurred\n        hevm.warp(interestPaid + globals.stakerCooldownPeriod() - 1);\n        assertTrue(!sam.try_unstake(address(stakeLocker), recognizableLossesOf.pre));\n        hevm.warp(interestPaid + globals.stakerCooldownPeriod());\n        assertTrue(sam.try_unstake(address(stakeLocker), recognizableLossesOf.pre));  // Withdraw lowest possible amount (amt == recognizableLosses), FDTs burned to cover losses, no BPTs left to withdraw\n\n        stakeLockerBal.post       = bPool.balanceOf(address(stakeLocker));\n        fdtTotalSupply.post       = stakeLocker.totalSupply();\n        stakerFDTBal.post         = stakeLocker.balanceOf(address(sam));\n        fundsTokenBal.post        = IERC20(USDC).balanceOf(address(stakeLocker));\n        withdrawableFundsOf.post  = stakeLocker.withdrawableFundsOf(address(sam));\n        bptLosses.post            = stakeLocker.bptLosses();\n        recognizableLossesOf.post = stakeLocker.recognizableLossesOf(address(sam));\n\n        assertEq(stakeLockerBal.post,                  stakeAmount + 75 * WAD - bptLosses.pre);  // Sam + Sid + Sid stake minus burned BPTs\n        assertEq(fdtTotalSupply.post,       stakeAmount + 75 * WAD - recognizableLossesOf.pre);  // FDT Supply == amount staked\n        assertEq(stakerFDTBal.post,                    stakeAmount - recognizableLossesOf.pre);  // Sam FDT balance burned on withdraw\n        assertEq(fundsTokenBal.post,                 stakingRevenue - withdrawableFundsOf.pre);  // Interest has been claimed\n        assertEq(withdrawableFundsOf.post,                                                  0);  // Interest cannot be claimed twice\n        assertEq(bptLosses.post,                     bptLosses.pre - recognizableLossesOf.pre);  // Losses accounting has been updated\n        assertEq(recognizableLossesOf.post,                                                 0);  // Losses have been recognized\n\n        assertEq(bPool.balanceOf(address(sam)),         25 * WAD - stakeAmount);  // Starting balance minus staked amount (same as before unstake, meaning no BPTs were returned to Sam)\n        assertEq(IERC20(USDC).balanceOf(address(sam)), withdrawableFundsOf.pre);  // USDC balance\n\n        /******************************************************/\n        /*** Staker Post-Loss Unstake Accounting (Sid Only) ***/\n        /******************************************************/\n\n        uint256 initialFundsTokenBal = fundsTokenBal.pre;  // Need this for asserting pre-unstake FDT\n        uint256 initialLosses        = bptLosses.pre;      // Need this for asserting pre-unstake FDT\n\n        // Pre-unstake FDT and StakeLocker checks (update variables)\n        stakeLockerBal.pre       = stakeLockerBal.post;\n        fdtTotalSupply.pre       = fdtTotalSupply.post;\n        stakerFDTBal.pre         = stakeLocker.balanceOf(address(sid));\n        fundsTokenBal.pre        = fundsTokenBal.post;\n        withdrawableFundsOf.pre  = stakeLocker.withdrawableFundsOf(address(sid));\n        bptLosses.pre            = bptLosses.post;\n        recognizableLossesOf.pre = stakeLocker.recognizableLossesOf(address(sid));\n\n        assertEq(bPool.balanceOf(address(sid)),        0);  // Staked entire balance\n        assertEq(IERC20(USDC).balanceOf(address(sid)), 0);  // USDC balance\n\n        assertEq(withdrawableFundsOf.pre,  initialFundsTokenBal * 25 * WAD / (75 * WAD + stakeAmount));  // Assert FDT interest accounting (have to use manual totalSupply because of Sam unstake)\n        assertEq(recognizableLossesOf.pre,        initialLosses * 25 * WAD / (75 * WAD + stakeAmount));  // Assert FDT loss     accounting (have to use manual totalSupply because of Sam unstake)\n\n        interestPaid = block.timestamp;\n\n        assertTrue(sid.try_intendToUnstake(address(stakeLocker)));\n        assertEq(stakeLocker.unstakeCooldown(address(sid)), interestPaid);\n        hevm.warp(interestPaid + globals.stakerCooldownPeriod() + 1);\n        assertTrue(!sid.try_unstake(address(stakeLocker), stakerFDTBal.pre + 1));  // Cannot withdraw more than current FDT bal\n        assertTrue( sid.try_unstake(address(stakeLocker), stakerFDTBal.pre));      // Withdraw remaining BPTs\n\n        stakeLockerBal.post       = bPool.balanceOf(address(stakeLocker));\n        fdtTotalSupply.post       = stakeLocker.totalSupply();\n        stakerFDTBal.post         = stakeLocker.balanceOf(address(sid));\n        fundsTokenBal.post        = IERC20(USDC).balanceOf(address(stakeLocker));\n        withdrawableFundsOf.post  = stakeLocker.withdrawableFundsOf(address(sid));\n        bptLosses.post            = stakeLocker.bptLosses();\n        recognizableLossesOf.post = stakeLocker.recognizableLossesOf(address(sid));\n\n        assertEq(stakeLockerBal.post,      stakeLockerBal.pre - (25 * WAD - recognizableLossesOf.pre));  // Sid's unstake amount minus his losses\n        assertEq(fdtTotalSupply.post,                                   fdtTotalSupply.pre - 25 * WAD);  // FDT Supply = previous FDT total supply - unstake amount\n        assertEq(stakerFDTBal.post,                                                                 0);  // Sid's entire FDT balance burned on withdraw\n        assertEq(fundsTokenBal.post,                      fundsTokenBal.pre - withdrawableFundsOf.pre);  // Interest has been claimed\n        assertEq(withdrawableFundsOf.post,                                                          0);  // Interest cannot be claimed twice\n        assertEq(bptLosses.post,                             bptLosses.pre - recognizableLossesOf.pre);  // Losses accounting has been updated\n        assertEq(recognizableLossesOf.post,                                                         0);  // Losses have been recognized\n\n        assertEq(bPool.balanceOf(address(sid)),        25 * WAD - recognizableLossesOf.pre);  // Starting balance minus losses\n        assertEq(IERC20(USDC).balanceOf(address(sid)),             withdrawableFundsOf.pre);  // USDC balance from interest\n\n        /************************************************************/\n        /*** Post-Loss Staker Stake/Unstake Accounting (Sue Only) ***/\n        /************************************************************/\n        // Ensure that Sue has no loss exposure if they stake after a default has already occurred\n        uint256 eliStakeAmount = bPool.balanceOf(address(sid));\n        sid.transfer(address(bPool), address(sue), eliStakeAmount);  // Sid sends Sue a balance of BPTs so they can stake\n\n        sue.stake(address(stakeLocker), eliStakeAmount);\n\n        // Pre-unstake FDT and StakeLocker checks (update variables)\n        stakeLockerBal.pre       = bPool.balanceOf(address(stakeLocker));\n        fdtTotalSupply.pre       = stakeLocker.totalSupply();\n        stakerFDTBal.pre         = stakeLocker.balanceOf(address(sue));\n        fundsTokenBal.pre        = IERC20(USDC).balanceOf(address(stakeLocker));\n        withdrawableFundsOf.pre  = stakeLocker.withdrawableFundsOf(address(sue));\n        bptLosses.pre            = stakeLocker.bptLosses();\n        recognizableLossesOf.pre = stakeLocker.recognizableLossesOf(address(sue));\n\n        assertEq(bPool.balanceOf(address(sue)),        0);  // Staked entire balance\n        assertEq(IERC20(USDC).balanceOf(address(sue)), 0);  // USDC balance\n\n        assertEq(withdrawableFundsOf.pre,  0);  // Assert FDT interest accounting\n        assertEq(recognizableLossesOf.pre, 0);  // Assert FDT loss     accounting\n\n        hevm.warp(block.timestamp + stakeLocker.lockupPeriod());  // Warp to the end of the lockup\n\n        assertTrue(sue.try_intendToUnstake(address(stakeLocker)));\n        hevm.warp(block.timestamp + globals.stakerCooldownPeriod() + 1);\n        sue.unstake(address(stakeLocker), eliStakeAmount);  // Unstake entire balance\n\n        stakeLockerBal.post       = bPool.balanceOf(address(stakeLocker));\n        fdtTotalSupply.post       = stakeLocker.totalSupply();\n        stakerFDTBal.post         = stakeLocker.balanceOf(address(sue));\n        fundsTokenBal.post        = IERC20(USDC).balanceOf(address(stakeLocker));\n        withdrawableFundsOf.post  = stakeLocker.withdrawableFundsOf(address(sue));\n        bptLosses.post            = stakeLocker.bptLosses();\n        recognizableLossesOf.post = stakeLocker.recognizableLossesOf(address(sue));\n\n        assertEq(stakeLockerBal.post,      stakeLockerBal.pre - eliStakeAmount);  // Sue recovered full stake\n        assertEq(fdtTotalSupply.post,      fdtTotalSupply.pre - eliStakeAmount);  // FDT Supply minus Sue's full stake\n        assertEq(stakerFDTBal.post,                                          0);  // Sue FDT balance burned on withdraw\n        assertEq(fundsTokenBal.post,                         fundsTokenBal.pre);  // No interest has been claimed\n        assertEq(withdrawableFundsOf.post,                                   0);  // Interest cannot be claimed twice\n        assertEq(bptLosses.post,                                 bptLosses.pre);  // Losses accounting has not changed\n        assertEq(recognizableLossesOf.post,                                  0);  // Losses have been \"recognized\" (there were none)\n\n        assertEq(bPool.balanceOf(address(sue)),        eliStakeAmount);  // Sue recovered full stake\n        assertEq(IERC20(USDC).balanceOf(address(sue)),              0);  // USDC balance from interest (none)\n    }\n\n    function test_setAllowlist() public {\n        // Pause protocol and attempt setAllowlist()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_setAllowlist(address(stakeLocker), address(sam), true));\n        assertTrue(!stakeLocker.allowed(address(sam)));\n\n        // Unpause protocol and setAllowlist()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pat.try_setAllowlist(address(stakeLocker), address(sam), true));\n        assertTrue(stakeLocker.allowed(address(sam)));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/PoolLiquidityProvider.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract PoolTest is TestUtil {\n\n    using SafeMath for uint256;\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpActors();\n        setUpBalancerPool();\n        createLiquidityPools();\n        createLoans();\n    }\n\n    function test_deposit(uint256 depositAmt) public {\n        address stakeLocker = pool.stakeLocker();\n        address liqLocker   = pool.liquidityLocker();\n\n        depositAmt = constrictToRange(depositAmt, 1 * USD, 100 * USD, true);\n\n        assertTrue(!leo.try_deposit(address(pool), depositAmt)); // Not finalized\n\n        finalizePool(pool, pat, false);\n\n        // Mint 100 USDC into this LP account\n        mint(\"USDC\", address(leo), depositAmt);\n\n        assertTrue(!pool.openToPublic());\n        assertTrue(!pool.allowedLiquidityProviders(address(leo)));\n        assertTrue( !leo.try_deposit(address(pool), depositAmt)); // Not in the LP allow list neither the pool is open to public.\n\n        assertTrue( !pam.try_setAllowList(address(pool), address(leo), true)); // It will fail as `pam` is not the right PD.\n        assertTrue(  pat.try_setAllowList(address(pool), address(leo), true));\n        assertTrue( pool.allowedLiquidityProviders(address(leo)));\n        \n        assertTrue(!leo.try_deposit(address(pool), depositAmt)); // Not Approved\n\n        leo.approve(USDC, address(pool), MAX_UINT);\n\n        assertLiquidity(pool, leo, liqLocker, depositAmt, 0, 0);\n\n        assertTrue(leo.try_deposit(address(pool), depositAmt));\n\n        assertLiquidity(pool, leo, liqLocker, 0, depositAmt, toWad(depositAmt));\n\n        // Remove leo from the allowed list\n        assertTrue(pat.try_setAllowList(address(pool), address(leo), false));\n        mint(\"USDC\", address(leo), depositAmt);\n        assertTrue(!leo.try_deposit(address(pool), depositAmt));\n\n        uint256 newDepositAmt = constrictToRange(depositAmt, 100 * USD, 200 * USD, true);\n\n        mint(\"USDC\", address(lex), newDepositAmt);\n        lex.approve(USDC, address(pool), MAX_UINT);\n        \n        assertLiquidity(pool, lex, liqLocker, newDepositAmt, depositAmt, 0);\n\n        assertTrue(!pool.allowedLiquidityProviders(address(lex)));\n        assertTrue(  !lex.try_deposit(address(pool), 100 * USD)); // Fail to invest as lex is not in the allowed list.\n\n        // Pause protocol and attempt openPoolToPublic()\n        assertTrue( emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_setOpenToPublic(address(pool), true));\n\n        // Unpause protocol and openPoolToPublic()\n        assertTrue( emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(!pam.try_setOpenToPublic(address(pool), true));  // Incorrect PD.\n        assertTrue( pat.try_setOpenToPublic(address(pool), true));\n\n        assertTrue(lex.try_deposit(address(pool), 100 * USD));\n\n        assertLiquidity(pool, lex, liqLocker, newDepositAmt - 100 * USD, depositAmt + 100 * USD, toWad(100 * USD));\n\n        mint(\"USDC\", address(leo), depositAmt);\n\n        // Pool-specific pause by Pool Delegate via setLiquidityCap(0)\n        assertEq(  pool.liquidityCap(), MAX_UINT);\n        assertTrue(!cam.try_setLiquidityCap(address(pool), 0));\n        assertTrue( pat.try_setLiquidityCap(address(pool), 0));\n        assertEq(  pool.liquidityCap(), 0);\n        assertTrue(!leo.try_deposit(address(pool), 1 * USD));\n        assertTrue( pat.try_setLiquidityCap(address(pool), MAX_UINT));\n        assertEq(  pool.liquidityCap(), MAX_UINT);\n        assertTrue( leo.try_deposit(address(pool), depositAmt));\n        assertEq(  pool.balanceOf(address(leo)), toWad(2 * depositAmt));\n \n        // Protocol-wide pause by Emergency Admin\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!leo.try_deposit(address(pool), 1 * USD));\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(leo.try_deposit(address(pool), depositAmt));\n        assertEq( pool.balanceOf(address(leo)), toWad(3 * depositAmt));\n\n        // Pause protocol and attempt setLiquidityCap()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_setLiquidityCap(address(pool), MAX_UINT));\n\n        // Unpause protocol and setLiquidityCap()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pat.try_setLiquidityCap(address(pool), MAX_UINT));\n\n        assertTrue( pat.try_setOpenToPublic(address(pool),      false));  // Close pool to public\n        assertTrue(!lex.try_deposit(address(pool),         depositAmt));  // Fail to deposit as pool no longer public\n    }\n\n    function test_deposit_with_liquidity_cap(uint256 newLiquidityCap) public {\n\n        finalizePool(pool, pat, true);\n\n        // Mint 10_000 USDC into this LP account\n        mint(\"USDC\", address(leo), 10_000 * USD);\n        leo.approve(USDC, address(pool), MAX_UINT);\n\n        newLiquidityCap = constrictToRange(newLiquidityCap, 10 * USD, 1000 * USD, true);\n\n        // Changes the `liquidityCap`.\n        assertTrue(pat.try_setLiquidityCap(address(pool), newLiquidityCap), \"Failed to set liquidity cap\");\n        assertEq( pool.liquidityCap(), newLiquidityCap,                     \"Incorrect value set for liquidity cap\");\n\n        // Not able to deposit as cap is lower than the deposit amount.\n        assertTrue(!pool.isDepositAllowed(newLiquidityCap + 1),                \"Deposit should not be allowed because liquidityCap < depositAmt\");\n        assertTrue( !leo.try_deposit(address(pool), newLiquidityCap + 1),      \"Should not able to deposit depositAmt\");\n\n        // Tries with lower amount it will pass.\n        assertTrue(pool.isDepositAllowed(newLiquidityCap - 1),                  \"Deposit should be allowed because liquidityCap > depositAmt\");\n        assertTrue( leo.try_deposit(address(pool), newLiquidityCap - 1),        \"Fail to deposit depositAmt\");\n\n        // leo tried again with 6 USDC it fails again.\n        assertTrue(!pool.isDepositAllowed(2),                         \"Deposit should not be allowed because liquidityCap < newLiquidityCap - 1 + 2\");\n        assertTrue( !leo.try_deposit(address(pool), 2),               \"Should not able to deposit 2 USD\");\n\n        // Set liquidityCap to zero and withdraw\n        assertTrue(pat.try_setLiquidityCap(address(pool), 0),         \"Failed to set liquidity cap\");\n        assertTrue(pat.try_setLockupPeriod(address(pool), 0),         \"Failed to set the lockup period\");\n        assertEq( pool.lockupPeriod(), uint256(0),                    \"Failed to update the lockup period\");\n\n        assertTrue(leo.try_intendToWithdraw(address(pool)),           \"Failed to intend to withdraw\");\n\n        hevm.warp(block.timestamp + globals.lpCooldownPeriod() + 1);\n        assertTrue(leo.try_withdraw(address(pool), 1 * USD),        \"Should pass to withdraw the funds from the pool\");\n    }\n\n    function test_deposit_depositDate(uint256 depositAmt) public {\n       \n        finalizePool(pool, pat, true);\n        \n        // Mint 100 USDC into this LP account\n        uint256 startDate  = block.timestamp;\n        uint256 depositAmt = constrictToRange(depositAmt, 100 * USD, 10_000_000 * USD, true);\n        mintFundsAndDepositIntoPool(leo, pool, 20_000_000 * USD, depositAmt);\n    \n        assertEq(pool.depositDate(address(leo)), startDate);\n\n        uint256 newAmt = constrictToRange(depositAmt, 1 * USD, 100_000 * USD, true);\n\n        hevm.warp(startDate + 30 days);\n        leo.deposit(address(pool), newAmt);\n\n        uint256 newDepDate = startDate + (block.timestamp - startDate) * newAmt / (newAmt + depositAmt);\n        assertEq(pool.depositDate(address(leo)), newDepDate);  // Gets updated\n\n        assertTrue(pat.try_setLockupPeriod(address(pool), uint256(0)));  // Sets 0 as lockup period to allow withdraw. \n        make_withdrawable(leo, pool);\n        leo.withdraw(address(pool), newAmt);\n\n        assertEq(pool.depositDate(address(leo)), newDepDate);  // Doesn't change\n    }\n\n    function test_transfer_lockup_period(uint256 depositAmt) public {\n        finalizePool(pool, pat, true);\n\n        // Deposit 100 USDC on first day\n        uint256 startDate = block.timestamp;\n        uint256 depositAmt = constrictToRange(depositAmt, 100 * USD, 10_000_000 * USD, true);\n\n        // Mint 200 USDC into this LP account\n        mintFundsAndDepositIntoPool(leo, pool, 20_000_000 * USD, depositAmt);\n        mintFundsAndDepositIntoPool(liz, pool, 20_000_000 * USD, depositAmt);\n\n        assertEq(pool.depositDate(address(leo)), startDate);\n        assertEq(pool.depositDate(address(liz)), startDate);\n        assertEq(pool.balanceOf(address(leo)), toWad(depositAmt));\n        assertEq(pool.balanceOf(address(liz)), toWad(depositAmt));\n\n        uint256 newDeposit = constrictToRange(depositAmt, 50 * USD, depositAmt, true);  // Amount of FDT transferred\n\n        // Will fail because lockup period hasn't passed yet\n        assertTrue(!liz.try_transfer(address(pool), address(leo), toWad(newDeposit)));\n\n        // Warp to just before lockup period ends\n        hevm.warp(startDate + pool.lockupPeriod() - 1);\n        assertTrue(!liz.try_transfer(address(pool), address(leo), toWad(newDeposit)));\n\n        // Warp to after lockup period\n        hevm.warp(startDate + pool.lockupPeriod());\n\n        // Pause protocol and attempt to transfer FDTs\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!liz.try_transfer(address(pool), address(leo), toWad(newDeposit)));\n\n        // Unpause protocol and transfer FDTs\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(liz.try_transfer(address(pool), address(leo), toWad(newDeposit)));  // Pool.transfer()\n\n        // Check balances and deposit dates are correct\n        assertEq(pool.balanceOf(address(leo)), toWad(depositAmt) + toWad(newDeposit));\n        assertEq(pool.balanceOf(address(liz)), toWad(depositAmt) - toWad(newDeposit));\n        uint256 newDepDate = startDate + (block.timestamp - startDate) * toWad(newDeposit) / (toWad(newDeposit) + toWad(depositAmt));\n        assertEq(pool.depositDate(address(leo)), newDepDate);  // Gets updated\n        assertEq(pool.depositDate(address(liz)), startDate);   // Stays the same\n    }\n\n    function test_transfer_recipient_withdrawing(uint256 depositAmt) public {\n        finalizePool(pool, pat, true);\n        pat.setLockupPeriod(address(pool), 0);\n\n        // Deposit 100 USDC on first day\n        uint256 start = block.timestamp;\n        depositAmt    = constrictToRange(depositAmt, 100 * USD, 10_000_000 * USD, true);\n\n        // Mint 200 USDC into this LP account\n        mintFundsAndDepositIntoPool(leo, pool, 10_000_000 * USD, depositAmt);\n        mintFundsAndDepositIntoPool(liz, pool, 10_000_000 * USD, depositAmt);\n\n        assertEq(pool.balanceOf(address(leo)), toWad(depositAmt));\n        assertEq(pool.balanceOf(address(liz)), toWad(depositAmt));\n        assertEq(pool.depositDate(address(leo)), start);\n        assertEq(pool.depositDate(address(liz)), start);\n\n        // LP (Liz) initiates withdrawal\n        assertTrue(liz.try_intendToWithdraw(address(pool)), \"Failed to intend to withdraw\");\n        assertEq( pool.withdrawCooldown(address(liz)), start);\n\n        // LP (Leo) fails to transfer to LP (liz) that is currently withdrawing\n        assertTrue(!leo.try_transfer(address(pool), address(liz), toWad(depositAmt)));\n        hevm.warp(start + globals.lpCooldownPeriod() + globals.lpWithdrawWindow());  // Very end of LP withdrawal window\n        assertTrue(!leo.try_transfer(address(pool), address(liz), toWad(depositAmt)));\n\n        // LP (leo) successfully transfers to LP (liz) that is outside withdraw window\n        hevm.warp(start + globals.lpCooldownPeriod() + globals.lpWithdrawWindow() + 1);  // Second after LP withdrawal window ends\n        assertTrue( leo.try_transfer(address(pool), address(liz), toWad(depositAmt)));\n        assertTrue(!liz.try_withdraw(address(pool), toWad(depositAmt)));\n\n        // Check balances and deposit dates are correct\n        assertEq(pool.balanceOf(address(leo)), 0);\n        assertEq(pool.balanceOf(address(liz)), toWad(depositAmt) * 2);\n        uint256 newDepDate = start + (block.timestamp - start) * (toWad(depositAmt)) / ((toWad(depositAmt)) + (toWad(depositAmt)));\n        assertEq(pool.depositDate(address(leo)), start);       // Stays the same\n        assertEq(pool.depositDate(address(liz)), newDepDate);  // Gets updated\n    }\n\n    function test_withdraw_cooldown(uint256 depositAmt) public {\n\n        gov.setLpCooldownPeriod(10 days);\n\n        finalizePool(pool, pat, true);\n        pat.setLockupPeriod(address(pool), 0);\n\n        depositAmt = constrictToRange(depositAmt, 100 * USD, 10_000_000 * USD, true);\n\n        // Mint 1000 USDC into this LP account\n        mintFundsAndDepositIntoPool(leo, pool, 10_000_000 * USD, depositAmt);\n\n        uint256 amt   = depositAmt / 3; // 1/3 of deposit so withdraw can happen thrice\n        uint256 start = block.timestamp;\n\n        assertTrue(!leo.try_withdraw(address(pool), amt),     \"Should fail to withdraw 500 USD because account has to intendToWithdraw\");\n        assertTrue(!lex.try_intendToWithdraw(address(pool)),  \"Should fail to intend to withdraw because lex has zero PoolFDTs\");\n        assertTrue( leo.try_intendToWithdraw(address(pool)),  \"Should fail to intend to withdraw\");\n        assertEq(  pool.withdrawCooldown(address(leo)), start);\n        assertTrue(!leo.try_withdraw(address(pool), amt),      \"Should fail to withdraw as cooldown period hasn't passed yet\");\n\n        // Just before cooldown ends\n        hevm.warp(start + globals.lpCooldownPeriod() - 1);\n        assertTrue(!leo.try_withdraw(address(pool), amt), \"Should fail to withdraw as cooldown period hasn't passed yet\");\n\n        // Right when cooldown ends\n        hevm.warp(start + globals.lpCooldownPeriod());\n        assertTrue(leo.try_withdraw(address(pool), amt), \"Should be able to withdraw funds at beginning of cooldown window\");\n\n        // Still within LP withdrawal window\n        hevm.warp(start + globals.lpCooldownPeriod() + 1);\n        assertTrue(leo.try_withdraw(address(pool), amt), \"Should be able to withdraw funds again during cooldown window\");\n\n        // Second after LP withdrawal window ends\n        hevm.warp(start + globals.lpCooldownPeriod() + globals.lpWithdrawWindow() + 1);\n        assertTrue(!leo.try_withdraw(address(pool), amt), \"Should fail to withdraw funds because now past withdraw window\");\n\n        uint256 newStart = block.timestamp;\n        \n        // ** Below is the test of resetting feature of withdrawCooldown after withdrawing funds again and again ** //\n\n        // Intend to withdraw\n        assertTrue(leo.try_intendToWithdraw(address(pool)), \"Failed to intend to withdraw\");\n\n        // Second after LP withdrawal window ends\n        hevm.warp(newStart + globals.lpCooldownPeriod() + globals.lpWithdrawWindow() + 1);\n        assertTrue(!leo.try_withdraw(address(pool), amt), \"Should fail to withdraw as cooldown window has been passed\");\n\n        // Last second of LP withdrawal window\n        hevm.warp(newStart + globals.lpCooldownPeriod() + globals.lpWithdrawWindow());\n        assertTrue(leo.try_withdraw(address(pool), amt), \"Should be able to withdraw funds at end of cooldown window\");\n    }\n\n    function test_cancelWithdraw() public {\n\n        finalizePool(pool, pat, true);\n\n        // Mint USDC to lee and deposit into Pool\n        mintFundsAndDepositIntoPool(lee, pool, 1000 * USD, 1000 * USD);\n\n        assertEq(pool.withdrawCooldown(address(lee)), 0);\n        assertTrue(lee.try_intendToWithdraw(address(pool)));\n        assertEq(pool.withdrawCooldown(address(lee)), block.timestamp);\n\n        assertTrue(lee.try_cancelWithdraw(address(pool)));\n        assertEq(pool.withdrawCooldown(address(lee)), 0);\n    }\n\n    function test_withdraw_under_lockup_period(uint256 depositAmt) public {\n        finalizePool(pool, pat, true);\n        gov.setValidLoanFactory(address(loanFactory), true);\n\n        // Ignore cooldown for this test\n        gov.setLpWithdrawWindow(MAX_UINT);\n\n        uint256 start = block.timestamp;\n        depositAmt    = constrictToRange(depositAmt, 1000 * USD, 10_000_000 * USD, true);\n        // Mint USDC to lee\n        mintFundsAndDepositIntoPool(lee, pool, 10_000_000 * USD, depositAmt);\n        uint256 bal0 = 10_000_000 * USD;\n        \n        // Check depositDate\n        assertEq(pool.depositDate(address(lee)), start);\n\n        // Fund loan, drawdown, make payment and claim so lee can claim interest\n        assertTrue(pat.try_fundLoan(address(pool), address(loan3),  address(dlFactory), depositAmt), \"Fail to fund the loan\");\n        drawdown(loan3, bud, depositAmt);\n        doFullLoanPayment(loan3, bud); \n        pat.claim(address(pool), address(loan3), address(dlFactory));\n\n        uint256 interest = pool.withdrawableFundsOf(address(lee));  // Get kim's withdrawable funds\n\n        assertTrue(lee.try_intendToWithdraw(address(pool)));\n        // Warp to exact time that lee can withdraw with weighted deposit date\n        hevm.warp( pool.depositDate(address(lee)) + pool.lockupPeriod() - 1);\n        assertTrue(!lee.try_withdraw(address(pool), depositAmt), \"Withdraw failure didn't trigger\");\n        hevm.warp( pool.depositDate(address(lee)) + pool.lockupPeriod());\n        assertEq(pool.balanceOf(address(lee)), toWad(depositAmt));\n        assertTrue( lee.try_withdraw(address(pool), depositAmt), \"Failed to withdraw funds\");\n\n        assertEq(IERC20(USDC).balanceOf(address(lee)) - bal0, interest);\n    }\n\n    function test_withdraw_under_weighted_lockup_period(uint256 depositAmt) public {\n        finalizePool(pool, pat, true);\n        gov.setValidLoanFactory(address(loanFactory), true);\n\n        // Ignore cooldown for this test\n        gov.setLpWithdrawWindow(MAX_UINT);\n\n        uint256 start = block.timestamp;\n        depositAmt    = constrictToRange(depositAmt, 1000 * USD, 10_000_000 * USD, true);\n\n        // Mint USDC to lee\n        mintFundsAndDepositIntoPool(lee, pool, 20_000_000 * USD, depositAmt);\n        uint256 bal0 = 20_000_000 * USD;\n\n        // Check depositDate\n        assertEq(pool.depositDate(address(lee)), start);\n\n        // Fund loan, drawdown, make payment and claim so lee can claim interest\n        assertTrue(pat.try_fundLoan(address(pool), address(loan3),  address(dlFactory), depositAmt), \"Fail to fund the loan\");\n        drawdown(loan3, bud, depositAmt);\n        doFullLoanPayment(loan3, bud); \n        pat.claim(address(pool), address(loan3), address(dlFactory));\n\n        // Warp to exact time that lee can withdraw for the first time\n        hevm.warp(start + pool.lockupPeriod());  \n        assertEq(block.timestamp - pool.depositDate(address(lee)), pool.lockupPeriod());  // Can withdraw at this point\n        \n        // Deposit more USDC into pool, increasing deposit date and locking up funds again\n        uint256 newDepositAmt = constrictToRange(depositAmt, 1000 * USD, 10_000_000 * USD, true);\n        assertTrue(lee.try_deposit(address(pool), newDepositAmt));\n        assertEq( pool.depositDate(address(lee)) - start, (block.timestamp - start) * (toWad(newDepositAmt)) / (toWad(newDepositAmt) + toWad(depositAmt)));  // Deposit date updating using weighting\n        assertTrue( lee.try_intendToWithdraw(address(pool)));\n        assertTrue(!lee.try_withdraw(address(pool), newDepositAmt + depositAmt), \"Withdraw failure didn't trigger\");                // Not able to withdraw the funds as deposit date was updated\n\n        uint256 interest = pool.withdrawableFundsOf(address(lee));  // Get kim's withdrawable funds\n\n        // Warp to exact time that lee can withdraw with weighted deposit date\n        assertTrue(!lee.try_withdraw(address(pool), newDepositAmt + depositAmt), \"Withdraw failure didn't trigger\");\n        hevm.warp(pool.depositDate(address(lee)) + pool.lockupPeriod());\n        assertTrue( lee.try_withdraw(address(pool), newDepositAmt + depositAmt), \"Failed to withdraw funds\");\n\n        assertEq(IERC20(USDC).balanceOf(address(lee)) - bal0, interest);\n    }\n\n    function test_withdraw_protocol_paused() public {\n        finalizePool(pool, pat, true);\n        gov.setValidLoanFactory(address(loanFactory), true);\n        \n        assertTrue(pat.try_setLockupPeriod(address(pool), 0));\n        assertEq(pool.lockupPeriod(), uint256(0));\n\n        mintFundsAndDepositIntoPool(lee, pool, 2000 * USD, 1000 * USD);\n        make_withdrawable(lee, pool);\n\n        // Protocol-wide pause by Emergency Admin\n        assertTrue(!globals.protocolPaused());\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n\n        // Attempt to withdraw while protocol paused\n        assertTrue(globals.protocolPaused());\n        assertTrue(!lee.try_withdrawFunds(address(pool)));\n        assertTrue(!lee.try_withdraw(address(pool), 1000 * USD));\n\n        // Unpause and withdraw\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(lee.try_withdrawFunds(address(pool)));\n        assertTrue(lee.try_withdraw(address(pool), 1000 * USD));\n\n        assertEq(IERC20(USDC).balanceOf(address(lee)), 2000 * USD);\n    }\n\n    /***************/\n    /*** Helpers ***/\n    /***************/\n\n    function assertLiquidity(Pool pool, LP lp, address liqLocker, uint256 balanceOfLp, uint256 balanceOfLiqLocker, uint256 balanceOfPoolFdt) internal {\n        assertEq(IERC20(USDC).balanceOf(address(lp)), balanceOfLp);\n        assertEq(IERC20(USDC).balanceOf(liqLocker),   balanceOfLiqLocker);\n        assertEq(pool.balanceOf(address(lp)),         balanceOfPoolFdt);\n    }\n\n}\n"
    },
    "packages/protocol/contracts/test/PoolLiquidation.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract PoolLiquidationTest is TestUtil {\n\n    using SafeMath for uint256;\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpActors();\n        setUpBalancerPoolForPools();\n        createLiquidityPools();\n        stakeAndFinalizePools(10 * WAD, 25 * WAD);  // Less than 1/6 in first pool, so that all BPTs can be burned in tests\n        createLoans();\n\n        gov.setMaxSwapSlippage(2000);  // Set to 20% for the sake of the BPT shortfall test\n    }\n\n    function test_triggerDefault_pool_delegate() public {\n        uint256 drawdownAmt  = 4_000_000 * USD;\n\n        // Fund the pool\n        mint(\"USDC\", address(leo), 100_000_000 * USD);\n        leo.approve(USDC, address(pool), MAX_UINT);\n        leo.approve(USDC, address(pool2), MAX_UINT);\n        leo.deposit(address(pool), 80_000_000 * USD + 1);\n        leo.deposit(address(pool2), 20_000_000 * USD - 1);\n\n        // Fund the loan\n        pat.fundLoan(address(pool), address(loan), address(dlFactory), 80_000_000 * USD + 1);   // Plus 1e-6 to create exact 100m totalSupply\n        pam.fundLoan(address(pool2), address(loan), address(dlFactory), 20_000_000 * USD - 1);  // 20% minus 1e-6 equity\n\n        // Drawdown loan\n        drawdown(loan, bob, drawdownAmt);\n\n        // Warp to late payment\n        uint256 start = block.timestamp;\n        uint256 nextPaymentDue = loan.nextPaymentDue();\n        uint256 gracePeriod = globals.defaultGracePeriod();\n        hevm.warp(start + nextPaymentDue + gracePeriod + 1);\n\n        // Attempt to trigger default as PD holding less than minimum LoanFDTs required (MapleGlobals.minLoanEquity)\n        assertTrue(!pam.try_triggerDefault(address(pool2), address(loan), address(dlFactory)));\n\n        // Update storage to have exactly 20% equity (totalSupply remains the same)\n        hevm.store(\n            address(loan),\n            keccak256(abi.encode(address(pool2.debtLockers(address(loan), address(dlFactory))), 0)), // Overwrite balance to have exact 20% equity\n            bytes32(uint256(20_000_000 * WAD))\n        );\n\n        // Pause protocol and attempt triggerDefault()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pam.try_triggerDefault(address(pool2), address(loan), address(dlFactory)));\n\n        // Unpause protocol and triggerDefault()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pam.try_triggerDefault(address(pool2), address(loan), address(dlFactory)));\n    }\n\n    function setUpLoanAndDefault() public {\n        // Fund the pool\n        mint(\"USDC\", address(leo), 4_000_000 * USD);\n        leo.approve(USDC, address(pool),  MAX_UINT);\n        leo.approve(USDC, address(pool2), MAX_UINT);\n        leo.deposit(address(pool),  1_000_000 * USD);\n        leo.deposit(address(pool2), 3_000_000 * USD);\n\n        // Fund the loan\n        pat.fundLoan(address(pool), address(loan), address(dlFactory),  100_000 * USD);\n        pam.fundLoan(address(pool2), address(loan), address(dlFactory), 300_000 * USD);\n        uint256 cReq = loan.collateralRequiredForDrawdown(4_000_000 * USD);\n\n        // Drawdown loan\n        mint(\"WETH\", address(bob), cReq);\n        bob.approve(WETH, address(loan), MAX_UINT);\n        bob.drawdown(address(loan), 400_000 * USD);\n\n        // Warp to late payment\n        uint256 start = block.timestamp;\n        uint256 nextPaymentDue = loan.nextPaymentDue();\n        uint256 gracePeriod = globals.defaultGracePeriod();\n        hevm.warp(start + nextPaymentDue + gracePeriod + 1);\n\n        // Trigger default\n        pat.triggerDefault(address(pool), address(loan), address(dlFactory));\n    }\n\n    function test_claim_default_info() public {\n\n        setUpLoanAndDefault();\n\n        /**\n            Now that triggerDefault() is called, the return value defaultSuffered\n            will be greater than 0. Calling claim() is the mechanism which settles,\n            or rather updates accounting in the Pool which in turn will enable us\n            to handle liquidation of BPTs in the StakeLocker accurately.\n        */\n        uint256[7] memory vals_a = pat.claim(address(pool), address(loan),  address(dlFactory));\n        uint256[7] memory vals_b = pam.claim(address(pool2), address(loan),  address(dlFactory));\n\n        // Non-zero value is passed through.\n        assertEq(vals_a[6], loan.defaultSuffered() * (100_000 * WAD) / (400_000 * WAD));\n        assertEq(vals_b[6], loan.defaultSuffered() * (300_000 * WAD) / (400_000 * WAD));\n        withinPrecision(vals_a[6] + vals_b[6], loan.defaultSuffered(), 2);\n\n        // Call claim again to make sure that default isn't double accounted\n        vals_a = pat.claim(address(pool), address(loan),  address(dlFactory));\n        vals_b = pam.claim(address(pool2), address(loan),  address(dlFactory));\n        assertEq(vals_a[6], 0);\n        assertEq(vals_b[6], 0);\n    }\n\n    function test_claim_default_burn_BPT_full_recover() public {\n\n        setUpLoanAndDefault();\n\n        TestObj memory liquidityLocker_a_bal;\n        TestObj memory liquidityLocker_b_bal;\n        TestObj memory stakeLocker_a_bal;\n        TestObj memory stakeLocker_b_bal;\n        TestObj memory principalOut_a;\n        TestObj memory principalOut_b;\n\n        address liquidityLocker_a = pool.liquidityLocker();\n        address liquidityLocker_b = pool2.liquidityLocker();\n\n        // Pre-state liquidityLocker checks.\n        liquidityLocker_a_bal.pre = IERC20(USDC).balanceOf(liquidityLocker_a);\n        liquidityLocker_b_bal.pre = IERC20(USDC).balanceOf(liquidityLocker_b);\n\n        stakeLocker_a_bal.pre = bPool.balanceOf(address(stakeLocker));\n        stakeLocker_b_bal.pre = bPool.balanceOf(address(stakeLocker2));\n\n        principalOut_a.pre = pool.principalOut();\n        principalOut_b.pre = pool2.principalOut();\n\n        assertEq(principalOut_a.pre, 100_000 * USD);\n        assertEq(principalOut_b.pre, 300_000 * USD);\n\n        assertEq(stakeLocker_a_bal.pre, 10 * WAD);\n        assertEq(stakeLocker_b_bal.pre, 25 * WAD);\n\n        assertEq(liquidityLocker_a_bal.pre,   900_000 * USD);\n        assertEq(liquidityLocker_b_bal.pre, 2_700_000 * USD);\n\n        pat.claim(address(pool), address(loan),  address(dlFactory));\n        pam.claim(address(pool2), address(loan),  address(dlFactory));\n\n        // Post-state liquidityLocker checks.\n        liquidityLocker_a_bal.post = IERC20(USDC).balanceOf(liquidityLocker_a);\n        liquidityLocker_b_bal.post = IERC20(USDC).balanceOf(liquidityLocker_b);\n\n        stakeLocker_a_bal.post = bPool.balanceOf(address(stakeLocker));\n        stakeLocker_b_bal.post = bPool.balanceOf(address(stakeLocker2));\n\n        principalOut_a.post = pool.principalOut();\n        principalOut_b.post = pool2.principalOut();\n\n        withinDiff(liquidityLocker_a_bal.post - liquidityLocker_a_bal.pre, 100_000 * USD, 1);  // Entire initial loan amount was recovered between liquidation and burn\n        withinDiff(liquidityLocker_b_bal.post - liquidityLocker_b_bal.pre, 300_000 * USD, 1);  // Entire initial loan amount was recovered between liquidation and burn\n\n        withinDiff(principalOut_a.post, 0, 1);  // Principal out is set to zero (with dust)\n        withinDiff(principalOut_b.post, 0, 1);  // Principal out is set to zero (with dust)\n\n        assertEq(liquidityLocker_a_bal.pre  + principalOut_a.pre,  1_000_000 * USD);  // Total pool value = 900k + 100k = 1m\n        assertEq(liquidityLocker_a_bal.post + principalOut_a.post, 1_000_000 * USD);  // Total pool value = 1m + 0 = 1m (successful full coverage from liquidation + staker burn)\n\n        assertEq(liquidityLocker_b_bal.pre  + principalOut_b.pre,  3_000_000 * USD);  // Total pool value = 2.7m + 300k = 3m\n        assertEq(liquidityLocker_b_bal.post + principalOut_b.post, 3_000_000 * USD);  // Total pool value = 3m + 0 = 3m (successful full coverage from liquidation + staker burn)\n\n        assertTrue(stakeLocker_a_bal.pre - stakeLocker_a_bal.post > 0);  // Assert BPTs were burned\n        assertTrue(stakeLocker_b_bal.pre - stakeLocker_b_bal.post > 0);  // Assert BPTs were burned\n\n        assertEq(stakeLocker_a_bal.pre - stakeLocker_a_bal.post, stakeLocker.bptLosses());  // Assert FDT loss accounting\n        assertEq(stakeLocker_a_bal.pre - stakeLocker_a_bal.post, stakeLocker.bptLosses());  // Assert FDT loss accounting\n    }\n\n    function assertPoolAccounting(Pool pool) internal {\n        uint256 liquidityAssetDecimals = IERC20Details(address(pool.liquidityAsset())).decimals();\n\n        uint256 liquidityLockerBal = pool.liquidityAsset().balanceOf(pool.liquidityLocker());\n        uint256 fdtTotalSupply     = pool.totalSupply().mul(10 ** liquidityAssetDecimals).div(WAD);  // Convert to liquidityAsset precision\n        uint256 principalOut       = pool.principalOut();\n        uint256 interestSum        = pool.interestSum();\n        uint256 poolLosses         = pool.poolLosses();\n\n        // Total Pool Value = LLBal + PO = fdtSupply + interestSum + aggregate unrecognized losses\n        assertEq(liquidityLockerBal + principalOut, fdtTotalSupply + interestSum - poolLosses, \"Pool accounting compromised\");\n    }\n\n    function test_claim_default_burn_BPT_shortfall() public {\n\n        // Fund the pool\n        mint(\"USDC\", address(leo), 500_000_000 * USD);\n        mint(\"USDC\", address(liz),  10_000_000 * USD);\n\n        leo.approve(USDC, address(pool), MAX_UINT);\n        liz.approve(USDC, address(pool), MAX_UINT);\n        leo.deposit(address(pool), 500_000_000 * USD);  // Ali symbolizes all other LPs, test focuses on Bob\n        liz.deposit(address(pool), 10_000_000 * USD);\n        assertTrue(liz.try_intendToWithdraw(address(pool)));\n\n        assertPoolAccounting(pool);\n\n        // Fund the loan\n        pat.fundLoan(address(pool), address(loan), address(dlFactory), 100_000_000 * USD);\n        uint256 cReq = loan.collateralRequiredForDrawdown(100_000_000 * USD);\n\n        assertPoolAccounting(pool);\n\n        // Drawdown loan\n        mint(\"WETH\", address(bob), cReq);\n        bob.approve(WETH, address(loan), MAX_UINT);\n        bob.drawdown(address(loan), 100_000_000 * USD);\n\n        assertPoolAccounting(pool);\n\n        // Warp to late payment\n        hevm.warp(block.timestamp + loan.nextPaymentDue() + globals.defaultGracePeriod() + 1);\n\n        // Trigger default\n        pat.triggerDefault(address(pool), address(loan), address(dlFactory));\n\n        // Instantiate all test variables\n        TestObj memory liquidityLockerBal;\n        TestObj memory slBPTBal;\n        TestObj memory fdtSupply;\n        TestObj memory principalOut;\n        TestObj memory poolLosses;\n        TestObj memory bob_usdcBal;\n        TestObj memory bob_poolBal;\n        TestObj memory bob_recognizableLosses;\n\n        address liquidityLocker = pool.liquidityLocker();\n        address stakeLocker     = pool.stakeLocker();\n\n        /**************************************************/\n        /*** Loan Default Accounting with BPT Shortfall ***/\n        /**************************************************/\n\n        // Pre-claim accounting checks\n        liquidityLockerBal.pre = IERC20(USDC).balanceOf(liquidityLocker);\n        slBPTBal.pre           = bPool.balanceOf(stakeLocker);\n        fdtSupply.pre          = pool.totalSupply();\n        principalOut.pre       = pool.principalOut();\n        poolLosses.pre         = pool.poolLosses();\n\n        uint256[7] memory vals_a = pat.claim(address(pool), address(loan),  address(dlFactory));\n\n        assertPoolAccounting(pool);\n\n        // Pre-claim accounting checks\n        liquidityLockerBal.post = IERC20(USDC).balanceOf(liquidityLocker);\n        slBPTBal.post           = bPool.balanceOf(stakeLocker);\n        fdtSupply.post          = pool.totalSupply();\n        principalOut.post       = pool.principalOut();\n        poolLosses.post         = pool.poolLosses();\n\n        assertEq(principalOut.pre,       100_000_000 * USD);  // Total Pool Value (TPV) = PO + LLBal = 510m\n        assertEq(liquidityLockerBal.pre, 410_000_000 * USD);\n\n        assertEq(slBPTBal.pre,  10 * WAD);  // Assert pre-burn BPT balance\n        assertLt(slBPTBal.post,     1E10);  // Dusty stakeLocker BPT return bal (less than 1e-8 WAD), meaning essentially all BPTs were burned\n\n        assertEq(slBPTBal.pre - slBPTBal.post, IStakeLocker(stakeLocker).bptLosses());  // Assert FDT loss accounting\n\n        assertEq(poolLosses.pre,                 0);  // No poolLosses before bpt burning occurs\n        assertGt(poolLosses.post, 40_000_000 * USD);  // Over $40m in shortfall after liquidation and BPT burn\n\n        assertEq(fdtSupply.pre,  510_000_000 * WAD);  // TPV = fdtSupply + interestSum - shortfall = PO + LLBal\n        assertEq(fdtSupply.post, 510_000_000 * WAD);  // TPV = 510m + 0 - 0\n\n        assertEq(liquidityLockerBal.pre  + principalOut.pre,                    510_000_000 * USD);  // TPV = LLBal + PO + shortfall = 510m (shortfall = aggregate unrecognizedLosses of LPs)\n        assertEq(liquidityLockerBal.post + principalOut.post + poolLosses.post, 510_000_000 * USD);  // LLBal + PO goes down, poolLosses distributes that loss - TPV = LL + PO + SF stays constant\n\n        withinDiff(principalOut.post, 0, 1);  // Principal out is set to zero after claim has been made (with dust)\n\n        /********************************************************/\n        /*** Liquidity Provider Minimum Withdrawal Accounting ***/\n        /********************************************************/\n\n        make_withdrawable(liz, pool);\n\n        bob_recognizableLosses.pre = pool.recognizableLossesOf(address(liz));  // Unrealized losses of liz from shortfall\n\n        assertTrue(!liz.try_withdraw(address(pool), bob_recognizableLosses.pre - 1));  // Cannot withdraw less than recognizableLosses\n\n        bob_usdcBal.pre = IERC20(USDC).balanceOf(address(liz));  // Bob USDC bal\n        bob_poolBal.pre = pool.balanceOf(address(liz));        // Bob FDT  bal\n\n        // Withdraw lowest possible amount (amt == recognizableLosses)\n        // NOTE: LPs can withdraw more than this amount, it will just go towards their USDC\n        assertTrue(!liz.try_transfer(address(pool), address(leo), bob_poolBal.pre));\n        assertTrue( liz.try_withdraw(address(pool), bob_recognizableLosses.pre));\n\n        assertPoolAccounting(pool);\n\n        bob_recognizableLosses.post = pool.recognizableLossesOf(address(liz));  // Unrealized losses of liz after withdrawal\n\n        bob_usdcBal.post = IERC20(USDC).balanceOf(address(liz));  // Bob USDC bal\n        bob_poolBal.post = pool.balanceOf(address(liz));        // Bob FDT  bal\n\n        liquidityLockerBal.pre  = liquidityLockerBal.post;                  // Update pre/post variables for withdrawal checks\n        liquidityLockerBal.post = IERC20(USDC).balanceOf(liquidityLocker);  // Update pre/post variables for withdrawal checks\n\n        fdtSupply.pre  = fdtSupply.post;        // Update pre/post variables for withdrawal checks\n        fdtSupply.post = pool.totalSupply();  // Update pre/post variables for withdrawal checks\n\n        poolLosses.pre  = poolLosses.post;      // Update pre/post variables for withdrawal checks\n        poolLosses.post = pool.poolLosses();  // Update pre/post variables for withdrawal checks\n\n        assertEq(bob_recognizableLosses.post, 0);  // After withdrawal, liz has zero unrecognized losses\n\n        assertEq(bob_usdcBal.pre,  0);  // Deposited entire balance into pool\n        assertEq(bob_usdcBal.post, 0);  // Withdrew enough just to realize losses, no USDC was transferred out of LL\n\n        assertEq(bob_usdcBal.post - bob_usdcBal.pre,  0);                                       // Bob's USDC value withdrawn did not increase\n        assertEq(bob_poolBal.pre  - bob_poolBal.post, bob_recognizableLosses.pre * WAD / 1E6);  // Bob's FDTs have been burned (doing assertion in WAD precision)\n        assertEq(fdtSupply.pre    - fdtSupply.post,   bob_recognizableLosses.pre * WAD / 1E6);  // Bob's FDTs have been burned (doing assertion in WAD precision)\n        assertEq(poolLosses.pre   - poolLosses.post,  bob_recognizableLosses.pre);              // BPT shortfall accounting has been decremented by Bob's recognized losses\n\n        assertEq(liquidityLockerBal.pre - liquidityLockerBal.post, 0);  // No USDC was transferred out of LL\n\n        /**********************************************************/\n        /*** Liquidity Provider Post-Loss Withdrawal Accounting ***/\n        /**********************************************************/\n\n        bob_usdcBal.pre = bob_usdcBal.post;  // Bob USDC bal\n        bob_poolBal.pre = bob_poolBal.post;  // Bob FDT  bal\n\n        uint256 withdrawAmt = bob_poolBal.pre * 1E6 / WAD;\n\n        make_withdrawable(liz, pool);\n\n        assertTrue(liz.try_withdraw(address(pool), withdrawAmt));  // Withdraw max amount\n\n        assertPoolAccounting(pool);\n\n        bob_usdcBal.post = IERC20(USDC).balanceOf(address(liz));  // Bob USDC bal\n        bob_poolBal.post = pool.balanceOf(address(liz));        // Bob FDT  bal\n\n        liquidityLockerBal.pre  = liquidityLockerBal.post;                  // Update pre/post variables for withdrawal checks\n        liquidityLockerBal.post = IERC20(USDC).balanceOf(liquidityLocker);  // Update pre/post variables for withdrawal checks\n\n        fdtSupply.pre  = fdtSupply.post;        // Update pre/post variables for withdrawal checks\n        fdtSupply.post = pool.totalSupply();  // Update pre/post variables for withdrawal checks\n\n        assertEq(bob_usdcBal.pre,  0);            // Deposited entire balance into pool\n        assertEq(bob_usdcBal.post, withdrawAmt);  // Withdrew enough just to realize losses, no USDC was transferred out of LL\n\n        assertEq(bob_poolBal.post, 0);  // Withdrew entire amount, so all remaining BPTs are burned\n\n        assertEq(fdtSupply.pre - fdtSupply.post, bob_poolBal.pre); // Bob's FDTs have been burned\n\n        assertEq(liquidityLockerBal.pre - liquidityLockerBal.post, withdrawAmt);  // All Bob's USDC was transferred out of LL\n    }\n} \n"
    },
    "packages/protocol/contracts/test/PoolFDTLosses.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract PoolFDTLossesTest is TestUtil {\n\n    using SafeMath for uint256;\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpActors();\n        setUpBalancerPool();\n        setUpLiquidityPools();\n        createLoans();\n    }\n\n    function createLoanForLossesAndGetDepositAmount(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio,\n        uint256 minimumRequestAmt\n    ) internal returns (Loan custom_loan, uint256 depositAmt) {\n        uint256[5] memory specs = getFuzzedSpecs(apr, index, numPayments, requestAmount, collateralRatio, (125 * minimumRequestAmt) / 100, 0, 1E7 * USD);\n        address[3] memory calcs = [address(repaymentCalc), address(lateFeeCalc), address(premiumCalc)];\n\n        custom_loan = bob.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs);\n        depositAmt  = constrictToRange(requestAmount, specs[3], 1E7 * USD, true);\n    }\n\n    function getClaimedInterestNetOfFees(uint256 interestPortionClaimed, uint256 delegateFee, uint256 stakingFee) internal pure returns (uint256 claimedInterest) {\n        uint256 fees    = interestPortionClaimed.mul(delegateFee).div(10_000);\n        fees            = fees.add(interestPortionClaimed.mul(stakingFee).div(10_000));\n        claimedInterest = interestPortionClaimed.sub(fees);\n    }\n\n    function getSplitDepositAmounts(uint256 amount, uint256 totalAmount) internal pure returns (uint256 amount1, uint256 amount2) {\n        amount1 = constrictToRange(amount, totalAmount / 1000, totalAmount, true);\n        amount2 = totalAmount - amount1;\n    }\n\n    function test_lpBearingLosses(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount\n    ) public {\n        uint256 minimumRequestAmt = PoolLib.getSwapOutValueLocker(address(bPool), USDC, address(pool.stakeLocker()));\n\n        // Create Loan with 0% CR, so no claimable funds are present after default, and a deposit amount from arguments\n        (Loan custom_loan, uint256 depositAmt) = createLoanForLossesAndGetDepositAmount(apr, index, numPayments, requestAmount, 0, minimumRequestAmt);\n\n        // Lex is putting up the funds into the Pool.\n        mintFundsAndDepositIntoPool(leo, pool, depositAmt, depositAmt);\n\n        // Fund the loan by the pool delegate.\n        pat.fundLoan(address(pool), address(custom_loan), address(dlFactory), depositAmt);\n\n        // Drawdown of the loan.\n        drawdown(custom_loan, bob, depositAmt);\n\n        // Time warp to make a payment.\n        hevm.warp(custom_loan.nextPaymentDue());\n        doPartialLoanPayment(custom_loan, bob);\n\n        // Claim the funds.\n        uint256[7] memory claimInfo = pat.claim(address(pool), address(custom_loan), address(dlFactory));\n\n        // Leo withdraws interest.\n        leo.withdrawFunds(address(pool));\n\n        // Verify the interest.\n        withinDiff(\n            getClaimedInterestNetOfFees(claimInfo[1], pool.delegateFee(), pool.stakingFee()),\n            usdc.balanceOf(address(leo)),\n            1\n        );\n\n        // Time warp to default\n        hevm.warp(custom_loan.nextPaymentDue() + globals.defaultGracePeriod() + 1);\n\n        // Setting slippage high enough to let it through the liquidations.\n        gov.setMaxSwapSlippage(7000);\n\n        // Pool Delegate trigger a default\n        pat.triggerDefault(address(pool), address(custom_loan), address(dlFactory));\n        \n        // Check for successful default.\n        assertTrue(uint8(custom_loan.loanState()) == 4, \"Unexpected Loan state\");\n\n        // PD claims funds and also sells the stake to recover the losses.\n        claimInfo = pat.claim(address(pool), address(custom_loan), address(dlFactory));\n        \n        assertTrue(claimInfo[6] > 0, \"Loan doesn't have default suffered\");\n\n        uint256 poolLosses = pool.poolLosses();\n        assertTrue(poolLosses > 0, \"Pool losses should be greater than 0\");\n        withinDiff(pool.recognizableLossesOf(address(leo)), poolLosses, 1);\n\n        // Time warp to past lockup to remove lockup transfer restriction\n        hevm.warp(block.timestamp + pool.lockupPeriod() + 1);\n\n        // Fails to transfer if the losses are > 0.\n        assertTrue(\n            !leo.try_transfer(address(pool), address(leo), 1),\n            \"Should not be allowed to transfer because losses are > 0\"\n        );\n\n        // Intend to withdraw and warp to withdraw window\n        leo.intendToWithdraw(address(pool));\n        hevm.warp(block.timestamp + globals.lpCooldownPeriod() + 1);\n\n        // Before withdrawing funds.\n        uint256 old_lex_bal = usdc.balanceOf(address(leo));\n\n        // Withdrawing half should be sufficient to recognize all the losses\n        leo.withdraw(address(pool), depositAmt - 1);\n\n        withinDiff(usdc.balanceOf(address(leo)) - old_lex_bal, depositAmt - poolLosses - 1, 1);\n\n        assertTrue(\n            leo.try_transfer(address(pool), address(liz), 1 * (WAD / USD)),\n            \"Should be allowed to transfer because losses recognized\"\n        );\n\n        assertEq(pool.balanceOf(address(liz)), 1 * (WAD / USD), \"Liz should have 1 FDT\");\n    }\n\n    function test_multipleLpBearingLossesWithMultiplePools(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 leoDepositAmt,\n        uint256 lexDepositAmt\n    ) public {\n        uint256 minDepositAmountForPool1 = PoolLib.getSwapOutValueLocker(address(bPool), USDC, address(pool.stakeLocker()));\n        uint256 minDepositAmountForPool2 = PoolLib.getSwapOutValueLocker(address(bPool), USDC, address(pool2.stakeLocker()));\n\n        // Create Loan and a deposit amount from arguments\n        (Loan custom_loan, uint256 totalDepositAmt) = createLoanForLossesAndGetDepositAmount(apr, index, numPayments, requestAmount, 0, minDepositAmountForPool1 + minDepositAmountForPool2);\n\n        uint256 lizDepositAmt;\n        (leoDepositAmt, lizDepositAmt) = getSplitDepositAmounts(leoDepositAmt, (minDepositAmountForPool1 * totalDepositAmt) / (minDepositAmountForPool1 + minDepositAmountForPool2));\n\n        uint256 leeDepositAmt;\n        (lexDepositAmt, leeDepositAmt) = getSplitDepositAmounts(lexDepositAmt, totalDepositAmt - leoDepositAmt - lizDepositAmt);\n\n        // LPs is putting up the funds into the Pool.\n        mintFundsAndDepositIntoPool(leo, pool,  leoDepositAmt, leoDepositAmt);\n        mintFundsAndDepositIntoPool(liz, pool,  lizDepositAmt, lizDepositAmt);\n        mintFundsAndDepositIntoPool(lex, pool2, lexDepositAmt, lexDepositAmt);\n        mintFundsAndDepositIntoPool(lee, pool2, leeDepositAmt, leeDepositAmt);\n\n        // Fund the loan by both pool delegates.\n        pat.fundLoan(address(pool),  address(custom_loan), address(dlFactory), usdc.balanceOf(pool.liquidityLocker()));\n        pam.fundLoan(address(pool2), address(custom_loan), address(dlFactory), usdc.balanceOf(pool2.liquidityLocker()));\n\n        // Drawdown of the loan\n        drawdown(custom_loan, bob, totalDepositAmt);\n\n        // Time warp to make a payment\n        hevm.warp(custom_loan.nextPaymentDue());\n        doPartialLoanPayment(custom_loan, bob);\n\n        {\n            // Claim the funds.\n            uint256[7] memory claimInfo1 = pat.claim(address(pool),  address(custom_loan), address(dlFactory));\n            uint256[7] memory claimInfo2 = pam.claim(address(pool2), address(custom_loan), address(dlFactory));\n\n            // Withdraw interest by the lps.\n            leo.withdrawFunds(address(pool));\n            liz.withdrawFunds(address(pool));\n            lex.withdrawFunds(address(pool2));\n            lee.withdrawFunds(address(pool2));\n\n            // Verify the interest.\n            withinDiff(\n                getClaimedInterestNetOfFees(claimInfo1[1], pool.delegateFee(), pool.stakingFee()),\n                usdc.balanceOf(address(leo)) + usdc.balanceOf(address(liz)),\n                1\n            );\n            \n            withinDiff(\n                getClaimedInterestNetOfFees(claimInfo2[1], pool2.delegateFee(), pool2.stakingFee()),\n                usdc.balanceOf(address(lex)) + usdc.balanceOf(address(lee)),\n                1\n            );\n\n            // Time warp to default\n            hevm.warp(custom_loan.nextPaymentDue() + globals.defaultGracePeriod() + 1);\n\n            // Setting slippage high enough to let it through the liquidations.\n            gov.setMaxSwapSlippage(7000);\n\n            // At least one of the pool delegates should be able to trigger a default\n            assertTrue(\n                pat.try_triggerDefault(address(pool),  address(custom_loan), address(dlFactory)) ||\n                pam.try_triggerDefault(address(pool2), address(custom_loan), address(dlFactory)),\n                \"Should be able to trigger Loan default\"\n            );\n            \n            // Check for successful default.\n            assertTrue(uint8(custom_loan.loanState()) == 4, \"Unexpected Loan state\");\n\n            claimInfo1 = pat.claim(address(pool),  address(custom_loan), address(dlFactory));\n            claimInfo2 = pam.claim(address(pool2), address(custom_loan), address(dlFactory));\n\n            assertTrue(claimInfo1[6]     > 0,     \"Loan doesn't have default suffered\");\n            assertTrue(pool.poolLosses() > 0, \"Pool 1 losses should be greater than 0\");\n            withinDiff(pool.recognizableLossesOf(address(leo)) + pool.recognizableLossesOf(address(liz)),  pool.poolLosses(), 1);\n\n            assertTrue(claimInfo2[6]      > 0,     \"Loan doesn't have default suffered\");\n            assertTrue(pool2.poolLosses() > 0, \"Pool 2 losses should be greater than 0\");\n            withinDiff(pool2.recognizableLossesOf(address(lex)) + pool2.recognizableLossesOf(address(lee)), pool2.poolLosses(), 1);\n        }\n\n        // Time warp to past lockup to remove lockup transfer restriction\n        hevm.warp(block.timestamp + pool.lockupPeriod() + 1);\n\n        // Fails to transfer if the losses are > 0.\n        assertTrue(\n            !leo.try_transfer(address(pool), address(liz), 1),\n            \"Should not allow Lex to transfer because losses are > 0\"\n        );\n\n        assertTrue(\n            !liz.try_transfer(address(pool), address(leo), 1),\n            \"Should not allow Lee to transfer because losses are > 0\"\n        );\n\n        assertTrue(\n            !lex.try_transfer(address(pool2), address(lee), 1),\n            \"Should not allow Leo to transfer because losses are > 0\"\n        );\n\n        assertTrue(\n            !lee.try_transfer(address(pool2), address(lex), 1),\n            \"Should not allow Liz to transfer because losses are > 0\"\n        );\n\n        // LPs is withdrawing funds from the Pool with losses.\n        leo.intendToWithdraw(address(pool));\n        liz.intendToWithdraw(address(pool));\n        lex.intendToWithdraw(address(pool2));\n        lee.intendToWithdraw(address(pool2));\n\n        // Time warp to withdraw window\n        hevm.warp(block.timestamp + globals.lpCooldownPeriod() + 1);\n\n        // Before withdrawing funds.\n        uint256 old_leo_bal = usdc.balanceOf(address(leo));\n        uint256 old_liz_bal = usdc.balanceOf(address(liz));\n        uint256 old_lex_bal = usdc.balanceOf(address(lex));\n        uint256 old_lee_bal = usdc.balanceOf(address(lee));\n\n        leo.withdraw(address(pool),  leoDepositAmt - 1);\n        liz.withdraw(address(pool),  lizDepositAmt - 1);\n        lex.withdraw(address(pool2), lexDepositAmt - 1);\n        lee.withdraw(address(pool2), leeDepositAmt - 1);\n\n        assertEq(pool.balanceOf(address(leo)),  1 * (WAD / USD), \"Leo should have 1 FDTs\");\n        assertEq(pool.balanceOf(address(liz)),  1 * (WAD / USD), \"Liz should have 1 FDTs\");\n        assertEq(pool2.balanceOf(address(lex)), 1 * (WAD / USD), \"Lex should have 1 FDTs\");\n        assertEq(pool2.balanceOf(address(lex)), 1 * (WAD / USD), \"Lee should have 1 FDTs\");\n\n        withinDiff(usdc.balanceOf(address(leo)) - old_leo_bal, leoDepositAmt - pool.recognizedLossesOf(address(leo)) - 1,  1);\n        withinDiff(usdc.balanceOf(address(liz)) - old_liz_bal, lizDepositAmt - pool.recognizedLossesOf(address(liz)) - 1,  1);\n        withinDiff(usdc.balanceOf(address(lex)) - old_lex_bal, lexDepositAmt - pool2.recognizedLossesOf(address(lex)) - 1, 1);\n        withinDiff(usdc.balanceOf(address(lee)) - old_lee_bal, leeDepositAmt - pool2.recognizedLossesOf(address(lee)) - 1, 1);\n\n        // Leo transfers 1 Pool1 FDT to Lex (who is not in a Pool1 withdrawal window)\n        assertTrue(\n            leo.try_transfer(address(pool), address(lex), 1 * (WAD / USD)),\n            \"Should allow Leo to transfer because losses recognized\"\n        );\n\n        // Lex transfers 1 Pool2 FDT to Leo (who is not in a Pool2 withdrawal window)\n        assertTrue(\n            lex.try_transfer(address(pool2), address(leo), 1 * (WAD / USD)),\n            \"Should allow Lex to transfer because losses recognized\"\n        );\n\n        assertEq(pool.balanceOf(address(lex)),  1 * (WAD / USD), \"Lex should have 1 Pool1 FDTs\");\n        assertEq(pool2.balanceOf(address(leo)), 1 * (WAD / USD), \"Leo should have 1 Pool2 FDTs\");\n\n        // Lez transfers 1 Pool1 FDT to Lee (who is not in a Pool1 withdrawal window)\n        assertTrue(\n            liz.try_transfer(address(pool), address(lee), 1 * (WAD / USD)),\n            \"Should allow Liz to transfer because losses recognized\"\n        );\n\n        // Lee transfers 1 Pool2 FDT to Liz (who is not in a Pool2 withdrawal window)\n        assertTrue(\n            lee.try_transfer(address(pool2), address(liz), 1 * (WAD / USD)),\n            \"Should allow Lee to transfer because losses recognized\"\n        );\n\n        assertEq(pool.balanceOf(address(lee)),  1 * (WAD / USD), \"Lee should have 1 Pool1 FDTs\");\n        assertEq(pool2.balanceOf(address(liz)), 1 * (WAD / USD), \"Liz should have 1 Pool2 FDTs\");\n    }\n\n}\n"
    },
    "packages/protocol/contracts/test/PoolFactory.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract PoolFactoryTest is TestUtil {\n\n    function setUp() public {\n        setUpGlobals();\n        setUpPoolDelegate();\n        setUpTokens();\n        setUpFactories();\n        setUpOracles();\n        setUpBalancerPool();\n    }\n\n    function test_setGlobals() public {\n        MapleGlobals globals2 = fakeGov.createGlobals(address(mpl));                   // Create upgraded MapleGlobals\n\n        assertEq(address(poolFactory.globals()), address(globals));\n\n        assertTrue(!fakeGov.try_setGlobals(address(poolFactory), address(globals2)));  // Non-governor cannot set new globals\n\n        globals2 = gov.createGlobals(address(mpl));                                    // Create upgraded MapleGlobals\n\n        assertTrue(gov.try_setGlobals(address(poolFactory), address(globals2)));       // Governor can set new globals\n        assertEq(address(poolFactory.globals()), address(globals2));                   // Globals is updated\n    }\n\n    function createPoolFails() internal returns (bool) {\n        return !pat.try_createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),  // Passing in address of pool delegate for StakeAsset, an EOA which should fail isBPool check.\n            address(slFactory),\n            address(llFactory),\n            500,\n            100,\n            MAX_UINT\n        );\n    }\n\n    function test_createPool_globals_validations() public {\n\n        gov.setValidPoolFactory(address(poolFactory), true);\n\n        // PoolFactory:INVALID_LL_FACTORY\n        gov.setValidSubFactory(address(poolFactory), address(llFactory), false);\n        assertTrue(createPoolFails());\n        gov.setValidSubFactory(address(poolFactory), address(llFactory), true);\n\n        // PoolFactory:INVALID_SL_FACTORY\n        gov.setValidSubFactory(address(poolFactory), address(slFactory), false);\n        assertTrue(createPoolFails());\n        gov.setValidSubFactory(address(poolFactory), address(slFactory), true);\n\n        // PoolFactory:MSG_SENDER_NOT_ALLOWED\n        gov.setPoolDelegateAllowlist(address(pat), false);\n        assertTrue(createPoolFails());\n        gov.setPoolDelegateAllowlist(address(pat), true);\n\n        // PoolFactory:LIQ_ASSET_NOT_ALLOWED\n        gov.setLiquidityAsset(USDC, false);\n        assertTrue(createPoolFails());\n        gov.setLiquidityAsset(USDC, true);\n    }\n\n    function test_createPool_bad_stakeAsset() public {\n\n        // PoolFactory:STAKE_ASSET_NOT_BPOOL\n        assertTrue(!pat.try_createPool(\n            address(poolFactory),\n            USDC,\n            address(pat),  // Passing in address of pool delegate for StakeAsset, an EOA which should fail isBPool check.\n            address(slFactory),\n            address(llFactory),\n            500,\n            100,\n            MAX_UINT\n        ));\n    }\n\n    function test_createPool_wrong_staking_pair_asset() public {\n\n        gov.setLiquidityAsset(DAI, true);\n\n        // Pool:Pool:INVALID_STAKING_POOL\n        assertTrue(!pat.try_createPool(\n            address(poolFactory),\n            DAI,\n            address(bPool),    // This pool uses MPL/USDC, so it can't cover DAI losses\n            address(slFactory),\n            address(llFactory),\n            500,\n            100,\n            MAX_UINT\n        ));\n    }\n\n    // Tests failure mode in createStakeLocker\n    function test_createPool_createStakeLocker_no_mpl_token() public {\n\n        mint(\"USDC\", address(this), 50_000_000 * 10 ** 6);\n        mint(\"DAI\", address(this), 50_000_000 ether);\n\n        // Initialize USDC/USDC Balancer pool (Doesn't include mpl)\n        bPool = IBPool(IBFactory(BPOOL_FACTORY).newBPool());\n\n        IERC20(DAI).approve(address(bPool), uint256(-1));\n        IERC20(USDC).approve(address(bPool), uint256(-1));\n\n        bPool.bind(USDC, 50_000_000 * 10 ** 6, 5 * WAD);  // Bind 50m   DAI with 5 denormalization weight\n        bPool.bind(DAI,  50_000_000 * WAD,     5 * WAD);  // Bind 100k USDC with 5 denormalization weight\n\n        assertEq(IERC20(USDC).balanceOf(address(bPool)), 50_000_000 * 10 ** 6);\n        assertEq(IERC20(DAI).balanceOf(address(bPool)),  50_000_000 * WAD);\n        bPool.finalize();\n\n        assertTrue(!pat.try_createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),\n            address(slFactory),\n            address(llFactory),\n            500,\n            100,\n            MAX_UINT\n        ));\n    }\n\n    function test_createPool_invalid_fees() public {\n\n        // PoolLib:INVALID_FEES\n        assertTrue(!pat.try_createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),\n            address(slFactory),\n            address(llFactory),\n            5000,  // 50.00%\n            5001,  // 50.01%\n            MAX_UINT\n        ));\n\n        assertTrue(pat.try_createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),\n            address(slFactory),\n            address(llFactory),\n            5000,  // 50.00%\n            5000,  // 50.00%\n            MAX_UINT\n        ));\n    }\n\n    // Tests failure mode in createStakeLocker\n    function test_createPool_createStakeLocker_bPool_not_finalized() public {\n\n        bPool = IBPool(IBFactory(BPOOL_FACTORY).newBPool());\n        mint(\"USDC\", address(this), 50_000_000 * USD);\n        usdc.approve(address(bPool), MAX_UINT);\n        mpl.approve(address(bPool),  MAX_UINT);\n        bPool.bind(USDC,         50_000_000 * USD, 5 ether);  // Bind 50m USDC with 5 denormalization weight\n        bPool.bind(address(mpl),    100_000 * WAD, 5 ether);  // Bind 100k MPL with 5 denormalization weight\n\n        // Pool:INVALID_BALANCER_POOL\n        assertTrue(!pat.try_createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),\n            address(slFactory),\n            address(llFactory),\n            500,\n            100,\n            MAX_UINT\n        ));\n    }\n\n    function test_createPool_paused() public {\n\n        // Pause PoolFactory and attempt createPool()\n        assertTrue( gov.try_pause(address(poolFactory)));\n        assertTrue(!pat.try_createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),\n            address(slFactory),\n            address(llFactory),\n            500,\n            100,\n            MAX_UINT\n        ));\n        assertEq(poolFactory.poolsCreated(), 0);\n\n        // Unpause PoolFactory and createPool()\n        assertTrue(gov.try_unpause(address(poolFactory)));\n        assertTrue(pat.try_createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),\n            address(slFactory),\n            address(llFactory),\n            500,\n            100,\n            MAX_UINT\n        ));\n        assertEq(poolFactory.poolsCreated(), 1);\n\n        // Pause protocol and attempt createPool()\n        assertTrue(!globals.protocolPaused());\n        assertTrue( emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),\n            address(slFactory),\n            address(llFactory),\n            500,\n            100,\n            MAX_UINT\n        ));\n        assertEq(poolFactory.poolsCreated(), 1);\n\n        // Unpause protocol and createPool()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pat.try_createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),\n            address(slFactory),\n            address(llFactory),\n            500,\n            100,\n            MAX_UINT\n        ));\n        assertEq(poolFactory.poolsCreated(), 2);\n    }\n\n    function test_createPool_overflow() public {\n\n        assertTrue(!pat.try_createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),\n            address(slFactory),\n            address(llFactory),\n            500,\n            MAX_UINT,\n            MAX_UINT\n        ));\n        assertEq(poolFactory.poolsCreated(), 0);\n    }\n\n    function test_createPool() public {\n\n        assertTrue(pat.try_createPool(\n            address(poolFactory),\n            USDC,\n            address(bPool),\n            address(slFactory),\n            address(llFactory),\n            500,\n            100,\n            MAX_UINT\n        ));\n\n        Pool pool = Pool(poolFactory.pools(0));\n\n        assertTrue(address(pool) != address(0));\n        assertTrue(poolFactory.isPool(address(pool)));\n        assertEq(poolFactory.poolsCreated(), 1);\n\n        assertEq(address(pool.liquidityAsset()),  USDC);\n        assertEq(pool.stakeAsset(),               address(bPool));\n        assertEq(pool.poolDelegate(),             address(pat));\n        assertEq(pool.stakingFee(),               500);\n        assertEq(pool.delegateFee(),              100);\n        assertEq(pool.liquidityCap(),             MAX_UINT);\n\n        assertTrue(pool.stakeLocker()     != address(0));\n        assertTrue(pool.liquidityLocker() != address(0));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/PoolExcess.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract PoolExcessTest is TestUtil {\n\n    using SafeMath for uint256;\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpActors();\n        setUpBalancerPoolForPools();\n        setUpLiquidityPools();\n        createLoan();\n    }\n\n    function setUpLoan() public {\n        // Fund the pool\n        mint(\"USDC\", address(leo), 20_000_000 * USD);\n        leo.approve(USDC, address(pool), MAX_UINT);\n        leo.approve(USDC, address(pool2), MAX_UINT);\n        leo.deposit(address(pool), 10_000_000 * USD);\n        leo.deposit(address(pool2), 10_000_000 * USD);\n\n        // Fund the loan\n        pat.fundLoan(address(pool), address(loan), address(dlFactory), 1_000_000 * USD);\n        pam.fundLoan(address(pool2), address(loan), address(dlFactory), 3_000_000 * USD);\n    }\n\n    function test_unwind_loan_reclaim() public {\n\n        setUpLoan();\n\n        // Warp and call unwind()\n        hevm.warp(loan.createdAt() + globals.fundingPeriod() + 1);\n        assertTrue(bob.try_unwind(address(loan)));\n\n        uint256 principalOut_a_pre = pool.principalOut();\n        uint256 principalOut_b_pre = pool2.principalOut();\n        uint256 llBalance_a_pre = IERC20(pool.liquidityAsset()).balanceOf(pool.liquidityLocker());\n        uint256 llBalance_b_pre = IERC20(pool2.liquidityAsset()).balanceOf(pool2.liquidityLocker());\n\n        // Claim unwind() excessReturned\n        uint256[7] memory vals_a = pat.claim(address(pool), address(loan),  address(dlFactory));\n        uint256[7] memory vals_b = pam.claim(address(pool2), address(loan),  address(dlFactory));\n\n        uint256 principalOut_a_post = pool.principalOut();\n        uint256 principalOut_b_post = pool2.principalOut();\n        uint256 llBalance_a_post = IERC20(pool.liquidityAsset()).balanceOf(pool.liquidityLocker());\n        uint256 llBalance_b_post = IERC20(pool2.liquidityAsset()).balanceOf(pool2.liquidityLocker());\n\n        assertEq(principalOut_a_pre - principalOut_a_post, vals_a[4]);\n        assertEq(principalOut_b_pre - principalOut_b_post, vals_b[4]);\n        assertEq(llBalance_a_post - llBalance_a_pre, vals_a[4]);\n        assertEq(llBalance_b_post - llBalance_b_pre, vals_b[4]);\n\n        // pool invested 1mm USD\n        // pool2 invested 3mm USD\n        withinDiff(principalOut_a_pre - principalOut_a_post, 1_000_000 * USD, 1);\n        withinDiff(principalOut_b_pre - principalOut_b_post, 3_000_000 * USD, 1);\n    }\n}\n"
    },
    "packages/protocol/contracts/test/PoolDelegate.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract PoolTest is TestUtil {\n\n    using SafeMath for uint256;\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpActors();\n        setUpBalancerPool();\n        createLiquidityPools();\n        createLoans();\n    }\n    \n    function test_getInitialStakeRequirements(uint256 newSwapOutRequired) public {\n        newSwapOutRequired = constrictToRange(newSwapOutRequired, 10_000, 500_000, true);\n        gov.setSwapOutRequired(newSwapOutRequired);\n\n        uint256 minCover; uint256 minCover2; uint256 curCover;\n        uint256 minStake; uint256 minStake2; uint256 curStake;\n        bool covered;\n\n        /*****************************************/\n        /*** Approve StakeLocker To Take BPTs ***/\n        /*****************************************/\n        pat.approve(address(bPool), pool.stakeLocker(), MAX_UINT);\n\n        uint256 patBptBalance = bPool.balanceOf(address(pat));\n\n        // Pre-state checks.\n        assertBalanceState(pool.stakeLocker(), patBptBalance, 0, 0);\n        \n        (,,, minStake,) = pool.getInitialStakeRequirements();\n        // Mint the minStake to PD\n        if (minStake > patBptBalance) { \n            transferMoreBpts(address(pat), minStake - patBptBalance);\n            patBptBalance = minStake;\n        }\n\n        (minCover, curCover, covered, minStake, curStake) = pool.getInitialStakeRequirements();\n        {\n            (uint256 calc_minStake, uint256 calc_stakerBal) = pool.getPoolSharesRequired(address(bPool), USDC, address(pat), pool.stakeLocker(), minCover);\n\n            assertEq(minCover, globals.swapOutRequired() * USD);                     // Equal to globally specified value\n            assertEq(curCover, 0);                                                   // Nothing staked\n            assertTrue(!covered);                                                    // Not covered\n            assertEq(minStake, calc_minStake);                                       // Minimum stake equals calculated minimum stake     \n            assertEq(curStake, calc_stakerBal);                                      // Current stake equals calculated stake\n            assertEq(curStake, IERC20(pool.stakeLocker()).balanceOf(address(pat)));  // Current stake equals balance of StakeLockerFDTs\n        }\n\n        /***************************************/\n        /*** Stake Less than Required Amount ***/\n        /***************************************/\n        pat.stake(pool.stakeLocker(), minStake - 1);\n\n        // Post-state checks.\n        assertBalanceState(pool.stakeLocker(), patBptBalance - (minStake - 1), (minStake - 1), (minStake - 1));\n\n        (minCover2, curCover, covered, minStake2, curStake) = pool.getInitialStakeRequirements();\n        {\n            (, uint256 calc_stakerBal) = pool.getPoolSharesRequired(address(bPool), USDC, address(pat), pool.stakeLocker(), minCover);\n\n            assertEq(minCover2, minCover);                                           // Doesn't change\n            assertTrue(curCover <= minCover);                                        // Not enough cover\n            assertTrue(!covered);                                                    // Not covered\n            assertEq(minStake2, minStake);                                           // Doesn't change\n            assertEq(curStake, calc_stakerBal);                                      // Current stake equals calculated stake\n            assertEq(curStake, IERC20(pool.stakeLocker()).balanceOf(address(pat)));  // Current stake equals balance of StakeLockerFDTs\n        }\n\n        /***********************************/\n        /*** Stake Exact Required Amount ***/\n        /***********************************/\n        pat.stake(pool.stakeLocker(), 1); // Add one more wei of BPT to get to minStake amount\n\n        // Post-state checks.\n        assertBalanceState(pool.stakeLocker(), patBptBalance - minStake, minStake, minStake);\n\n        (minCover2, curCover, covered, minStake2, curStake) = pool.getInitialStakeRequirements();\n\n        (, uint256 calc_stakerBal) = pool.getPoolSharesRequired(address(bPool), USDC, address(pat), pool.stakeLocker(), minCover);\n\n        assertEq(minCover2, minCover);                                           // Doesn't change\n        withinPrecision(curCover, minCover, 6);                                  // Roughly enough\n        assertTrue(covered);                                                     // Covered\n        assertEq(minStake2, minStake);                                           // Doesn't change\n        assertEq(curStake, calc_stakerBal);                                      // Current stake equals calculated stake\n        assertEq(curStake, IERC20(pool.stakeLocker()).balanceOf(address(pat)));  // Current stake equals balance of StakeLockerFDTs\n    }\n\n    function test_stake_and_finalize() public {\n\n        /*****************************************/\n        /*** Approve StakeLocker To Take BPTs ***/\n        /*****************************************/\n        address stakeLocker = pool.stakeLocker();\n        pat.approve(address(bPool), stakeLocker, uint256(-1));\n\n        // Pre-state checks.\n        assertBalanceState(stakeLocker, 50 * WAD, 0, 0);\n\n        /***************************************/\n        /*** Stake Less than Required Amount ***/\n        /***************************************/\n        (,,, uint256 minStake,) = pool.getInitialStakeRequirements();\n        pat.stake(pool.stakeLocker(), minStake - 1);\n\n        // Post-state checks.\n        assertBalanceState(stakeLocker, 50 * WAD - (minStake - 1), minStake - 1, minStake - 1);\n\n        assertTrue(!pat.try_finalize(address(pool)));  // Can't finalize\n\n        /***********************************/\n        /*** Stake Exact Required Amount ***/\n        /***********************************/\n        pat.stake(stakeLocker, 1); // Add one more wei of BPT to get to minStake amount\n\n        // Post-state checks.\n        assertBalanceState(stakeLocker, 50 * WAD - minStake, minStake, minStake);\n        assertEq(uint256(pool.poolState()), 0);  // Initialized\n\n        assertTrue(!pam.try_finalize(address(pool)));  // Can't finalize if not PD\n\n        // Pause protocol and attempt finalize()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_finalize(address(pool)));\n        \n        // Unpause protocol and finalize()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pat.try_finalize(address(pool)));  // PD that staked can finalize\n\n        assertEq(uint256(pool.poolState()), 1);  // Finalized\n    }\n\n    function test_setLockupPeriod() public {\n        assertEq(  pool.lockupPeriod(), 180 days);\n        assertTrue(!pam.try_setLockupPeriod(address(pool), 15 days));       // Cannot set lockup period if not pool delegate\n        assertTrue(!pat.try_setLockupPeriod(address(pool), 180 days + 1));  // Cannot increase lockup period\n        assertTrue( pat.try_setLockupPeriod(address(pool), 180 days));      // Can set the same lockup period\n        assertTrue( pat.try_setLockupPeriod(address(pool), 180 days - 1));  // Can decrease lockup period\n        assertEq(pool.lockupPeriod(), 180 days - 1);\n        assertTrue(!pat.try_setLockupPeriod(address(pool), 180 days));      // Cannot increase lockup period\n\n        // Pause protocol and attempt setLockupPeriod()\n        assertTrue( emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_setLockupPeriod(address(pool), 180 days - 2));\n        assertEq(pool.lockupPeriod(), 180 days - 1);\n\n        // Unpause protocol and setLockupPeriod()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pat.try_setLockupPeriod(address(pool), 180 days - 2));\n        assertEq(pool.lockupPeriod(), 180 days - 2);\n    }\n\n    function test_fundLoan(uint256 depositAmt, uint256 fundAmt) public {\n        address stakeLocker   = pool.stakeLocker();\n        address liqLocker     = pool.liquidityLocker();\n        address fundingLocker = loan.fundingLocker();\n\n        // Finalize the Pool\n        finalizePool(pool, pat, true);\n\n        depositAmt = constrictToRange(depositAmt, loan.requestAmount(), loan.requestAmount() + 1000 * USD, true);\n        fundAmt    = constrictToRange(fundAmt, 1 * USD, depositAmt, true); \n\n        // Mint funds and deposit to Pool.\n        mintFundsAndDepositIntoPool(leo, pool, depositAmt, depositAmt);\n\n        gov.setValidLoanFactory(address(loanFactory), false);\n\n        assertTrue(!pat.try_fundLoan(address(pool), address(loan), address(dlFactory), depositAmt)); // LoanFactory not in globals\n\n        gov.setValidLoanFactory(address(loanFactory), true);\n\n        assertEq(usdc.balanceOf(liqLocker),               depositAmt);  // Balance of LiquidityLocker\n        assertEq(usdc.balanceOf(address(fundingLocker)),           0);  // Balance of FundingLocker\n        \n        /*******************/\n        /*** Fund a Loan ***/\n        /*******************/\n\n        // Pause protocol and attempt fundLoan()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_fundLoan(address(pool), address(loan), address(dlFactory), fundAmt));\n\n        // Unpause protocol and fundLoan()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pat.try_fundLoan(address(pool), address(loan), address(dlFactory), fundAmt), \"Fail to fund a loan\");  // Fund loan for 20 USDC\n\n        DebtLocker debtLocker = DebtLocker(pool.debtLockers(address(loan), address(dlFactory)));\n\n        assertEq(address(debtLocker.loan()),           address(loan));\n        assertEq(debtLocker.pool(),                    address(pool));\n        assertEq(address(debtLocker.liquidityAsset()), USDC);\n\n        assertEq(usdc.balanceOf(liqLocker),                    depositAmt - fundAmt);  // Balance of LiquidityLocker\n        assertEq(usdc.balanceOf(address(fundingLocker)),                    fundAmt);  // Balance of FundingLocker\n        assertEq(IERC20(loan).balanceOf(address(debtLocker)),        toWad(fundAmt));  // LoanFDT balance of DebtLocker\n        assertEq(pool.principalOut(),                                       fundAmt);  // Outstanding principal in liquidity pool 1\n\n        /****************************************/\n        /*** Fund same loan with the same DL ***/\n        /****************************************/\n        uint256 newFundAmt = constrictToRange(fundAmt, 1 * USD, depositAmt - fundAmt, true);\n        assertTrue(pat.try_fundLoan(address(pool), address(loan), address(dlFactory), newFundAmt)); // Fund same loan for newFundAmt\n\n        assertEq(dlFactory.owner(address(debtLocker)), address(pool));\n        assertTrue(dlFactory.isLocker(address(debtLocker)));\n\n        assertEq(usdc.balanceOf(liqLocker),                    depositAmt - fundAmt - newFundAmt);  // Balance of LiquidityLocker\n        assertEq(usdc.balanceOf(address(fundingLocker)),                    fundAmt + newFundAmt);  // Balance of FundingLocker\n        assertEq(IERC20(loan).balanceOf(address(debtLocker)),        toWad(fundAmt + newFundAmt));  // LoanFDT balance of DebtLocker\n        assertEq(pool.principalOut(),                                       fundAmt + newFundAmt);  // Outstanding principal in liquidity pool 1\n\n        /*******************************************/\n        /*** Fund same loan with a different DL ***/\n        /*******************************************/\n        uint256 newFundAmt2 = constrictToRange(fundAmt, 1 * USD, depositAmt - fundAmt - newFundAmt, true);\n        assertTrue(pat.try_fundLoan(address(pool), address(loan), address(dlFactory2), newFundAmt2)); // Fund loan for 15 USDC\n\n        DebtLocker debtLocker2 = DebtLocker(pool.debtLockers(address(loan),  address(dlFactory2)));\n\n        assertEq(address(debtLocker2.loan()),           address(loan));\n        assertEq(debtLocker2.pool(),                    address(pool));\n        assertEq(address(debtLocker2.liquidityAsset()), USDC);\n\n        assertEq(dlFactory2.owner(address(debtLocker2)), address(pool));\n        assertTrue(dlFactory2.isLocker(address(debtLocker2)));\n\n        assertEq(usdc.balanceOf(liqLocker),                    depositAmt - fundAmt - newFundAmt - newFundAmt2);  // Balance of LiquidityLocker\n        assertEq(usdc.balanceOf(address(fundingLocker)),                    fundAmt + newFundAmt + newFundAmt2);  // Balance of FundingLocker\n        assertEq(IERC20(loan).balanceOf(address(debtLocker2)),                              toWad(newFundAmt2));  // LoanFDT balance of DebtLocker 2\n        assertEq(pool.principalOut(),                                       fundAmt + newFundAmt + newFundAmt2);  // Outstanding principal in liquidity pool 1\n    }\n\n    function test_deactivate() public {\n\n        /*******************************/\n        /*** Finalize liquidity pool ***/\n        /*******************************/\n        \n        finalizePool(pool, pat, true);\n\n        address liquidityAsset         = address(pool.liquidityAsset());\n        uint256 liquidityAssetDecimals = IERC20Details(liquidityAsset).decimals();\n\n        // Pre-state checks.\n        assertTrue(pool.principalOut() <= 100 * 10 ** liquidityAssetDecimals);\n\n        // Pause protocol and attempt deactivate()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_deactivate(address(pool)));\n\n        // Unpause protocol and deactivate()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pat.try_deactivate(address(pool)));\n\n        // Post-state checks.\n        assertEq(int(pool.poolState()), 2);\n\n        // Deactivation should block the following functionality:\n\n        // deposit()\n        mint(\"USDC\", address(leo), 1_000_000_000 * USD);\n        leo.approve(USDC, address(pool), uint256(-1));\n        assertTrue(!leo.try_deposit(address(pool), 100_000_000 * USD));\n\n        // fundLoan()\n        assertTrue(!pat.try_fundLoan(address(pool), address(loan), address(dlFactory), 1));\n\n        // deactivate()\n        assertTrue(!pat.try_deactivate(address(pool)));\n\n    }\n\n    function test_deactivate_fail(uint256 depositAmt, uint256 fundAmt) public {\n\n        /*******************************/\n        /*** Finalize liquidity pool ***/\n        /*******************************/\n        \n        finalizePool(pool, pat, true);\n        \n        /**************************************************/\n        /*** Mint and deposit funds into liquidity pool ***/\n        /**************************************************/\n\n        depositAmt = constrictToRange(depositAmt, loan.requestAmount(), loan.requestAmount() + 100_000_000 * USD, true);\n        fundAmt    = constrictToRange(fundAmt, 101 * USD, depositAmt, true); \n\n        mintFundsAndDepositIntoPool(leo, pool, loan.requestAmount() + 100_000_000 * USD, depositAmt);\n\n        /************************************/\n        /*** Fund loan / loan2 (Excess) ***/\n        /************************************/\n        \n        assertTrue(pat.try_fundLoan(address(pool), address(loan),  address(dlFactory2), fundAmt));\n\n        address liquidityAsset         = address(pool.liquidityAsset());\n        uint256 liquidityAssetDecimals = IERC20Details(liquidityAsset).decimals();\n\n        // Pre-state checks.\n        assertTrue(pool.principalOut() >= 100 * 10 ** liquidityAssetDecimals);\n        assertTrue(!pat.try_deactivate(address(pool)));\n    }\n\n    function test_reclaim_erc20(uint256 mintedUsdc, uint256 mintedDai, uint256 mintedWeth) external {\n        // Transfer different assets into the Pool\n\n        mintedUsdc = constrictToRange(mintedUsdc, 500 * USD, 1_000_000 * USD, true);\n        mintedDai  = constrictToRange(mintedDai,  500 * WAD, 1_000_000 * WAD, true);\n        mintedWeth = constrictToRange(mintedWeth, 500 * WAD, 1_000_000 * WAD, true);\n\n        mint(\"USDC\", address(pool), mintedUsdc);\n        mint(\"DAI\",  address(pool), mintedDai);\n        mint(\"WETH\", address(pool), mintedWeth);\n\n        Governor fakeGov = new Governor();\n\n        uint256 beforeBalanceDAI  = IERC20(DAI).balanceOf(address(gov));\n        uint256 beforeBalanceWETH = IERC20(WETH).balanceOf(address(gov));\n\n        assertTrue(!fakeGov.try_reclaimERC20(address(pool), DAI));\n        assertTrue(    !gov.try_reclaimERC20(address(pool), USDC));  // Can't claim the USDC from the Pool as it is liquidityAsset of the Pool.\n        assertTrue(    !gov.try_reclaimERC20(address(pool), address(0)));\n        assertTrue(     gov.try_reclaimERC20(address(pool), DAI));\n        assertTrue(     gov.try_reclaimERC20(address(pool), WETH));\n\n        uint256 afterBalanceDAI  = IERC20(DAI).balanceOf(address(gov));\n        uint256 afterBalanceWETH = IERC20(WETH).balanceOf(address(gov));\n\n        assertEq(afterBalanceDAI - beforeBalanceDAI,    mintedDai);\n        assertEq(afterBalanceWETH - beforeBalanceWETH,  mintedWeth);\n    }\n\n    function test_setAllowList() public {\n        // Pause protocol and attempt setAllowList()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_setAllowList(address(pool), address(leo), true));\n        assertTrue(!pool.allowedLiquidityProviders(address(leo)));\n\n        // Unpause protocol and setAllowList()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pat.try_setAllowList(address(pool), address(leo), true));\n        assertTrue(pool.allowedLiquidityProviders(address(leo)));\n    }\n\n    function test_setPoolAdmin() public {\n        // Pause protocol and attempt setPoolAdmin()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_setPoolAdmin(address(pool), address(securityAdmin), true));\n        assertTrue(!pool.poolAdmins(address(securityAdmin)));\n\n        // Unpause protocol and setPoolAdmin()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pat.try_setPoolAdmin(address(pool), address(securityAdmin), true));\n        assertTrue(pool.poolAdmins(address(securityAdmin)));\n    }\n\n    function test_setStakingFee() public {\n        assertEq(pool.stakingFee(),  500);\n        assertEq(pool.delegateFee(), 100);\n        assertTrue(!pam.try_setStakingFee(address(pool), 1000));  // Cannot set stakingFee if not pool delegate\n        assertTrue(!pat.try_setStakingFee(address(pool), 9901));  // Cannot set stakingFee if sum of fees is over 100%\n        assertTrue( pat.try_setStakingFee(address(pool), 9900));  // Can set stakingFee if pool delegate\n        assertEq(pool.stakingFee(),                      9900);\n\n        // Pause protocol and attempt setLockupPeriod()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_setStakingFee(address(pool), 2000));  // Cannot set stakingFee if protocol is paused\n        assertEq(pool.stakingFee(),                      9900);\n\n        // Unpause protocol and setLockupPeriod()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pat.try_setStakingFee(address(pool), 2000));\n        assertEq(pool.stakingFee(),                     2000);\n    }\n    \n    /***************/\n    /*** Helpers ***/\n    /***************/\n\n    function assertBalanceState(address stakeLocker, uint256 patBptBal, uint256 stakeLockerBptBal, uint256 patStakeAmount) internal {\n        assertEq(bPool.balanceOf(address(pat)),                patBptBal);          // Pool delegate BPT balance\n        assertEq(bPool.balanceOf(stakeLocker),                 stakeLockerBptBal);  // BPT owned by the stakeLocker\n        assertEq(IERC20(stakeLocker).balanceOf(address(pat)),  patStakeAmount);     // Stake amount of Pool delegate in stakeLocker\n    }\n}\n"
    },
    "packages/protocol/contracts/test/PoolClaim.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract PoolClaimTest is TestUtil {\n\n    using SafeMath for uint256;\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpActors();\n        setUpBalancerPool();\n        setUpLiquidityPools();\n        createLoans();\n    }\n\n    function test_claim_permissions() public {\n        // Add liquidity into the pool (lex is an LP, but still won't be able to claim)\n        mintFundsAndDepositIntoPool(lex, pool, 10_000 * USD, 10_000 * USD);\n\n        // Fund Loan (so that debtLocker is instantiated and given LoanFDTs)\n        assertTrue(pat.try_fundLoan(address(pool), address(loan), address(dlFactory), 10_000 * USD));\n        \n        // Assert that LPs and non-admins cannot claim\n        assertTrue(!lex.try_claim(address(pool), address(loan), address(dlFactory)));            // Does not have permission to call `claim()` function\n        assertTrue(!securityAdmin.try_claim(address(pool), address(loan), address(dlFactory)));  // Does not have permission to call `claim()` function\n\n        // Pool delegate can claim\n        assertTrue(pat.try_claim(address(pool), address(loan), address(dlFactory)));   // Successfully call the `claim()` function\n        \n        // Admin can claim once added\n        pat.setPoolAdmin(address(pool), address(securityAdmin), true);                           // Add admin to allow to call the `claim()` function\n        assertTrue(securityAdmin.try_claim(address(pool), address(loan), address(dlFactory)));   // Successfully call the `claim()` function\n\n        // Pause protocol and attempt claim()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!securityAdmin.try_claim(address(pool), address(loan), address(dlFactory)));\n        \n        // Unpause protocol and claim()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(securityAdmin.try_claim(address(pool), address(loan), address(dlFactory)));\n\n        // Admin can't claim after removed\n        pat.setPoolAdmin(address(pool), address(securityAdmin), false);                           // Add admin to allow to call the `claim()` function\n        assertTrue(!securityAdmin.try_claim(address(pool), address(loan), address(dlFactory)));   // Does not have permission to call `claim()` function\n    }\n\n    function test_claim_defaulting_for_zero_collateral_loan(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount\n    ) public {\n        // Create Loan with 0% CR so no claimable funds are present after default\n        uint256[5] memory specs = getFuzzedSpecs(apr, index, numPayments, requestAmount, 0);\n        address[3] memory calcs = [address(repaymentCalc), address(lateFeeCalc), address(premiumCalc)];\n\n        uint256 depositAmt = specs[3];\n        mintFundsAndDepositIntoPool(lex, pool, depositAmt, depositAmt);\n\n        Loan zero_loan = bob.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs);\n\n        // Fund the loan by pool delegate.\n        assertTrue(pat.try_fundLoan(address(pool), address(zero_loan), address(dlFactory), depositAmt));\n\n        // Drawdown of the loan\n        uint256 cReq = zero_loan.collateralRequiredForDrawdown(depositAmt);\n        assertEq(cReq, 0); // No collateral required on 0% collateralized loan\n        bob.drawdown(address(zero_loan), depositAmt);\n\n        // Initial claim to clear out claimable funds from drawdown\n        uint256[7] memory claim = pat.claim(address(pool), address(zero_loan), address(dlFactory));\n\n        uint256 beforeBalance = usdc.balanceOf(address(bPool));\n        // Time warp to default\n        hevm.warp(block.timestamp + zero_loan.nextPaymentDue() + globals.defaultGracePeriod() + 1);\n        pat.triggerDefault(address(pool), address(zero_loan), address(dlFactory));   // Triggers a \"liquidation\" that does not perform a swap\n\n        assertEq(pool.principalOut(), depositAmt);\n        assertEq(usdc.balanceOf(pool.liquidityLocker()), 0);\n\n        uint256[7] memory claim2 = pat.claim(address(pool), address(zero_loan), address(dlFactory));\n        assertEq(claim2[0], 0);\n        assertEq(claim2[1], 0);\n        assertEq(claim2[2], 0);\n        assertEq(claim2[3], 0);\n        assertEq(claim2[4], 0);\n        assertEq(claim2[5], 0);\n        assertEq(claim2[6], depositAmt);\n\n        assertEq(pool.principalOut(), 0);\n        // It should be equal to the amount recovered from the BPTs burned.\n        assertEq(usdc.balanceOf(pool.liquidityLocker()), beforeBalance - usdc.balanceOf(address(bPool)));\n    }\n\n    function test_claim_principal_accounting(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio\n    ) public {\n        /*********************************************/\n        /*** Create a loan with 0% APR, 0% premium ***/\n        /*********************************************/\n        premiumCalc = new PremiumCalc(0); // Flat 0% premium\n        gov.setCalc(address(premiumCalc), true);\n\n        uint256 depositAmt = generateLoanAndDepositAmount(apr, index, numPayments, requestAmount, collateralRatio);\n\n        /**************************************************/\n        /*** Mint and deposit funds into liquidity pool ***/\n        /**************************************************/\n\n        mintFundsAndDepositIntoPool(leo, pool, 6E10 * USD,     depositAmt);\n        mintFundsAndDepositIntoPool(liz, pool, 6E10 * USD, 3 * depositAmt);\n        mintFundsAndDepositIntoPool(lex, pool, 6E10 * USD, 6 * depositAmt);\n\n        uint256 CONST_POOL_VALUE = pool.principalOut() + usdc.balanceOf(pool.liquidityLocker());\n\n        /**********************************/\n        /*** Fund loan / loan2 (Excess) ***/\n        /**********************************/\n\n        uint256 beforeLLBalance = usdc.balanceOf(pool.liquidityLocker());\n        (uint256 totalFundedAmount, uint256[] memory fundedAmounts) = getLoanFundedAmounts(beforeLLBalance, 8, uint256(4), uint256(4));\n\n        assertConstFundLoan(pool, address(loan),  address(dlFactory),  fundedAmounts[0], usdc, CONST_POOL_VALUE);\n        assertConstFundLoan(pool, address(loan),  address(dlFactory),  fundedAmounts[1], usdc, CONST_POOL_VALUE);\n        assertConstFundLoan(pool, address(loan),  address(dlFactory2), fundedAmounts[2], usdc, CONST_POOL_VALUE);\n        assertConstFundLoan(pool, address(loan),  address(dlFactory2), fundedAmounts[3], usdc, CONST_POOL_VALUE);\n        assertConstFundLoan(pool, address(loan2), address(dlFactory),  fundedAmounts[4], usdc, CONST_POOL_VALUE);\n        assertConstFundLoan(pool, address(loan2), address(dlFactory),  fundedAmounts[5], usdc, CONST_POOL_VALUE);\n        assertConstFundLoan(pool, address(loan2), address(dlFactory2), fundedAmounts[6], usdc, CONST_POOL_VALUE);\n        assertConstFundLoan(pool, address(loan2), address(dlFactory2), fundedAmounts[7], usdc, CONST_POOL_VALUE);\n        \n        assertEq(pool.principalOut(), totalFundedAmount);\n        assertEq(usdc.balanceOf(pool.liquidityLocker()), beforeLLBalance - totalFundedAmount);\n\n        /*****************/\n        /*** Draw Down ***/\n        /*****************/\n\n        drawdown(loan,  bob, loan.requestAmount());\n        drawdown(loan2, ben, loan2.requestAmount());\n        \n        /*********************************/\n        /*** Make (Early) Full Payment ***/\n        /*********************************/\n\n        doFullLoanPayment(loan,  bob);  // Complete loan payment for loan\n        doFullLoanPayment(loan2, ben);  // Complete loan payment for loan2\n        \n        /******************/\n        /*** Pool Claim ***/\n        /******************/\n           \n        assertConstClaim(pool, address(loan),  address(dlFactory),  usdc, CONST_POOL_VALUE);\n        assertConstClaim(pool, address(loan2), address(dlFactory),  usdc, CONST_POOL_VALUE);\n        assertConstClaim(pool, address(loan2), address(dlFactory2), usdc, CONST_POOL_VALUE);\n        assertConstClaim(pool, address(loan),  address(dlFactory2), usdc, CONST_POOL_VALUE);\n        \n        assertTrue(pool.principalOut() < 10);\n    }\n\n    function test_claim_single_pool(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio\n    ) public {\n\n        uint256 depositAmt = generateLoanAndDepositAmount(apr, index, numPayments, requestAmount, collateralRatio);\n\n        /**************************************************/\n        /*** Mint and deposit funds into liquidity pool ***/\n        /**************************************************/\n        \n        mintFundsAndDepositIntoPool(leo, pool, 6E10 * USD,     depositAmt);\n        mintFundsAndDepositIntoPool(liz, pool, 6E10 * USD, 3 * depositAmt);\n        mintFundsAndDepositIntoPool(lex, pool, 6E10 * USD, 6 * depositAmt);\n\n        /**********************************/\n        /*** Fund loan / loan2 (Excess) ***/\n        /**********************************/\n\n        uint256 beforeLLBalance = usdc.balanceOf(pool.liquidityLocker());\n        (uint256 totalFundedAmount,  uint256[] memory fundedAmounts)  = getLoanFundedAmounts(beforeLLBalance,  8, uint256(4), uint256(4));\n        \n        assertTrue(pat.try_fundLoan(address(pool), address(loan),  address(dlFactory),  fundedAmounts[0]));\n        assertTrue(pat.try_fundLoan(address(pool), address(loan),  address(dlFactory),  fundedAmounts[1]));\n        assertTrue(pat.try_fundLoan(address(pool), address(loan),  address(dlFactory2), fundedAmounts[2]));\n        assertTrue(pat.try_fundLoan(address(pool), address(loan),  address(dlFactory2), fundedAmounts[3]));\n\n        assertTrue(pat.try_fundLoan(address(pool), address(loan2), address(dlFactory),   fundedAmounts[4]));\n        assertTrue(pat.try_fundLoan(address(pool), address(loan2), address(dlFactory),   fundedAmounts[5]));\n        assertTrue(pat.try_fundLoan(address(pool), address(loan2), address(dlFactory2),  fundedAmounts[6]));\n        assertTrue(pat.try_fundLoan(address(pool), address(loan2), address(dlFactory2),  fundedAmounts[7]));\n        \n        assertEq(pool.principalOut(), totalFundedAmount);\n        assertEq(usdc.balanceOf(pool.liquidityLocker()), beforeLLBalance - totalFundedAmount);\n\n        DebtLocker debtLocker1 = DebtLocker(pool.debtLockers(address(loan),  address(dlFactory)));   // debtLocker1 = DebtLocker 1, for loan using dlFactory\n        DebtLocker debtLocker2 = DebtLocker(pool.debtLockers(address(loan),  address(dlFactory2)));  // debtLocker2 = DebtLocker 2, for loan using dlFactory2\n        DebtLocker debtLocker3 = DebtLocker(pool.debtLockers(address(loan2), address(dlFactory)));   // debtLocker3 = DebtLocker 3, for loan2 using dlFactory\n        DebtLocker debtLocker4 = DebtLocker(pool.debtLockers(address(loan2), address(dlFactory2)));  // debtLocker4 = DebtLocker 4, for loan2 using dlFactory2\n\n        /*****************/\n        /*** Draw Down ***/\n        /*****************/\n\n        drawdown(loan,  bob, loan.requestAmount());\n        drawdown(loan2, ben, loan2.requestAmount());\n        \n        /****************************/\n        /*** Make 1 Payment (1/6) ***/\n        /****************************/\n\n        doPartialLoanPayment(loan,  bob);\n        doPartialLoanPayment(loan2, ben);\n        \n        /******************/\n        /*** Pool Claim ***/\n        /******************/\n   \n        checkClaim(debtLocker1, loan,  pat, usdc, pool, address(dlFactory));\n        checkClaim(debtLocker2, loan,  pat, usdc, pool, address(dlFactory2));\n        checkClaim(debtLocker3, loan2, pat, usdc, pool, address(dlFactory));\n        checkClaim(debtLocker4, loan2, pat, usdc, pool, address(dlFactory2));\n\n        /******************************/\n        /*** Make 2 Payments (3/6)  ***/\n        /******************************/\n\n        doPartialLoanPayment(loan,  bob); // USDC required for 2nd payment on loan\n        doPartialLoanPayment(loan2, ben); // USDC required for 2nd payment on loan2\n\n        doPartialLoanPayment(loan,  bob); // USDC required for 3rd payment on loan\n        doPartialLoanPayment(loan2, ben); // USDC required for 3rd payment on loan2\n        \n        /******************/\n        /*** Pool Claim ***/\n        /******************/\n\n        checkClaim(debtLocker1, loan,  pat, usdc, pool, address(dlFactory));\n        checkClaim(debtLocker2, loan,  pat, usdc, pool, address(dlFactory2));\n        checkClaim(debtLocker3, loan2, pat, usdc, pool, address(dlFactory));\n        checkClaim(debtLocker4, loan2, pat, usdc, pool, address(dlFactory2));\n        \n        /*********************************/\n        /*** Make (Early) Full Payment ***/\n        /*********************************/\n        \n        doFullLoanPayment(loan,  bob);  // Complete loan payment for loan\n        doFullLoanPayment(loan2, ben);  // Complete loan payment for loan2\n        \n        /******************/\n        /*** Pool Claim ***/\n        /******************/\n\n        checkClaim(debtLocker1, loan,  pat, usdc, pool, address(dlFactory));\n        checkClaim(debtLocker2, loan,  pat, usdc, pool, address(dlFactory2));\n        checkClaim(debtLocker3, loan2, pat, usdc, pool, address(dlFactory));\n        checkClaim(debtLocker4, loan2, pat, usdc, pool, address(dlFactory2));\n\n        // Ensure both loans are matured.\n        assertEq(uint256(loan.loanState()),  2);\n        assertEq(uint256(loan2.loanState()), 2);\n\n        assertTrue(pool.principalOut() < 10);\n    }\n    \n    function test_claim_multiple_pools(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio\n    ) public {\n       \n        uint256 depositAmt = generateLoanAndDepositAmount(apr, index, numPayments, requestAmount, collateralRatio);\n\n        /*************************************************************/\n        /*** Mint and deposit funds into liquidity pools (1b each) ***/\n        /*************************************************************/\n\n        mintFundsAndDepositIntoPool(leo, pool, 10E10 * USD,     depositAmt);\n        mintFundsAndDepositIntoPool(liz, pool, 10E10 * USD, 3 * depositAmt);\n        mintFundsAndDepositIntoPool(lex, pool, 10E10 * USD, 6 * depositAmt);\n\n        mintFundsAndDepositIntoPool(lex, pool2, 0,     depositAmt);\n        mintFundsAndDepositIntoPool(leo, pool2, 0, 5 * depositAmt);\n        mintFundsAndDepositIntoPool(liz, pool2, 0, 4 * depositAmt);\n\n        /***************************/\n        /*** Fund loan / loan2 ***/\n        /***************************/\n        {\n            uint256 beforeLLBalance  = usdc.balanceOf(pool.liquidityLocker());\n            uint256 beforeLLBalance2 = usdc.balanceOf(pool2.liquidityLocker());\n            (uint256 totalFundedAmount,  uint256[] memory fundedAmounts)  = getLoanFundedAmounts(beforeLLBalance,  8, uint256(4), uint256(4));\n            (uint256 totalFundedAmount2, uint256[] memory fundedAmounts2) = getLoanFundedAmounts(beforeLLBalance2, 6, uint256(2), uint256(4));\n        \n            // Pool 1 loan 1\n            assertTrue(pat.try_fundLoan(address(pool), address(loan),  address(dlFactory),  fundedAmounts[0]));\n            assertTrue(pat.try_fundLoan(address(pool), address(loan),  address(dlFactory),  fundedAmounts[1])); \n            assertTrue(pat.try_fundLoan(address(pool), address(loan),  address(dlFactory2), fundedAmounts[2])); \n            assertTrue(pat.try_fundLoan(address(pool), address(loan),  address(dlFactory2), fundedAmounts[3]));\n\n            // Pool 2 loan 1\n            assertTrue(pam.try_fundLoan(address(pool2), address(loan),  address(dlFactory),  fundedAmounts2[0]));\n            assertTrue(pam.try_fundLoan(address(pool2), address(loan),  address(dlFactory2), fundedAmounts2[1]));\n\n            // Pool 1 Loan 2\n            assertTrue(pat.try_fundLoan(address(pool), address(loan2),  address(dlFactory),  fundedAmounts[4]));\n            assertTrue(pat.try_fundLoan(address(pool), address(loan2),  address(dlFactory),  fundedAmounts[5]));\n            assertTrue(pat.try_fundLoan(address(pool), address(loan2),  address(dlFactory2), fundedAmounts[6]));\n            assertTrue(pat.try_fundLoan(address(pool), address(loan2),  address(dlFactory2), fundedAmounts[7]));\n\n            // Pool 2 loan 2\n            assertTrue(pam.try_fundLoan(address(pool2), address(loan2),  address(dlFactory),  fundedAmounts2[2]));\n            assertTrue(pam.try_fundLoan(address(pool2), address(loan2),  address(dlFactory),  fundedAmounts2[3]));\n            assertTrue(pam.try_fundLoan(address(pool2), address(loan2),  address(dlFactory2), fundedAmounts2[4]));\n            assertTrue(pam.try_fundLoan(address(pool2), address(loan2),  address(dlFactory2), fundedAmounts2[5]));\n\n            // Present state checks\n            assertEq(usdc.balanceOf(pool.liquidityLocker()),             beforeLLBalance - totalFundedAmount); \n            assertEq(usdc.balanceOf(pool2.liquidityLocker()),            beforeLLBalance2 - totalFundedAmount2);\n            assertEq(usdc.balanceOf(address(loan.fundingLocker())),      fundedAmounts[0] + fundedAmounts[1] + fundedAmounts[2] + fundedAmounts[3] + fundedAmounts2[0] + fundedAmounts2[1]);   // Balance of loan fl \n            assertEq(usdc.balanceOf(address(loan2.fundingLocker())),     fundedAmounts[4] + fundedAmounts[5] + fundedAmounts[6] + fundedAmounts[7] + fundedAmounts2[2] + fundedAmounts2[3] + fundedAmounts2[4] + fundedAmounts2[5]);  // Balance of loan2 fl\n            assertEq(loan.balanceOf( getDL(pool,  loan,  dlFactory)),    toWad(fundedAmounts[0]) + toWad(fundedAmounts[1]));    // Balance of debtLocker1 for pool with dlFactory\n            assertEq(loan.balanceOf( getDL(pool,  loan,  dlFactory2)),   toWad(fundedAmounts[2]) + toWad(fundedAmounts[3]));    // Balance of debtLocker2 for pool with dlFactory2\n            assertEq(loan2.balanceOf(getDL(pool,  loan2, dlFactory)),    toWad(fundedAmounts[4]) + toWad(fundedAmounts[5]));    // Balance of debtLocker3 for pool with dlFactory\n            assertEq(loan2.balanceOf(getDL(pool,  loan2, dlFactory2)),   toWad(fundedAmounts[6]) + toWad(fundedAmounts[7]));    // Balance of debtLocker4 for pool with dlFactory2\n            assertEq(loan.balanceOf( getDL(pool2, loan,  dlFactory)),    toWad(fundedAmounts2[0]));                             // Balance of debtLocker1 for pool2 with dlFactory\n            assertEq(loan.balanceOf( getDL(pool2, loan,  dlFactory2)),   toWad(fundedAmounts2[1]));                             // Balance of debtLocker2 for pool2 with dlFactory2\n            assertEq(loan2.balanceOf(getDL(pool2, loan2, dlFactory)),    toWad(fundedAmounts2[2]) + toWad(fundedAmounts2[3]));  // Balance of debtLocker3 for pool2 with dlFactory\n            assertEq(loan2.balanceOf(getDL(pool2, loan2, dlFactory2)),   toWad(fundedAmounts2[4]) + toWad(fundedAmounts2[5]));  // Balance of debtLocker4 for pool2 with dlFactory2\n        }\n\n        DebtLocker debtLocker1_pool1 = DebtLocker(getDL(pool,  loan,  dlFactory));   // debtLocker1_pool1 = DebtLocker 1, for pool, for loan using dlFactory\n        DebtLocker debtLocker2_pool1 = DebtLocker(getDL(pool,  loan,  dlFactory2));  // debtLocker2_pool1 = DebtLocker 2, for pool, for loan using dlFactory2\n        DebtLocker debtLocker3_pool1 = DebtLocker(getDL(pool,  loan2, dlFactory));   // debtLocker3_pool1 = DebtLocker 3, for pool, for loan2 using dlFactory\n        DebtLocker debtLocker4_pool1 = DebtLocker(getDL(pool,  loan2, dlFactory2));  // debtLocker4_pool1 = DebtLocker 4, for pool, for loan2 using dlFactory2\n        DebtLocker debtLocker1_pool2 = DebtLocker(getDL(pool2, loan,  dlFactory));   // debtLocker1_pool2 = DebtLocker 1, for pool2, for loan using dlFactory\n        DebtLocker debtLocker2_pool2 = DebtLocker(getDL(pool2, loan,  dlFactory2));  // debtLocker2_pool2 = DebtLocker 2, for pool2, for loan using dlFactory2\n        DebtLocker debtLocker3_pool2 = DebtLocker(getDL(pool2, loan2, dlFactory));   // debtLocker3_pool2 = DebtLocker 3, for pool2, for loan2 using dlFactory\n        DebtLocker debtLocker4_pool2 = DebtLocker(getDL(pool2, loan2, dlFactory2));  // debtLocker4_pool2 = DebtLocker 4, for pool2, for loan2 using dlFactory2\n\n        /*****************/\n        /*** Draw Down ***/\n        /*****************/\n\n        drawdown(loan,  bob, loan.requestAmount());\n        drawdown(loan2, ben, loan2.requestAmount());\n        \n        /****************************/\n        /*** Make 1 Payment (1/6) ***/\n        /****************************/\n\n        doPartialLoanPayment(loan,  bob); // USDC required for 1st payment on loan\n        doPartialLoanPayment(loan2, ben); // USDC required for 1st payment on loan2\n        \n        /******************/\n        /*** Pool Claim ***/\n        /******************/\n        \n        checkClaim(debtLocker1_pool1, loan,  pat, usdc, pool, address(dlFactory));\n        checkClaim(debtLocker2_pool1, loan,  pat, usdc, pool, address(dlFactory2));\n        checkClaim(debtLocker3_pool1, loan2, pat, usdc, pool, address(dlFactory));\n        checkClaim(debtLocker4_pool1, loan2, pat, usdc, pool, address(dlFactory2));\n\n        checkClaim(debtLocker1_pool2, loan,  pam, usdc, pool2, address(dlFactory));\n        checkClaim(debtLocker2_pool2, loan,  pam, usdc, pool2, address(dlFactory2));\n        checkClaim(debtLocker3_pool2, loan2, pam, usdc, pool2, address(dlFactory));\n        checkClaim(debtLocker4_pool2, loan2, pam, usdc, pool2, address(dlFactory2));\n        \n        /******************************/\n        /*** Make 2 Payments (3/6)  ***/\n        /******************************/\n\n        doPartialLoanPayment(loan,  bob); // USDC required for 2nd payment on loan\n        doPartialLoanPayment(loan2, ben); // USDC required for 2nd payment on loan2\n\n        doPartialLoanPayment(loan,  bob); // USDC required for 3rd payment on loan\n        doPartialLoanPayment(loan2, ben); // USDC required for 3rd payment on loan2\n\n        /******************/\n        /*** Pool Claim ***/\n        /******************/\n        \n        checkClaim(debtLocker1_pool1, loan,  pat, usdc, pool, address(dlFactory));\n        checkClaim(debtLocker2_pool1, loan,  pat, usdc, pool, address(dlFactory2));\n        checkClaim(debtLocker3_pool1, loan2, pat, usdc, pool, address(dlFactory));\n        checkClaim(debtLocker4_pool1, loan2, pat, usdc, pool, address(dlFactory2));\n\n        checkClaim(debtLocker1_pool2, loan,  pam, usdc, pool2, address(dlFactory));\n        checkClaim(debtLocker2_pool2, loan,  pam, usdc, pool2, address(dlFactory2));\n        checkClaim(debtLocker3_pool2, loan2, pam, usdc, pool2, address(dlFactory));\n        checkClaim(debtLocker4_pool2, loan2, pam, usdc, pool2, address(dlFactory2));\n        \n        /*********************************/\n        /*** Make (Early) Full Payment ***/\n        /*********************************/\n\n        doFullLoanPayment(loan,  bob);  // Complete loan payment for loan\n        doFullLoanPayment(loan2, ben);  // Complete loan payment for loan2\n        \n        /******************/\n        /*** Pool Claim ***/\n        /******************/\n        \n        checkClaim(debtLocker1_pool1, loan,  pat, usdc, pool, address(dlFactory));\n        checkClaim(debtLocker2_pool1, loan,  pat, usdc, pool, address(dlFactory2));\n        checkClaim(debtLocker3_pool1, loan2, pat, usdc, pool, address(dlFactory));\n        checkClaim(debtLocker4_pool1, loan2, pat, usdc, pool, address(dlFactory2));\n\n        checkClaim(debtLocker1_pool2, loan,  pam, usdc, pool2, address(dlFactory));\n        checkClaim(debtLocker2_pool2, loan,  pam, usdc, pool2, address(dlFactory2));\n        checkClaim(debtLocker3_pool2, loan2, pam, usdc, pool2, address(dlFactory));\n        checkClaim(debtLocker4_pool2, loan2, pam, usdc, pool2, address(dlFactory2));\n\n        // Ensure both loans are matured.\n        assertEq(uint256(loan.loanState()),  2);\n        assertEq(uint256(loan2.loanState()), 2);\n\n        assertTrue(pool.principalOut()  < 10);\n        assertTrue(pool2.principalOut() < 10);\n    }\n\n    function test_claim_external_transfers(\n        uint256 depositAmt,\n        uint256 transferAmtToPool,\n        uint256 transferAmtToDL,\n        uint256 transferAmtToLoan\n    ) public {\n\n        /**********************************************************/\n        /*** Mint, deposit funds into liquidity pool, fund loan ***/\n        /**********************************************************/\n\n        depositAmt = constrictToRange(depositAmt, loan.requestAmount(), 1_000_000_000 * USD, true);\n\n        mintFundsAndDepositIntoPool(leo, pool, 2_000_000_000 * USD, depositAmt);\n\n        pat.fundLoan(address(pool), address(loan),  address(dlFactory), depositAmt);\n        assertTrue(pool.debtLockers(address(loan),  address(dlFactory)) != address(0));\n        assertEq(pool.principalOut(), depositAmt);\n\n        /*****************/\n        /*** Draw Down ***/\n        /*****************/\n\n        drawdown(loan, bob, depositAmt);\n\n        /*****************************/\n        /*** Make Interest Payment ***/\n        /*****************************/\n\n        doPartialLoanPayment(loan, bob);\n\n        /****************************************************/\n        /*** Transfer USDC into Pool, Loan and debtLocker ***/\n        /****************************************************/\n\n        leo.approve(USDC, address(this), MAX_UINT);\n\n        DebtLocker debtLocker1 = DebtLocker(pool.debtLockers(address(loan),  address(dlFactory)));\n\n        uint256 poolBal_before       = usdc.balanceOf(address(pool));\n        uint256 debtLockerBal_before = usdc.balanceOf(address(debtLocker1));\n\n        uint256 extraTransferAmtToPool = constrictToRange(transferAmtToPool, 10 * USD, 1_000_000 * USD, true);\n        uint256 extraTransferAmtToDL   = constrictToRange(transferAmtToDL,   10 * USD, 1_000_000 * USD, true);\n        uint256 extraTransferAmtToLoan = constrictToRange(transferAmtToLoan, 10 * USD, 1_000_000 * USD, true);\n\n        usdc.transferFrom(address(leo), address(pool),        extraTransferAmtToPool);\n        usdc.transferFrom(address(leo), address(debtLocker1), extraTransferAmtToDL);\n        usdc.transferFrom(address(leo), address(loan),        extraTransferAmtToLoan);\n\n        uint256 poolBal_after       = usdc.balanceOf(address(pool));\n        uint256 debtLockerBal_after = usdc.balanceOf(address(debtLocker1));\n\n        assertEq(poolBal_after - poolBal_before,             extraTransferAmtToPool);\n        assertEq(debtLockerBal_after - debtLockerBal_before, extraTransferAmtToDL);\n\n        poolBal_before       = poolBal_after;\n        debtLockerBal_before = debtLockerBal_after;\n\n        checkClaim(debtLocker1, loan, pat, usdc, pool, address(dlFactory));\n\n        poolBal_after       = usdc.balanceOf(address(pool));\n        debtLockerBal_after = usdc.balanceOf(address(debtLocker1));\n\n        assertTrue(poolBal_after - poolBal_before < 10);  // Collects some rounding dust\n        assertEq(debtLockerBal_after, debtLockerBal_before);\n        \n\n        /*************************/\n        /*** Make Full Payment ***/\n        /*************************/\n\n        doFullLoanPayment(loan, bob);\n\n        /*********************************************************/\n        /*** Check claim with existing balances in DL and Pool ***/\n        /*** Transfer more funds into Loan                     ***/\n        /*********************************************************/\n        \n        // Transfer funds into Loan to make principalClaim > principalOut\n        extraTransferAmtToLoan = constrictToRange(transferAmtToLoan, 200_000 * USD, 1_000_000 * USD, true);\n        usdc.transferFrom(address(leo), address(loan), extraTransferAmtToLoan);\n\n        poolBal_before       = usdc.balanceOf(address(pool));\n        debtLockerBal_before = usdc.balanceOf(address(debtLocker1));\n\n        checkClaim(debtLocker1, loan, pat, usdc, pool, address(dlFactory));\n\n        poolBal_after       = usdc.balanceOf(address(pool));\n        debtLockerBal_after = usdc.balanceOf(address(debtLocker1));\n\n        assertTrue(poolBal_after - poolBal_before < 10);  // Collects some rounding dust\n        assertEq(debtLockerBal_after, debtLockerBal_before);\n\n        assertTrue(pool.principalOut() < 10);\n    }\n\n    /***************/\n    /*** Helpers ***/\n    /***************/\n\n    function assertConstFundLoan(Pool pool, address _loan, address dlFactory, uint256 amt, IERC20 liquidityAsset, uint256 constPoolVal) internal returns (bool) {\n        assertTrue(pat.try_fundLoan(address(pool), _loan,  dlFactory, amt));\n        assertTrue(isConstantPoolValue(pool, liquidityAsset, constPoolVal));\n    }\n\n    function assertConstClaim(Pool pool, address _loan, address dlFactory, IERC20 liquidityAsset, uint256 constPoolVal) internal returns (bool) {\n        pat.claim(address(pool), _loan, dlFactory);\n        assertTrue(isConstantPoolValue(pool, liquidityAsset, constPoolVal));\n    }\n\n    function isConstantPoolValue(Pool pool, IERC20 liquidityAsset, uint256 constPoolVal) internal view returns (bool) {\n        return pool.principalOut() + liquidityAsset.balanceOf(pool.liquidityLocker()) == constPoolVal;\n    }\n\n    function calcAllotment(uint256 newAmt, uint256 totalClaim, uint256 totalNewAmt) internal pure returns (uint256) {\n        return newAmt == uint256(0) ? uint256(0) : newAmt.mul(totalClaim).div(totalNewAmt);\n    }\n\n    function getDL(Pool pool, Loan loan, DebtLockerFactory dlFactory) internal view returns (address) {\n        return pool.debtLockers(address(loan), address(dlFactory));\n    }\n\n    function generateLoanAndDepositAmount(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio\n    ) internal returns (uint256 depositAmt) {\n        uint256[5] memory specs = getFuzzedSpecs(apr, index, numPayments, requestAmount, collateralRatio);\n        address[3] memory calcs = [address(repaymentCalc), address(lateFeeCalc), address(premiumCalc)];\n\n        loan  = bob.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs);\n        loan2 = ben.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs);\n\n        depositAmt = constrictToRange(specs[3], 100 * USD, 1E10 * USD, true);  // Fund value should be between 100 USD - 1B USD\n        uint256 estimatedLLBalance = 10 * depositAmt;\n        if (estimatedLLBalance < specs[3] * 2) {\n            uint256 delta = specs[3] * 2 - estimatedLLBalance;\n            depositAmt = (estimatedLLBalance + delta / 10); \n        }\n    }\n    \n    function getLoanFundedAmounts(uint256 beforeLLBalance, uint256 rounds, uint256 loan1FundedCount, uint256 loan2FundedCount) internal returns (uint256, uint256[] memory) {\n        uint256 maxAmountPerFundLoan = beforeLLBalance / rounds;\n        uint256 totalFundedAmount    = 0;\n\n        uint256[] memory fundedCount     = new uint256[](2);\n        uint256[] memory fundedAmounts   = new uint256[](rounds);\n        uint256[] memory amtFundedToLoan = new uint256[](2);\n\n        fundedCount[0] = loan1FundedCount;\n        fundedCount[1] = loan2FundedCount;\n\n        for (uint256 i = 0; i < rounds; i++) {\n            uint256 minAmt     = i == 0 ? 100 * USD : fundedAmounts[i - 1];\n            uint256 fundAmt    = i == 0 ? maxAmountPerFundLoan : i * fundedAmounts[i - 1];\n            fundedAmounts[i]   = constrictToRange(fundAmt, minAmt, maxAmountPerFundLoan, true);\n            totalFundedAmount += fundedAmounts[i];\n        }\n\n        for (uint256 j = 0; j < fundedCount.length; j++) {\n            for (uint256 i = 0; i < fundedCount[0]; i++) {\n                amtFundedToLoan[j] += fundedAmounts[i];\n            }\n        }\n\n        if (amtFundedToLoan[0] < loan.requestAmount()) { \n            fundedAmounts[0]  += loan.requestAmount() - amtFundedToLoan[0];\n            totalFundedAmount += loan.requestAmount() - amtFundedToLoan[0];\n        }\n\n        if (amtFundedToLoan[1] < loan2.requestAmount()) { \n            fundedAmounts[4]  += loan2.requestAmount() - amtFundedToLoan[1];\n            totalFundedAmount += loan2.requestAmount() - amtFundedToLoan[1];\n        }\n        return (totalFundedAmount, fundedAmounts);\n    }\n\n    function checkClaim(DebtLocker debtLocker, Loan _loan, PoolDelegate pd, IERC20 liquidityAsset, Pool pool, address dlFactory) internal {\n        uint256[10] memory balances = [\n            liquidityAsset.balanceOf(address(debtLocker)),\n            liquidityAsset.balanceOf(address(pool)),\n            liquidityAsset.balanceOf(address(pd)),\n            liquidityAsset.balanceOf(pool.stakeLocker()),\n            liquidityAsset.balanceOf(pool.liquidityLocker()),\n            0,0,0,0,0\n        ];\n\n        uint256[4] memory loanData = [\n            _loan.interestPaid(),\n            _loan.principalPaid(),\n            _loan.feePaid(),\n            _loan.excessReturned()\n        ];\n\n        uint256[8] memory debtLockerData = [\n            debtLocker.lastInterestPaid(),\n            debtLocker.lastPrincipalPaid(),\n            debtLocker.lastFeePaid(),\n            debtLocker.lastExcessReturned(),\n            0,0,0,0\n        ];\n\n        uint256 beforePrincipalOut = pool.principalOut();\n        uint256 beforeInterestSum  = pool.interestSum();\n        uint256[7] memory claim = pd.claim(address(pool), address(_loan),   address(dlFactory));\n\n        // Updated DL state variables\n        debtLockerData[4] = debtLocker.lastInterestPaid();\n        debtLockerData[5] = debtLocker.lastPrincipalPaid();\n        debtLockerData[6] = debtLocker.lastFeePaid();\n        debtLockerData[7] = debtLocker.lastExcessReturned();\n\n        balances[5] = liquidityAsset.balanceOf(address(debtLocker));\n        balances[6] = liquidityAsset.balanceOf(address(pool));\n        balances[7] = liquidityAsset.balanceOf(address(pd));\n        balances[8] = liquidityAsset.balanceOf(pool.stakeLocker());\n        balances[9] = liquidityAsset.balanceOf(pool.liquidityLocker());\n\n        uint256 sumTransfer;\n        uint256 sumNetNew;\n\n        for (uint256 i = 0; i < 4; i++) sumNetNew += (loanData[i] - debtLockerData[i]);\n\n        for (uint256 i = 0; i < 4; i++) {\n            assertEq(debtLockerData[i + 4], loanData[i]);  // DL updated to reflect loan state\n            // Category portion of claim * DL asset balance \n            // Eg. (interestClaimed / totalClaimed) * balance = Portion of total claim balance that is interest\n            assertEq(calcAllotment(loanData[i] - debtLockerData[i], claim[0], sumNetNew), claim[i + 1]);\n\n            sumTransfer += balances[i + 6] - balances[i + 1]; // Sum up all transfers that occurred from claim\n        }\n        \n        assertEq(claim[0], sumTransfer); // Assert balance from withdrawFunds equals sum of transfers\n        \n        assertEq(  balances[5] - balances[0], 0);    // DL should have transferred ALL funds claimed to LP\n        assertTrue(balances[6] - balances[1] < 10);  // LP should have transferred ALL funds claimed to LL, SL, and PD (with rounding error)\n\n        assertEq(  balances[7] - balances[2], claim[3] + claim[1] * pool.delegateFee() / 10_000);  // Pool delegate claim (feePaid + delegateFee portion of interest)\n        assertEq(  balances[8] - balances[3],            claim[1] * pool.stakingFee()  / 10_000);  // Staking Locker claim (feePaid + stakingFee portion of interest)\n\n        // LiquidityLocker balance change should EXACTLY equal state variable change\n        assertEq(balances[9] - balances[4], (beforePrincipalOut - pool.principalOut()) + (pool.interestSum() - beforeInterestSum));\n\n        // Normal case, principalClaim <= principalOut\n        if (claim[2] + claim[4] + claim[5] <= beforePrincipalOut) {\n            // interestSum incremented by remainder of interest\n            withinPrecision(\n                pool.interestSum() - beforeInterestSum, \n                claim[1] - ((claim[1] * pool.delegateFee() / 10_000) + (claim[1] * pool.stakingFee() / 10_000)), \n                11\n            );  \n            // principalOut decremented by principal paid plus excess\n            assertTrue(beforePrincipalOut - pool.principalOut() == claim[2] + claim[4] + claim[5]);\n        } \n        // Edge case, attacker transfers funds into Loan to make principalClaim overflow\n        else {\n            // interestSum incremented by remainder of interest plus overflow amount\n            withinPrecision(\n                pool.interestSum() - beforeInterestSum, \n                claim[1] - claim[1] * (pool.delegateFee() + pool.stakingFee()) / 10_000 + (claim[2] + claim[4] - beforePrincipalOut), \n                11\n            );\n            assertEq(pool.principalOut(), 0);\n        }   \n    }\n\n}\n"
    },
    "packages/protocol/contracts/test/MplRewardsFactory.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract MplRewardsFactoryTest is TestUtil {\n\n    function setUp() public {\n        setUpGlobals();\n        setUpMplRewardsFactory();\n    }\n\n    function test_constructor() public {\n        MplRewardsFactory _mplRewardsFactory = new MplRewardsFactory(address(globals));  // Setup MplRewardsFactory to support MplRewards creation.\n        assertEq(address(_mplRewardsFactory.globals()), address(globals));\n    }\n\n    function test_createMplRewards() public {\n        address mockPool = address(1);  // Fake pool address so a pool doesn't have to be instantiated for PoolFDTs\n\n        // Assert permissioning\n        assertTrue(!fakeGov.try_createMplRewards(address(mpl), mockPool));\n        assertTrue(     gov.try_createMplRewards(address(mpl), mockPool));\n\n        MplRewards mplRewards = MplRewards(gov.createMplRewards(address(mpl), mockPool));\n\n        // Validate the storage of mplRewardsFactory\n        assertTrue(mplRewardsFactory.isMplRewards(address(mplRewards)));\n\n        // Validate the storage of mplRewards.\n        assertEq(address(mplRewards.rewardsToken()), address(mpl));\n        assertEq(address(mplRewards.stakingToken()),     mockPool);\n        assertEq(mplRewards.rewardsDuration(),             7 days);\n        assertEq(address(mplRewards.owner()),        address(gov));\n    }\n\n    function test_setGlobals() public {\n        assertTrue(!fakeGov.try_setGlobals(address(mplRewardsFactory), address(1)));\n        assertTrue(     gov.try_setGlobals(address(mplRewardsFactory), address(1)));\n        assertEq(address(mplRewardsFactory.globals()), address(1));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/MplRewards.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\nimport \"./TestUtil.sol\";\n\ncontract MplRewardsTest is TestUtil {\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpActors();\n        setUpBalancerPool();\n        setUpLiquidityPool();\n        setUpMplRewardsFactory();\n        setUpMplRewards();\n        setUpFarmers(1000 * USD, 1000 * USD, 1000 * USD);\n    }\n\n    /*******************************/\n    /*** Admin Functions Testing ***/\n    /*******************************/\n    function test_transferOwnership() public {\n        assertEq(mplRewards.owner(), address(gov));\n\n        assertTrue(!fakeGov.try_transferOwnership(address(fakeGov)));\n        assertTrue(     gov.try_transferOwnership(address(fakeGov)));\n\n        assertEq(mplRewards.owner(), address(fakeGov));\n\n        assertTrue(   !gov.try_transferOwnership(address(gov)));\n        assertTrue(fakeGov.try_transferOwnership(address(gov)));\n\n        assertEq(mplRewards.owner(), address(gov));\n    }\n\n    function test_notifyRewardAmount() public {\n        assertEq(mplRewards.periodFinish(),              0);\n        assertEq(mplRewards.rewardRate(),                0);\n        assertEq(mplRewards.rewardsDuration(),      7 days);  // Pre set value\n        assertEq(mplRewards.lastUpdateTime(),            0);\n        assertEq(mplRewards.rewardPerTokenStored(),      0);\n\n        mpl.transfer(address(mplRewards), 25_000 * WAD);\n\n        assertTrue(!fakeGov.try_notifyRewardAmount(25_000 * WAD));\n        assertTrue(     gov.try_notifyRewardAmount(25_000 * WAD));\n\n        assertEq(mplRewards.rewardRate(),     uint256(25_000 * WAD) / 7 days);\n        assertEq(mplRewards.lastUpdateTime(),                block.timestamp);\n        assertEq(mplRewards.periodFinish(),         block.timestamp + 7 days);\n    }\n\n    function test_updatePeriodFinish() public {\n        assertEq(mplRewards.periodFinish(), 0);\n\n        assertTrue(!fakeGov.try_updatePeriodFinish(block.timestamp + 30 days));\n        assertTrue(     gov.try_updatePeriodFinish(block.timestamp + 30 days));\n\n        assertEq(mplRewards.periodFinish(), block.timestamp + 30 days);\n    }\n\n    function test_recoverERC20() public {\n        mint(\"USDC\", address(fay), 1000 * USD);\n\n        assertEq(IERC20(USDC).balanceOf(address(fay)),            1000 * USD);\n        assertEq(IERC20(USDC).balanceOf(address(gov)),                     0);\n        assertEq(IERC20(USDC).balanceOf(address(mplRewards)),              0);\n        assertEq(mplRewards.balanceOf(address(fay)),                       0);\n        assertEq(mplRewards.totalSupply(),                                 0);\n\n        fay.transfer(USDC, address(mplRewards), 1000 * USD); // Ali transfers USDC directly into Staking rewards accidentally\n\n        assertEq(IERC20(USDC).balanceOf(address(fay)),                     0);\n        assertEq(IERC20(USDC).balanceOf(address(gov)),                     0);\n        assertEq(IERC20(USDC).balanceOf(address(mplRewards)),     1000 * USD);\n        assertEq(mplRewards.balanceOf(address(fay)),                       0);\n        assertEq(mplRewards.totalSupply(),                                 0);\n\n        assertTrue(!fakeGov.try_recoverERC20(USDC, 400 * USD));\n        assertTrue(     gov.try_recoverERC20(USDC, 400 * USD));\n\n        assertEq(IERC20(USDC).balanceOf(address(fay)),                     0);\n        assertEq(IERC20(USDC).balanceOf(address(gov)),             400 * USD);\n        assertEq(IERC20(USDC).balanceOf(address(mplRewards)),      600 * USD);\n        assertEq(mplRewards.balanceOf(address(fay)),                       0);\n        assertEq(mplRewards.totalSupply(),                                 0);\n\n        assertTrue(!fakeGov.try_recoverERC20(USDC, 600 * USD));\n        assertTrue(     gov.try_recoverERC20(USDC, 600 * USD));\n\n        assertEq(IERC20(USDC).balanceOf(address(fay)),                     0);\n        assertEq(IERC20(USDC).balanceOf(address(gov)),            1000 * USD);\n        assertEq(IERC20(USDC).balanceOf(address(mplRewards)),              0);\n        assertEq(mplRewards.balanceOf(address(fay)),                       0);\n        assertEq(mplRewards.totalSupply(),                                 0);\n    }\n\n    function test_setRewardsDuration() public {\n        assertEq(mplRewards.periodFinish(),         0);\n        assertEq(mplRewards.rewardsDuration(), 7 days);\n\n        mpl.transfer(address(mplRewards), 25_000 * WAD);\n\n        gov.notifyRewardAmount(25_000 * WAD);\n\n        assertEq(mplRewards.periodFinish(),    block.timestamp + 7 days);\n        assertEq(mplRewards.rewardsDuration(),                   7 days);\n\n        assertTrue(!fakeGov.try_setRewardsDuration(30 days));\n        assertTrue(    !gov.try_setRewardsDuration(30 days)); // Won't work because current rewards period hasn't ended\n\n        hevm.warp(mplRewards.periodFinish());\n\n        assertTrue(!gov.try_setRewardsDuration(30 days)); // Won't work because current rewards period hasn't ended\n\n        hevm.warp(mplRewards.periodFinish() + 1);\n\n        assertTrue(gov.try_setRewardsDuration(30 days)); // Works because current rewards period has ended\n\n        assertEq(mplRewards.rewardsDuration(), 30 days);\n    }\n\n    function test_setPaused() public {\n        assertTrue(!mplRewards.paused());\n\n        // Fay can stake\n        fay.increaseCustodyAllowance(address(pool), address(mplRewards), 100 * WAD);\n        assertTrue(fay.try_stake(100 * WAD));\n\n        // Set to paused\n        assertTrue(!fakeGov.try_setPaused(true));\n        assertTrue(     gov.try_setPaused(true));\n\n        assertTrue(mplRewards.paused());\n\n        // Fez can't stake\n        fez.increaseCustodyAllowance(address(pool), address(mplRewards), 100 * WAD);\n        assertTrue(!fez.try_stake(100 * WAD));\n\n        // Fay can't withdraw\n        fay.increaseCustodyAllowance(address(pool), address(mplRewards), 100 * WAD);\n        assertTrue(!fay.try_withdraw(100 * WAD));\n\n        // Set to unpaused\n        assertTrue(!fakeGov.try_setPaused(false));\n        assertTrue(     gov.try_setPaused(false));\n\n        assertTrue(!mplRewards.paused());\n        assertTrue(fay.try_withdraw(100 * WAD));\n\n        // Fez can stake\n        fez.increaseCustodyAllowance(address(pool), address(mplRewards), 100 * WAD);\n        assertTrue(fez.try_stake(100 * WAD));\n    }\n\n    /****************************/\n    /*** LP functions testing ***/\n    /****************************/\n    function test_stake() public {\n        uint256 start = block.timestamp;\n\n        assertEq(pool.balanceOf(address(fay)),           1000 * WAD);\n        assertEq(pool.depositDate(address(fay)),              start);\n        assertEq(pool.depositDate(address(mplRewards)),           0);  // MplRewards depDate should always be zero so that it can avoid lockup logic\n        assertEq(mplRewards.balanceOf(address(fay)),              0);\n        assertEq(mplRewards.totalSupply(),                        0);\n\n        hevm.warp(start + 1 days); // Warp to ensure no effect on depositDates\n\n        assertTrue(!fay.try_stake(100 * WAD));  // Can't stake before approval\n\n        fay.increaseCustodyAllowance(address(pool), address(mplRewards), 100 * WAD);\n\n        assertTrue(!fay.try_stake(0));          // Can't stake zero\n        assertTrue( fay.try_stake(100 * WAD));  // Can stake after approval\n\n        assertEq(pool.balanceOf(address(fay)),          1000 * WAD);  // PoolFDT balance doesn't change\n        assertEq(pool.depositDate(address(fay)),             start);  // Has not changed\n        assertEq(pool.depositDate(address(mplRewards)),          0);  // Has not changed\n        assertEq(mplRewards.balanceOf(address(fay)),     100 * WAD);\n        assertEq(mplRewards.totalSupply(),               100 * WAD);\n    }\n\n    function test_withdraw() public {\n        uint256 start = block.timestamp;\n\n        fay.increaseCustodyAllowance(address(pool), address(mplRewards), 100 * WAD);\n        fay.stake(100 * WAD);\n\n        hevm.warp(start + 1 days); // Warp to ensure no effect on depositDates\n\n        assertEq(pool.balanceOf(address(fay)),           1000 * WAD);  // PoolFDT balance doesn't change\n        assertEq(pool.depositDate(address(fay)),              start);\n        assertEq(pool.depositDate(address(mplRewards)),           0);  // MplRewards depDate should always be zero so that it can avoid lockup logic\n        assertEq(mplRewards.balanceOf(address(fay)),      100 * WAD);\n        assertEq(mplRewards.totalSupply(),                100 * WAD);\n\n        assertTrue(!fay.try_withdraw(0));          // Can't withdraw zero\n        assertTrue( fay.try_withdraw(100 * WAD));  // Can withdraw\n\n        assertEq(pool.balanceOf(address(fay)),           1000 * WAD);\n        assertEq(pool.depositDate(address(fay)),              start);  // Does not change\n        assertEq(pool.depositDate(address(mplRewards)),           0);  // MplRewards depDate should always be zero so that it can avoid lockup logic\n        assertEq(mplRewards.balanceOf(address(fay)),              0);\n        assertEq(mplRewards.totalSupply(),                        0);\n    }\n\n    function assertRewardsAccounting(\n        address account,\n        uint256 totalSupply,\n        uint256 rewardPerTokenStored,\n        uint256 userRewardPerTokenPaid,\n        uint256 earned,\n        uint256 rewards,\n        uint256 rewardTokenBal\n    )\n        public\n    {\n        assertEq(mplRewards.totalSupply(),                   totalSupply);\n        assertEq(mplRewards.rewardPerTokenStored(),          rewardPerTokenStored);\n        assertEq(mplRewards.userRewardPerTokenPaid(account), userRewardPerTokenPaid);\n        assertEq(mplRewards.earned(account),                 earned);\n        assertEq(mplRewards.rewards(account),                rewards);\n        assertEq(mpl.balanceOf(account),                     rewardTokenBal);\n    }\n\n    /**********************************/\n    /*** Rewards accounting testing ***/\n    /**********************************/\n    function test_rewards_single_epoch() public {\n        fay.increaseCustodyAllowance(address(pool), address(mplRewards), 100 * WAD);\n        fez.increaseCustodyAllowance(address(pool), address(mplRewards), 100 * WAD);\n        fay.stake(10 * WAD);\n\n        mpl.transfer(address(mplRewards), 25_000 * WAD);\n\n        gov.setRewardsDuration(30 days);\n\n        gov.notifyRewardAmount(25_000 * WAD);\n\n        uint256 rewardRate = mplRewards.rewardRate();\n        uint256 start      = block.timestamp;\n\n        assertEq(rewardRate, uint256(25_000 * WAD) / 30 days);\n\n        assertEq(mpl.balanceOf(address(mplRewards)), 25_000 * WAD);\n\n        /*** Ali time = 0 post-stake ***/\n        assertRewardsAccounting({\n            account:                address(fay),  // Account for accounting\n            totalSupply:            10 * WAD,      // Ali's stake\n            rewardPerTokenStored:   0,             // Starting state\n            userRewardPerTokenPaid: 0,             // Starting state\n            earned:                 0,             // Starting state\n            rewards:                0,             // Starting state\n            rewardTokenBal:         0              // Starting state\n        });\n\n        fay.getReward();  // Get reward at time = 0\n\n        /*** Ali time = (0 days) post-claim ***/\n        assertRewardsAccounting({\n            account:                address(fay),  // Account for accounting\n            totalSupply:            10 * WAD,      // Ali's stake\n            rewardPerTokenStored:   0,             // Starting state (getReward has no effect at time = 0)\n            userRewardPerTokenPaid: 0,             // Starting state (getReward has no effect at time = 0)\n            earned:                 0,             // Starting state (getReward has no effect at time = 0)\n            rewards:                0,             // Starting state (getReward has no effect at time = 0)\n            rewardTokenBal:         0              // Starting state (getReward has no effect at time = 0)\n        });\n\n        hevm.warp(start + 1 days);  // Warp to time = (1 days) (dTime = 1 days)\n\n        // Reward per token (RPT) that was used before fez entered the pool (accrued over dTime = 1 days)\n        uint256 dTime1_rpt = rewardRate * 1 days * WAD / (10 * WAD);\n\n        /*** Ali time = (1 days) pre-claim ***/\n        assertRewardsAccounting({\n            account:                address(fay),                 // Account for accounting\n            totalSupply:            10 * WAD,                     // Ali's stake\n            rewardPerTokenStored:   0,                            // Not updated yet\n            userRewardPerTokenPaid: 0,                            // Not updated yet\n            earned:                 dTime1_rpt * 10 * WAD / WAD,  // Time-based calculation\n            rewards:                0,                            // Not updated yet\n            rewardTokenBal:         0                             // Nothing claimed\n        });\n\n        fay.getReward();  // Get reward at time = (1 days)\n\n        /*** Ali time = (1 days) post-claim ***/\n        assertRewardsAccounting({\n            account:                address(fay),                // Account for accounting\n            totalSupply:            10 * WAD,                    // Ali's stake\n            rewardPerTokenStored:   dTime1_rpt,                  // Updated on updateReward\n            userRewardPerTokenPaid: dTime1_rpt,                  // Updated on updateReward for 100% ownership in pool after 1hr\n            earned:                 0,                           // Time-based calculation and userRewardPerTokenPaid cancel out\n            rewards:                0,                           // Updated on updateReward to earned(), then set to zero on getReward\n            rewardTokenBal:         dTime1_rpt * 10 * WAD / WAD  // Updated on getReward, account has claimed rewards (equal to original earned() amt at this timestamp))\n        });\n\n        fez.stake(10 * WAD); // Bob stakes 10 FDTs, giving him 50% stake in the pool rewards going forward\n\n        /*** Bob time = (1 days) post-stake ***/\n        assertRewardsAccounting({\n            account:                address(fez),  // Account for accounting\n            totalSupply:            20 * WAD,      // Ali + Bob stake\n            rewardPerTokenStored:   dTime1_rpt,    // Doesn't change since no time has passed\n            userRewardPerTokenPaid: dTime1_rpt,    // Used so Bob can't claim past rewards\n            earned:                 0,             // Time-based calculation and userRewardPerTokenPaid cancel out, meaning Bob only earns future rewards\n            rewards:                0,             // Not updated yet\n            rewardTokenBal:         0              // Not updated yet\n        });\n\n        hevm.warp(start + 2 days);  // Warp to time = (2 days) (dTime = 1 days)\n\n        // Reward per token (RPT) that was used after Bob entered the pool (accrued over dTime = 1 days, on second day), smaller since supply increased\n        uint256 dTime2_rpt = rewardRate * 1 days * WAD / (20 * WAD);\n\n        /*** Ali time = (2 days) pre-claim ***/\n        assertRewardsAccounting({\n            account:                address(fay),                 // Account for accounting\n            totalSupply:            20 * WAD,                     // Ali + Bob stake\n            rewardPerTokenStored:   dTime1_rpt,                   // Not updated yet\n            userRewardPerTokenPaid: dTime1_rpt,                   // Used so Ali can't do multiple claims\n            earned:                 dTime2_rpt * 10 * WAD / WAD,  // Ali has not claimed any rewards that have accrued during dTime2\n            rewards:                0,                            // Not updated yet\n            rewardTokenBal:         dTime1_rpt * 10 * WAD / WAD   // From previous claim\n        });\n\n        /*** Bob time = (2 days) pre-claim ***/\n        assertRewardsAccounting({\n            account:                address(fez),                 // Account for accounting\n            totalSupply:            20 * WAD,                     // Ali + Bob stake\n            rewardPerTokenStored:   dTime1_rpt,                   // Not updated yet\n            userRewardPerTokenPaid: dTime1_rpt,                   // Used so Bob can't do claims on past rewards\n            earned:                 dTime2_rpt * 10 * WAD / WAD,  // Bob has not claimed any rewards that have accrued during dTime2\n            rewards:                0,                            // Not updated yet\n            rewardTokenBal:         0                             // Not updated yet\n        });\n\n        fez.stake(20 * WAD); // Bob stakes another 20 FDTs, giving him 75% stake in the pool rewards going forward\n\n        /*** Bob time = (2 days) post-stake ***/\n        assertRewardsAccounting({\n            account:                address(fez),                 // Account for accounting\n            totalSupply:            40 * WAD,                     // Ali + Bob stake\n            rewardPerTokenStored:   dTime1_rpt + dTime2_rpt,      // Updated on updateReward to snapshot rewardPerToken up to that point\n            userRewardPerTokenPaid: dTime1_rpt + dTime2_rpt,      // Used so Bob can't do claims on past rewards\n            earned:                 dTime2_rpt * 10 * WAD / WAD,  // Earned updated to reflect all unclaimed earnings pre stake\n            rewards:                dTime2_rpt * 10 * WAD / WAD,  // Rewards updated to earnings on updateReward\n            rewardTokenBal:         0                             // Not updated yet\n        });\n\n        hevm.warp(start + 2 days + 1 hours);  // Warp to time = (2 days + 1 hours) (dTime = 1 hours)\n\n        uint256 dTime3_rpt = rewardRate * 1 hours * WAD / (40 * WAD);  // Reward per token (RPT) that was used after Bob staked more into the pool (accrued over dTime = 1 hours)\n\n        /*** Ali time = (2 days + 1 hours) pre-claim ***/\n        assertRewardsAccounting({\n            account:                address(fay),                                // Account for accounting\n            totalSupply:            40 * WAD,                                    // Ali + Bob stake\n            rewardPerTokenStored:   dTime1_rpt + dTime2_rpt,                     // Not updated yet\n            userRewardPerTokenPaid: dTime1_rpt,                                  // Used so Ali can't do multiple claims\n            earned:                 (dTime2_rpt + dTime3_rpt) * 10 * WAD / WAD,  // Ali has not claimed any rewards that have accrued during dTime2 or dTime3\n            rewards:                0,                                           // Not updated yet\n            rewardTokenBal:         dTime1_rpt * 10 * WAD / WAD                  // From previous claim\n        });\n\n        /*** Bob time = (2 days + 1 hours) pre-claim ***/\n        assertRewardsAccounting({\n            account:                address(fez),                                           // Account for accounting\n            totalSupply:            40 * WAD,                                               // Ali + Bob stake\n            rewardPerTokenStored:   dTime1_rpt + dTime2_rpt,                                // Not updated yet\n            userRewardPerTokenPaid: dTime1_rpt + dTime2_rpt,                                // Used so Bob can't do claims on past rewards\n            earned:                 (dTime2_rpt * 10 * WAD + dTime3_rpt * 30 * WAD) / WAD,  // Bob's earnings since he entered the pool\n            rewards:                dTime2_rpt * 10 * WAD / WAD,                            // Rewards updated to reflect all unclaimed earnings pre stake\n            rewardTokenBal:         0                                                       // Not updated yet\n        });\n\n        fez.getReward();  // Get reward at time = (2 days + 1 hours)\n\n        /*** Bob time = (2 days + 1 hours) post-claim ***/\n        assertRewardsAccounting({\n            account:                address(fez),                                          // Account for accounting\n            totalSupply:            40 * WAD,                                              // Ali + Bob stake\n            rewardPerTokenStored:   dTime1_rpt + dTime2_rpt + dTime3_rpt,                  // Updated on updateReward\n            userRewardPerTokenPaid: dTime1_rpt + dTime2_rpt + dTime3_rpt,                  // Used so Bob can't do multiple claims\n            earned:                 0,                                                     // Time-based calculation and userRewardPerTokenPaid cancel out\n            rewards:                0,                                                     // Updated on updateReward to earned(), then set to zero on getReward\n            rewardTokenBal:         (dTime2_rpt * 10 * WAD + dTime3_rpt * 30 * WAD) / WAD  // Updated on getReward, account has claimed rewards (equal to original earned() amt at this timestamp))\n        });\n\n        fez.getReward();  // Try double claim\n\n        /*** Bob time = (2 days + 1 hours) post-claim (ASSERT NOTHING CHANGES) ***/\n        assertRewardsAccounting({\n            account:                address(fez),                                          // Doesn't change\n            totalSupply:            40 * WAD,                                              // Doesn't change\n            rewardPerTokenStored:   dTime1_rpt + dTime2_rpt + dTime3_rpt,                  // Doesn't change\n            userRewardPerTokenPaid: dTime1_rpt + dTime2_rpt + dTime3_rpt,                  // Doesn't change\n            earned:                 0,                                                     // Doesn't change\n            rewards:                0,                                                     // Doesn't change\n            rewardTokenBal:         (dTime2_rpt * 10 * WAD + dTime3_rpt * 30 * WAD) / WAD  // Doesn't change\n        });\n\n        fay.withdraw(5 * WAD);  // Ali withdraws 5 * WAD at time = (2 days + 1 hours)\n\n        /*** Ali time = (2 days + 1 hours) pre-claim ***/\n        assertRewardsAccounting({\n            account:                address(fay),                                // Account for accounting\n            totalSupply:            35 * WAD,                                    // Ali + Bob stake, lower now that Ali withdrew\n            rewardPerTokenStored:   dTime1_rpt + dTime2_rpt + dTime3_rpt,        // From Bob's update\n            userRewardPerTokenPaid: dTime1_rpt + dTime2_rpt + dTime3_rpt,        // Used so Ali can't claim past earnings\n            earned:                 (dTime2_rpt + dTime3_rpt) * 10 * WAD / WAD,  // Ali has not claimed any rewards that have accrued during dTime2 and dTime3\n            rewards:                (dTime2_rpt + dTime3_rpt) * 10 * WAD / WAD,  // Updated on updateReward to earned()\n            rewardTokenBal:         dTime1_rpt * 10 * WAD / WAD                  // From previous claim\n        });\n\n        hevm.warp(start + 3 days + 1 hours);  // Warp to time = (3 days + 1 hours) (dTime = 1 days)\n\n        uint256 dTime4_rpt = rewardRate * 1 days * WAD / (35 * WAD);  // Reward per token (RPT) that was used after Ali withdrew from the pool (accrued over dTime = 1 days)\n\n        /*** Ali time = (3 days + 1 hours) pre-exit ***/\n        assertRewardsAccounting({\n            account:                address(fay),                                                         // Account for accounting\n            totalSupply:            35 * WAD,                                                             // Ali + Bob stake\n            rewardPerTokenStored:   dTime1_rpt + dTime2_rpt + dTime3_rpt,                                 // Not updated yet\n            userRewardPerTokenPaid: dTime1_rpt + dTime2_rpt + dTime3_rpt,                                 // Used so Ali can't do multiple claims\n            earned:                 ((dTime2_rpt + dTime3_rpt) * 10 * WAD + dTime4_rpt * 5 * WAD) / WAD,  // Ali has not claimed any rewards that have accrued during dTime2, dTime3 and dTime4\n            rewards:                (dTime2_rpt + dTime3_rpt) * 10 * WAD / WAD,                           // Not updated yet\n            rewardTokenBal:         dTime1_rpt * 10 * WAD / WAD                                           // From previous claim\n        });\n\n        /*** Bob time = (2 days + 1 hours) pre-exit ***/\n        assertRewardsAccounting({\n            account:                address(fez),                                          // Account for accounting\n            totalSupply:            35 * WAD,                                              // Ali + Bob stake\n            rewardPerTokenStored:   dTime1_rpt + dTime2_rpt + dTime3_rpt,                  // Not updated yet\n            userRewardPerTokenPaid: dTime1_rpt + dTime2_rpt + dTime3_rpt,                  // Used so Bob can't do multiple claims\n            earned:                 dTime4_rpt * 30 * WAD / WAD,                           // Bob has not claimed any rewards that have accrued during dTime4\n            rewards:                0,                                                     // Not updated yet\n            rewardTokenBal:         (dTime2_rpt * 10 * WAD + dTime3_rpt * 30 * WAD) / WAD  // From previous claim\n        });\n\n        fay.exit();  // Ali exits at time = (3 days + 1 hours)\n        fez.exit();  // Bob exits at time = (3 days + 1 hours)\n\n        /*** Ali time = (3 days + 1 hours) post-exit ***/\n        assertRewardsAccounting({\n            account:                address(fay),                                                                     // Account for accounting\n            totalSupply:            0,                                                                                // Ali + Bob withdrew all stake\n            rewardPerTokenStored:   dTime1_rpt + dTime2_rpt + dTime3_rpt + dTime4_rpt,                                // Updated on updateReward\n            userRewardPerTokenPaid: dTime1_rpt + dTime2_rpt + dTime3_rpt + dTime4_rpt,                                // Used so Ali can't do multiple claims\n            earned:                 0,                                                                                // Time-based calculation and userRewardPerTokenPaid cancel out\n            rewards:                0,                                                                                // Updated on updateReward to earned(), then set to zero on getReward\n            rewardTokenBal:         ((dTime1_rpt + dTime2_rpt + dTime3_rpt) * 10 ether + dTime4_rpt * 5 ether) / WAD  // Total earnings from pool (using ether to avoid stack too deep)\n        });\n\n        /*** Bob time = (2 days + 1 hours) post-exit ***/\n        assertRewardsAccounting({\n            account:                address(fez),                                                         // Account for accounting\n            totalSupply:            0,                                                                    // Ali + Bob withdrew all stake\n            rewardPerTokenStored:   dTime1_rpt + dTime2_rpt + dTime3_rpt + dTime4_rpt,                    // Updated on updateReward\n            userRewardPerTokenPaid: dTime1_rpt + dTime2_rpt + dTime3_rpt + dTime4_rpt,                    // Used so Bob can't do multiple claims\n            earned:                 0,                                                                    // Time-based calculation and userRewardPerTokenPaid cancel out\n            rewards:                0,                                                                    // Updated on updateReward to earned(), then set to zero on getReward\n            rewardTokenBal:         (dTime2_rpt * 10 ether + (dTime3_rpt + dTime4_rpt) * 30 ether) / WAD  // Total earnings from pool (using ether to avoid stack too deep)\n        });\n    }\n\n    function test_rewards_multi_epoch() public {\n        fay.increaseCustodyAllowance(address(pool), address(mplRewards), 100 * WAD);\n        fez.increaseCustodyAllowance(address(pool), address(mplRewards), 100 * WAD);\n\n        fay.stake(10 * WAD);\n        fez.stake(30 * WAD);\n\n        /**********************/\n        /*** EPOCH 1 STARTS ***/\n        /**********************/\n\n        gov.setRewardsDuration(30 days);\n\n        mpl.transfer(address(mplRewards), 25_000 * WAD);\n\n        gov.notifyRewardAmount(25_000 * WAD);\n\n        uint256 rewardRate   = mplRewards.rewardRate();\n        uint256 periodFinish = mplRewards.periodFinish();\n        uint256 start        = block.timestamp;\n\n        assertEq(rewardRate, uint256(25_000 * WAD) / 30 days);\n\n        assertEq(periodFinish, start + 30 days);\n\n        hevm.warp(periodFinish);  // Warp to the end of the epoch\n\n        /********************/\n        /*** EPOCH 1 ENDS ***/\n        /********************/\n\n        uint256 dTime1_rpt = rewardRate * 30 days * WAD / (40 * WAD);  // Reward per token (RPT) for all of epoch 1\n\n        /*** Ali time = (30 days) pre-claim ***/\n        assertRewardsAccounting({\n            account:                address(fay),                 // Account for accounting\n            totalSupply:            40 * WAD,                     // Ali + Bob stake\n            rewardPerTokenStored:   0,                            // Not updated yet\n            userRewardPerTokenPaid: 0,                            // Not updated yet\n            earned:                 dTime1_rpt * 10 * WAD / WAD,  // Time-based calculation\n            rewards:                0,                            // Not updated yet\n            rewardTokenBal:         0                             // Total claimed earnings from pool\n        });\n\n        /*** Bob time = (30 days) pre-claim ***/\n        assertRewardsAccounting({\n            account:                address(fez),                 // Account for accounting\n            totalSupply:            40 * WAD,                     // Ali + Bob stake\n            rewardPerTokenStored:   0,                            // Not updated yet\n            userRewardPerTokenPaid: 0,                            // Not updated yet\n            earned:                 dTime1_rpt * 30 * WAD / WAD,  // Time-based calculation\n            rewards:                0,                            // Not updated yet\n            rewardTokenBal:         0                             // Total claimed earnings from pool\n        });\n\n        fay.getReward();  // Ali claims all rewards for epoch 1\n\n        /*** Ali time = (30 days) post-claim ***/\n        assertRewardsAccounting({\n            account:                address(fay),                 // Account for accounting\n            totalSupply:            40 * WAD,                     // Ali + Bob stake\n            rewardPerTokenStored:   dTime1_rpt,                   // Updated on updateReward\n            userRewardPerTokenPaid: dTime1_rpt,                   // Used so Ali can't do multiple claims\n            earned:                 0,                            // Time-based calculation and userRewardPerTokenPaid cancel out\n            rewards:                0,                            // Updated on updateReward to earned(), then set to zero on getReward\n            rewardTokenBal:         dTime1_rpt * 10 * WAD / WAD   // Total claimed earnings from pool\n        });\n\n        assertEq(mplRewards.lastUpdateTime(),           start + 30 days);\n        assertEq(mplRewards.lastTimeRewardApplicable(), start + 30 days);\n\n        hevm.warp(periodFinish + 1 days);  // Warp another day after the epoch is finished\n\n        assertEq(mplRewards.lastUpdateTime(),           start + 30 days);  // Doesn't change\n        assertEq(mplRewards.lastTimeRewardApplicable(), start + 30 days);  // Doesn't change\n\n        /*** Ali time = (31 days) pre-claim (ASSERT NOTHING CHANGES DUE TO EPOCH BEING OVER) ***/\n        assertRewardsAccounting({\n            account:                address(fay),                 // Doesn't change\n            totalSupply:            40 * WAD,                     // Doesn't change\n            rewardPerTokenStored:   dTime1_rpt,                   // Doesn't change\n            userRewardPerTokenPaid: dTime1_rpt,                   // Doesn't change\n            earned:                 0,                            // Doesn't change\n            rewards:                0,                            // Doesn't change\n            rewardTokenBal:         dTime1_rpt * 10 * WAD / WAD   // Doesn't change\n        });\n\n        fay.getReward();  // Ali claims rewards, but epoch 1 is finished\n\n        /*** Ali time = (31 days) post-claim (ASSERT NOTHING CHANGES DUE TO EPOCH BEING OVER) ***/\n        assertRewardsAccounting({\n            account:                address(fay),                 // Doesn't change\n            totalSupply:            40 * WAD,                     // Doesn't change\n            rewardPerTokenStored:   dTime1_rpt,                   // Doesn't change\n            userRewardPerTokenPaid: dTime1_rpt,                   // Doesn't change\n            earned:                 0,                            // Doesn't change\n            rewards:                0,                            // Doesn't change\n            rewardTokenBal:         dTime1_rpt * 10 * WAD / WAD   // Doesn't change\n        });\n\n        /**********************/\n        /*** EPOCH 2 STARTS ***/\n        /**********************/\n\n        assertEq(mpl.balanceOf(address(mplRewards)), 25_000 * WAD - dTime1_rpt * 10 * WAD / WAD);  // Bob's claimable MPL is still in the contract\n\n        gov.setRewardsDuration(15 days);\n\n        mpl.transfer(address(mplRewards), 40_000 * WAD);\n\n        gov.notifyRewardAmount(40_000 * WAD);\n\n        uint256 rewardRate2 = mplRewards.rewardRate(); // New rewardRate\n\n        assertEq(rewardRate2, uint256(40_000 * WAD) / 15 days);\n\n        hevm.warp(block.timestamp + 1 days);  // Warp to 1 day into the second epoch\n\n        uint256 dTime2_rpt = rewardRate2 * 1 days * WAD / (40 * WAD);  // Reward per token (RPT) for one day of epoch 2 (uses the new rewardRate)\n\n        /*** Ali time = (1 days into epoch 2) pre-exit ***/\n        assertRewardsAccounting({\n            account:                address(fay),                 // Account for accounting\n            totalSupply:            40 * WAD,                     // Ali + Bob stake\n            rewardPerTokenStored:   dTime1_rpt,                   // From last epoch\n            userRewardPerTokenPaid: dTime1_rpt,                   // Used so Ali can't do multiple claims\n            earned:                 dTime2_rpt * 10 * WAD / WAD,  // Time-based calculation (epoch 2 earnings)\n            rewards:                0,                            // Not updated yet\n            rewardTokenBal:         dTime1_rpt * 10 * WAD / WAD   // Total claimed earnings from pool\n        });\n\n        /*** Bob time = (1 days into epoch 2) pre-exit ***/\n        assertRewardsAccounting({\n            account:                address(fez),                                // Account for accounting\n            totalSupply:            40 * WAD,                                    // Ali + Bob stake\n            rewardPerTokenStored:   dTime1_rpt,                                  // From last epoch\n            userRewardPerTokenPaid: 0,                                           // Used so Ali can't do multiple claims\n            earned:                 (dTime1_rpt + dTime2_rpt) * 30 * WAD / WAD,  // Time-based calculation (epoch 1 + epoch 2 earnings)\n            rewards:                0,                                           // Not updated yet\n            rewardTokenBal:         0                                            // Total claimed earnings from pool\n        });\n\n        fay.exit();  // Ali exits at time = (1 days into epoch 2)\n        fez.exit();  // Bob exits at time = (1 days into epoch 2)\n\n        /*** Ali time = (1 days into epoch 2) post-exit ***/\n        assertRewardsAccounting({\n            account:                address(fay),                                // Account for accounting\n            totalSupply:            0,                                           // Ali + Bob exited\n            rewardPerTokenStored:   dTime1_rpt + dTime2_rpt,                     // Updated on updateReward\n            userRewardPerTokenPaid: dTime1_rpt + dTime2_rpt,                     // Used so Ali can't do multiple claims\n            earned:                 0,                                           // Time-based calculation and userRewardPerTokenPaid cancel out\n            rewards:                0,                                           // Updated on updateReward to earned(), then set to zero on getReward\n            rewardTokenBal:         (dTime1_rpt + dTime2_rpt) * 10 * WAD / WAD   // Total claimed earnings from pool over both epochs\n        });\n\n        /*** Bob time = (1 days into epoch 2) post-exit ***/\n        assertRewardsAccounting({\n            account:                address(fez),                                // Account for accounting\n            totalSupply:            0,                                           // Ali + Bob exited\n            rewardPerTokenStored:   dTime1_rpt + dTime2_rpt,                     // Updated on updateReward\n            userRewardPerTokenPaid: dTime1_rpt + dTime2_rpt,                     // Used so Bob can't do multiple claims\n            earned:                 0,                                           // Time-based calculation and userRewardPerTokenPaid cancel out\n            rewards:                0,                                           // Updated on updateReward to earned(), then set to zero on getReward\n            rewardTokenBal:         (dTime1_rpt + dTime2_rpt) * 30 * WAD / WAD   // Total claimed earnings from pool over both epochs\n        });\n    }\n}\n"
    },
    "packages/protocol/contracts/test/MapleTreasury.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract MapleTreasuryTest is TestUtil {\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        createHolders();\n\n        mint(\"WBTC\", address(this),  10 * BTC);\n        mint(\"WETH\", address(this),  10 ether);\n        mint(\"DAI\",  address(this), 100 ether);\n        mint(\"USDC\", address(this), 100 * USD);\n    }\n\n    function test_setGlobals() public {\n        MapleGlobals globals2 = fakeGov.createGlobals(address(mpl));                // Create upgraded MapleGlobals\n\n        assertEq(address(treasury.globals()), address(globals));\n\n        assertTrue(!fakeGov.try_setGlobals(address(treasury), address(globals2)));  // Non-governor cannot set new globals\n\n        globals2 = gov.createGlobals(address(mpl));                                 // Create upgraded MapleGlobals\n\n        assertTrue(gov.try_setGlobals(address(treasury), address(globals2)));       // Governor can set new globals\n        assertEq(address(treasury.globals()), address(globals2));                   // Globals is updated\n    }\n\n    function test_withdrawFunds() public {\n        assertEq(IERC20(USDC).balanceOf(address(treasury)), 0);\n\n        IERC20(USDC).transfer(address(treasury), 100 * USD);\n\n        assertEq(IERC20(USDC).balanceOf(address(treasury)), 100 * USD);\n        assertEq(IERC20(USDC).balanceOf(address(gov)),         0);\n\n        assertTrue(!fakeGov.try_reclaimERC20_treasury(USDC, 40 * USD));  // Non-governor can't withdraw\n        assertTrue(     gov.try_reclaimERC20_treasury(USDC, 40 * USD));\n\n        assertEq(IERC20(USDC).balanceOf(address(treasury)), 60 * USD);  // Can be distributed to MPL holders\n        assertEq(IERC20(USDC).balanceOf(address(gov)), 40 * USD);  // Withdrawn to MapleDAO address for funding\n    }\n\n    function test_distributeToHolders() public {\n        assertEq(mpl.balanceOf(address(hal)), 0);\n        assertEq(mpl.balanceOf(address(hue)), 0);\n\n        mpl.transfer(address(hal), mpl.totalSupply() * 25 / 100);  // 25%\n        mpl.transfer(address(hue), mpl.totalSupply() * 75 / 100);  // 75%\n\n        assertEq(mpl.balanceOf(address(hal)), 2_500_000 ether);\n        assertEq(mpl.balanceOf(address(hue)), 7_500_000 ether);\n\n        assertEq(IERC20(USDC).balanceOf(address(treasury)), 0);\n\n        IERC20(USDC).transfer(address(treasury), 100 * USD);\n\n        assertEq(IERC20(USDC).balanceOf(address(treasury)), 100 * USD);\n        assertEq(IERC20(USDC).balanceOf(address(mpl)),              0);\n\n        assertTrue(!fakeGov.try_distributeToHolders());  // Non-governor can't distribute\n        assertTrue(     gov.try_distributeToHolders());  // Governor can distribute\n\n        assertEq(IERC20(USDC).balanceOf(address(treasury)),         0);  // Withdraws all funds\n        assertEq(IERC20(USDC).balanceOf(address(mpl)),      100 * USD);  // Withdrawn to MPL address, where accounts can claim funds\n\n        assertEq(IERC20(USDC).balanceOf(address(hal)), 0);  // Token holder hasn't claimed\n        assertEq(IERC20(USDC).balanceOf(address(hue)), 0);  // Token holder hasn't claimed\n\n        hal.withdrawFunds(address(mpl));\n        hue.withdrawFunds(address(mpl));\n\n        withinDiff(IERC20(USDC).balanceOf(address(hal)), 25 * USD, 1);  // Token holder has claimed proportional share of USDC\n        withinDiff(IERC20(USDC).balanceOf(address(hue)), 75 * USD, 1);  // Token holder has claimed proportional share of USDC\n    }\n\n    function test_convertERC20() public {\n\n        IMapleGlobals _globals = IMapleGlobals(address(globals));\n\n        assertEq(IERC20(WBTC).balanceOf(address(treasury)), 0);\n        assertEq(IERC20(WETH).balanceOf(address(treasury)), 0);\n        assertEq(IERC20(DAI).balanceOf(address(treasury)),  0);\n\n        IERC20(WBTC).transfer(address(treasury), 10 * BTC);\n        IERC20(WETH).transfer(address(treasury), 10 ether);\n        IERC20(DAI).transfer(address(treasury), 100 ether);\n\n        assertEq(IERC20(WBTC).balanceOf(address(treasury)),  10 * BTC);\n        assertEq(IERC20(WETH).balanceOf(address(treasury)),  10 ether);\n        assertEq(IERC20(DAI).balanceOf(address(treasury)),  100 ether);\n        assertEq(IERC20(USDC).balanceOf(address(treasury)),         0);\n\n        uint256 expectedAmtFromWBTC = Util.calcMinAmount(_globals, WBTC, USDC,  10 * BTC);\n        uint256 expectedAmtFromWETH = Util.calcMinAmount(_globals, WETH, USDC,  10 ether);\n        uint256 expectedAmtFromDAI  = Util.calcMinAmount(_globals, DAI,  USDC, 100 ether);\n\n        /*** Convert WBTC ***/\n        assertTrue(!fakeGov.try_convertERC20(WBTC));  // Non-governor can't convert\n        assertTrue(     gov.try_convertERC20(WBTC));  // Governor can convert\n\n        assertEq(IERC20(WBTC).balanceOf(address(treasury)),         0);\n        assertEq(IERC20(DAI).balanceOf(address(treasury)),  100 ether);\n\n        withinPrecision(IERC20(USDC).balanceOf(address(treasury)), expectedAmtFromWBTC, 2);\n\n        gov.distributeToHolders();  // Empty treasury balance of USDC\n\n        /*** Convert WETH ***/\n        assertTrue(!fakeGov.try_convertERC20(WETH));  // Non-governor can't convert\n        assertTrue(     gov.try_convertERC20(WETH));  // Governor can convert\n\n        assertEq(IERC20(WETH).balanceOf(address(treasury)),         0);\n        assertEq(IERC20(DAI).balanceOf(address(treasury)),  100 ether);\n\n        withinPrecision(IERC20(USDC).balanceOf(address(treasury)), expectedAmtFromWETH, 2);\n\n        gov.distributeToHolders();  // Empty treasury balance of USDC\n\n        /*** Convert DAI ***/\n        assertTrue(!fakeGov.try_convertERC20(DAI));  // Non-governor can't convert\n        assertTrue(     gov.try_convertERC20(DAI));  // Governor can convert\n\n        assertEq(IERC20(WETH).balanceOf(address(treasury)), 0);\n        assertEq(IERC20(DAI).balanceOf(address(treasury)),  0);\n\n        withinPrecision(IERC20(USDC).balanceOf(address(treasury)), expectedAmtFromDAI, 2);\n    }\n}\n"
    },
    "packages/protocol/contracts/test/MapleGlobals.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract MapleGlobalsTest is TestUtil {\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpPoolDelegates();\n    }\n\n    function test_constructor() public {\n\n        globals = new MapleGlobals(address(gov), address(mpl), address(1));\n\n        assertEq(globals.governor(),         address(gov));\n        assertEq(globals.mpl(),              address(mpl));\n        assertEq(globals.defaultGracePeriod(),     5 days);\n        assertEq(globals.swapOutRequired(),        10_000);\n        assertEq(globals.fundingPeriod(),         10 days);\n        assertEq(globals.investorFee(),                50);\n        assertEq(globals.treasuryFee(),                50);\n        assertEq(globals.maxSwapSlippage(),          1000);\n        assertEq(globals.minLoanEquity(),            2000);\n        assertEq(globals.globalAdmin(),        address(1));\n    }\n\n    function test_setup() public {\n        assertTrue(globals.isValidPoolDelegate(address(pat)));\n\n        assertTrue(globals.isValidLiquidityAsset(DAI));\n        assertTrue(globals.isValidLiquidityAsset(USDC));\n\n        assertTrue(globals.isValidCollateralAsset(DAI));\n        assertTrue(globals.isValidCollateralAsset(USDC));\n        assertTrue(globals.isValidCollateralAsset(WETH));\n        assertTrue(globals.isValidCollateralAsset(WBTC));\n\n        assertTrue(globals.validCalcs(address(lateFeeCalc)));\n        assertTrue(globals.validCalcs(address(premiumCalc)));\n        assertTrue(globals.validCalcs(address(repaymentCalc)));\n\n        assertTrue(globals.isValidCalc(address(lateFeeCalc),         LATEFEE_CALC_TYPE));\n        assertTrue(globals.isValidCalc(address(premiumCalc),          PREMIUM_CALC_TYPE));\n        assertTrue(globals.isValidCalc(address(repaymentCalc), INTEREST_CALC_TYPE));\n\n        assertTrue(globals.isValidPoolFactory(address(poolFactory)));\n        assertTrue(globals.isValidLoanFactory(address(loanFactory)));\n\n        assertTrue(globals.validSubFactories(address(poolFactory), address(slFactory)));\n        assertTrue(globals.validSubFactories(address(poolFactory), address(llFactory)));\n        assertTrue(globals.validSubFactories(address(poolFactory), address(dlFactory)));\n        assertTrue(globals.validSubFactories(address(loanFactory), address(clFactory)));\n        assertTrue(globals.validSubFactories(address(loanFactory), address(flFactory)));\n\n        assertTrue(globals.isValidSubFactory(address(poolFactory), address(slFactory), SL_FACTORY));\n        assertTrue(globals.isValidSubFactory(address(poolFactory), address(llFactory), LL_FACTORY));\n        assertTrue(globals.isValidSubFactory(address(poolFactory), address(dlFactory), DL_FACTORY));\n        assertTrue(globals.isValidSubFactory(address(loanFactory), address(clFactory), CL_FACTORY));\n        assertTrue(globals.isValidSubFactory(address(loanFactory), address(flFactory), FL_FACTORY));\n    }\n\n    function test_setters() public {\n\n        Governor fakeGov  = new Governor();\n        Governor fakeGov2 = new Governor();\n        fakeGov.setGovGlobals(globals);  // Point to globals created by gov.\n        fakeGov2.setGovGlobals(globals);\n\n        // setValidPoolFactory()\n        assertTrue(!globals.isValidPoolFactory(address(pat)));             // Use dummy address since poolFactory is already valid\n        assertTrue(!fakeGov.try_setValidPoolFactory(address(pat), true));  // Non-governor cant set\n        assertTrue(     gov.try_setValidPoolFactory(address(pat), true));\n        assertTrue( globals.isValidPoolFactory(address(pat)));\n        assertTrue(     gov.try_setValidPoolFactory(address(pat), false));\n        assertTrue(!globals.isValidPoolFactory(address(pat)));\n\n        // setValidLoanFactory()\n        assertTrue(!globals.isValidLoanFactory(address(pat)));             // Use dummy address since loanFactory is already valid\n        assertTrue(!fakeGov.try_setValidLoanFactory(address(pat), true));  // Non-governor cant set\n        assertTrue(     gov.try_setValidLoanFactory(address(pat), true));\n        assertTrue( globals.isValidLoanFactory(address(pat)));\n        assertTrue(     gov.try_setValidLoanFactory(address(pat), false));\n        assertTrue(!globals.isValidLoanFactory(address(pat)));\n\n        // setValidSubFactory()\n        assertTrue( globals.validSubFactories(address(poolFactory), address(dlFactory)));\n        assertTrue(!fakeGov.try_setValidSubFactory(address(poolFactory), address(dlFactory), false));  // Non-governor cant set\n        assertTrue(     gov.try_setValidSubFactory(address(poolFactory), address(dlFactory), false));\n        assertTrue(!globals.validSubFactories(address(poolFactory), address(dlFactory)));\n        assertTrue(     gov.try_setValidSubFactory(address(poolFactory), address(dlFactory), true));\n        assertTrue( globals.validSubFactories(address(poolFactory), address(dlFactory)));\n\n        // setPoolDelegateAllowlist()\n        assertTrue(!globals.isValidPoolDelegate(address(bob)));\n        assertTrue(!fakeGov.try_setPoolDelegateAllowlist(address(bob), true));  // Non-governor cant set\n        assertTrue(     gov.try_setPoolDelegateAllowlist(address(bob), true));\n        assertTrue( globals.isValidPoolDelegate(address(bob)));\n        assertTrue(     gov.try_setPoolDelegateAllowlist(address(bob), false));\n        assertTrue(!globals.isValidPoolDelegate(address(bob)));\n\n        // setDefaultUniswapPath()\n        assertTrue(!fakeGov.try_setDefaultUniswapPath(WETH, USDC, USDC));  // Non-governor cant set\n        assertEq(   globals.defaultUniswapPath(WETH, USDC), address(0));\n        assertEq(   globals.defaultUniswapPath(DAI, USDC), address(0));\n        assertTrue(     gov.try_setDefaultUniswapPath(WETH, USDC, USDC));\n        assertTrue(     gov.try_setDefaultUniswapPath(DAI, USDC, WETH));\n        assertEq(   globals.defaultUniswapPath(WETH, USDC), USDC);\n        assertEq(   globals.defaultUniswapPath(DAI, USDC), WETH);\n\n        // setLiquidityAsset()\n        assertTrue(!globals.isValidLiquidityAsset(WETH));\n        assertTrue(!fakeGov.try_setLiquidityAsset(WETH,  true));  // Non-governor cant set\n        assertTrue(     gov.try_setLiquidityAsset(WETH,  true));\n        assertTrue(globals.isValidLiquidityAsset(WETH));\n        assertTrue(!fakeGov.try_setLiquidityAsset(WETH,  false));  // Non-governor cant set\n        assertTrue(     gov.try_setLiquidityAsset(WETH,  false));\n        assertTrue(!globals.isValidLiquidityAsset(WETH));\n\n        // setCollateralAsset()\n        assertTrue(!globals.isValidCollateralAsset(CDAI));\n        assertTrue(!fakeGov.try_setCollateralAsset(CDAI,   true));  // Non-governor cant set\n        assertTrue(     gov.try_setCollateralAsset(CDAI,   true));\n        assertTrue( globals.isValidCollateralAsset(CDAI));\n        assertTrue(!fakeGov.try_setCollateralAsset(CDAI,   false));  // Non-governor cant set\n        assertTrue(     gov.try_setCollateralAsset(CDAI,   false));\n        assertTrue(!globals.isValidCollateralAsset(CDAI));\n\n        // setCalc()\n        assertTrue( globals.validCalcs(address(repaymentCalc)));\n        assertTrue(!fakeGov.try_setCalc(address(repaymentCalc), false));  // Non-governor cant set\n        assertTrue(     gov.try_setCalc(address(repaymentCalc), false));\n        assertTrue(!globals.validCalcs(address(repaymentCalc)));\n\n        // setInvestorFee()\n        assertTrue(     gov.try_setInvestorFee(     0));  // Set to zero to test upper bound condition for treasuryFee\n        assertTrue(     gov.try_setTreasuryFee(     0));  // Set to zero to test upper bound condition for investorFee\n\n        assertEq(   globals.investorFee(),          0);\n        assertTrue(!fakeGov.try_setInvestorFee(10_000));  // Non-governor cant set\n        assertTrue(    !gov.try_setInvestorFee(10_001));  // 100.01% is outside of bounds\n        assertTrue(     gov.try_setInvestorFee(10_000));  // 100% is upper bound\n        assertEq(   globals.investorFee(),     10_000);\n        assertTrue(     gov.try_setInvestorFee(     0));  // Set to zero to test combined condition\n\n        // setTreasuryFee()\n        assertEq(   globals.treasuryFee(),          0);\n        assertTrue(!fakeGov.try_setTreasuryFee(10_000));  // Non-governor cant set\n        assertTrue(    !gov.try_setTreasuryFee(10_001));  // 100.01% is outside of bounds\n        assertTrue(     gov.try_setTreasuryFee(10_000));  // 100% is upper bound\n        assertEq(   globals.treasuryFee(),     10_000);\n        assertTrue(     gov.try_setTreasuryFee(     0));  // Set to zero to test combined condition\n\n        // investorFee + treasuryFee <= 100%\n        assertTrue(     gov.try_setInvestorFee(5_000));     // 100% is combined upper bound\n        assertTrue(     gov.try_setTreasuryFee(5_000));     // 100% is combined upper bound\n        assertTrue(    !gov.try_setInvestorFee(5_001));     // 100% is combined upper bound\n        assertTrue(    !gov.try_setTreasuryFee(5_001));     // 100% is combined upper bound\n        assertTrue(    !gov.try_setInvestorFee(MAX_UINT));  // Attempt overflow\n        assertTrue(    !gov.try_setTreasuryFee(MAX_UINT));  // Attempt overflow\n\n        // setStakerCooldownPeriod()\n        assertEq(   globals.stakerCooldownPeriod(),     10 days);\n        assertTrue(!fakeGov.try_setStakerCooldownPeriod( 1 days));\n        assertTrue(     gov.try_setStakerCooldownPeriod( 1 days));\n        assertEq(   globals.stakerCooldownPeriod(),      1 days);\n\n        // setLpCooldownPeriod()\n        assertEq(   globals.lpCooldownPeriod(),     10 days);\n        assertTrue(!fakeGov.try_setLpCooldownPeriod( 1 days));\n        assertTrue(     gov.try_setLpCooldownPeriod (1 days));\n        assertEq(   globals.lpCooldownPeriod(),      1 days);\n\n        // setStakerUnstakeWindow()\n        assertEq(   globals.stakerUnstakeWindow(),     2 days);\n        assertTrue(!fakeGov.try_setStakerUnstakeWindow(1 days));\n        assertTrue(     gov.try_setStakerUnstakeWindow(1 days));\n        assertEq(   globals.stakerUnstakeWindow(),     1 days);\n\n        // setLpWithdrawWindow()\n        assertEq(   globals.lpWithdrawWindow(),     2 days);\n        assertTrue(!fakeGov.try_setLpWithdrawWindow(1 days));\n        assertTrue(     gov.try_setLpWithdrawWindow(1 days));\n        assertEq(   globals.lpWithdrawWindow(),     1 days);\n\n        // setFundingPeriod()\n        assertEq(   globals.fundingPeriod(),    10 days);\n        assertTrue(!fakeGov.try_setFundingPeriod(1 days));\n        assertTrue(     gov.try_setFundingPeriod(1 days));\n        assertEq(   globals.fundingPeriod(),     1 days);\n\n        // setDefaultGracePeriod()\n        assertEq(   globals.defaultGracePeriod(),     5 days);\n        assertTrue(!fakeGov.try_setDefaultGracePeriod(1 days));\n        assertTrue(     gov.try_setDefaultGracePeriod(1 days));\n        assertEq(   globals.defaultGracePeriod(),     1 days);\n\n        // setSwapOutRequired()\n        assertEq(   globals.swapOutRequired(),     10_000);\n        assertTrue(!fakeGov.try_setSwapOutRequired(15_000));\n        assertTrue(    !gov.try_setSwapOutRequired( 9_999));  // Lower bound is $10,000 of pool cover\n        assertTrue(     gov.try_setSwapOutRequired(15_000));\n        assertEq(   globals.swapOutRequired(),     15_000);\n        assertTrue(     gov.try_setSwapOutRequired(10_000));  // Lower bound is $10,000 of pool cover\n        assertEq(   globals.swapOutRequired(),     10_000);\n\n        // setMapleTreasury()\n        assertEq(   globals.mapleTreasury(), address(treasury));\n        assertTrue(!fakeGov.try_setMapleTreasury(address(this)));\n        assertTrue(    !gov.try_setMapleTreasury(address(0)));\n        assertTrue(     gov.try_setMapleTreasury(address(this)));\n        assertEq(   globals.mapleTreasury(), address(this));\n\n        // setPriceOracle()\n        assertTrue(!fakeGov.try_setPriceOracle(WETH, address(1)));\n        assertTrue(     gov.try_setPriceOracle(WETH, address(wethOracle)));\n        assertTrue(     gov.try_setPriceOracle(WBTC, address(wbtcOracle)));\n        assertEq(globals.oracleFor(WETH),            address(wethOracle));\n        assertEq(globals.oracleFor(WBTC),            address(wbtcOracle));\n\n        assertTrue(globals.getLatestPrice(WETH) != 0); // Shows real WETH value from Chainlink\n        assertTrue(globals.getLatestPrice(WBTC) != 0); // Shows real WBTC value from Chainlink\n\n        // setMaxSwapSlippage()\n        assertEq(   globals.maxSwapSlippage(),      1_000);\n        assertTrue(!fakeGov.try_setMaxSwapSlippage(10_000));\n        assertTrue(    !gov.try_setMaxSwapSlippage(10_001));  // 100.01% is outside of bounds\n        assertTrue(     gov.try_setMaxSwapSlippage(10_000));  // 100% is upper bound\n        assertEq(   globals.maxSwapSlippage(),     10_000);\n\n        // setValidBalancerPool()\n        assertTrue(!globals.isValidBalancerPool(address(1)));\n        assertTrue(!fakeGov.try_setValidBalancerPool(address(1), true));\n        assertTrue(     gov.try_setValidBalancerPool(address(1), true));\n        assertTrue( globals.isValidBalancerPool(address(1)));\n\n        // setMinLoanEquity\n        assertEq(   globals.minLoanEquity(),      2_000);\n        assertTrue(!fakeGov.try_setMinLoanEquity(10_000));\n        assertTrue(    !gov.try_setMinLoanEquity(10_001));  // 100.01% is outside of bounds\n        assertTrue(     gov.try_setMinLoanEquity(10_000));  // 99.99 %\n        assertEq(   globals.minLoanEquity(),     10_000);   // 100% is upper bound\n    }\n\n    function test_transfer_governor() public {\n        Governor fakeGov  = new Governor();\n        Governor fakeGov2 = new Governor();\n        fakeGov.setGovGlobals(globals);  // Point to globals created by gov.\n        fakeGov2.setGovGlobals(globals);\n\n        // Transfer Governor\n        assertTrue( !fakeGov.try_setPendingGovernor(address(fakeGov)));\n        assertTrue(     !gov.try_setPendingGovernor(address(0)));       // Cannot set governor to zero\n        assertTrue(      gov.try_setPendingGovernor(address(fakeGov2)));\n        assertTrue(      gov.try_setPendingGovernor(address(fakeGov)));\n        assertEq(    globals.pendingGovernor(), address(fakeGov));\n        assertEq(    globals.governor(), address(gov));\n        assertTrue( !fakeGov.try_setPendingGovernor(address(fakeGov2)));  // Trying to assign the permission to someone else.\n        assertTrue(!fakeGov2.try_acceptGovernor());\n        assertTrue(  fakeGov.try_acceptGovernor());\n        assertEq(    globals.governor(), address(fakeGov));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/LoanLiquidation.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract LoanLiquidationTest is TestUtil {\n\n    function setUp() public {\n\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpActors();\n        setUpBalancerPool();\n        setUpLiquidityPool();\n        createLoans();\n\n        /*** Mint balances to relevant actors ***/\n        mint(\"WETH\", address(bob),         100 ether);\n        mint(\"WBTC\", address(bob),          10 * BTC);\n        mint(\"USDC\", address(leo),     100_000 * USD);\n        mint(\"USDC\", address(bob),     100_000 * USD);\n        mint(\"USDC\", address(this), 50_000_000 * USD);\n\n        /*** LP deposits USDC into Pool ***/\n        leo.approve(USDC, address(pool), MAX_UINT);\n        leo.deposit(address(pool), 5000 * USD);\n    }\n\n    function createAndFundLoan(address _interestStructure, address _collateral, uint256 collateralRatio) internal returns (Loan loan) {\n        uint256[5] memory specs = [500, 90, 30, uint256(1000 * USD), collateralRatio];\n        address[3] memory calcs = [_interestStructure, address(lateFeeCalc), address(premiumCalc)];\n\n        loan = bob.createLoan(address(loanFactory), USDC, _collateral, address(flFactory), address(clFactory), specs, calcs);\n\n        pat.fundLoan(address(pool), address(loan), address(dlFactory), 1000 * USD);\n\n        bob.approve(_collateral, address(loan), MAX_UINT);\n        assertTrue(bob.try_drawdown(address(loan), 1000 * USD));     // Borrow draws down 1000 USDC\n    }\n\n    function performLiquidationAssertions(Loan loan) internal {\n        // Fetch pre-state variables.\n        address collateralLocker  = loan.collateralLocker();\n        address collateralAsset   = address(loan.collateralAsset());\n        uint256 collateralBalance = IERC20(collateralAsset).balanceOf(address(collateralLocker));\n\n        uint256 principalOwed_pre      = loan.principalOwed();\n        uint256 liquidityAssetLoan_pre = IERC20(USDC).balanceOf(address(loan));\n        uint256 liquidityAssetBorr_pre = IERC20(USDC).balanceOf(address(bob));\n\n        // Warp to late payment.\n        hevm.warp(block.timestamp + loan.nextPaymentDue() + globals.defaultGracePeriod() + 1);\n\n        // Pre-state triggerDefault() checks.\n        assertEq(uint256(loan.loanState()),                                                     1);\n        assertEq(IERC20(collateralAsset).balanceOf(address(collateralLocker)),  collateralBalance);\n\n        pat.triggerDefault(address(pool), address(loan), address(dlFactory));\n\n        {\n            uint256 principalOwed_post      = loan.principalOwed();\n            uint256 liquidityAssetLoan_post = IERC20(USDC).balanceOf(address(loan));\n            uint256 liquidityAssetBorr_post = IERC20(USDC).balanceOf(address(bob));\n            uint256 amountLiquidated        = loan.amountLiquidated();\n            uint256 amountRecovered         = loan.amountRecovered();\n            uint256 defaultSuffered         = loan.defaultSuffered();\n            uint256 liquidationExcess       = loan.liquidationExcess();\n\n            // Post-state triggerDefault() checks.\n            assertEq(uint256(loan.loanState()),                                     4);\n            assertEq(IERC20(collateralAsset).balanceOf(address(collateralLocker)),  0);\n            assertEq(amountLiquidated,                              collateralBalance);\n\n            if (amountRecovered > principalOwed_pre) {\n                assertEq(liquidityAssetBorr_post - liquidityAssetBorr_pre, liquidationExcess);\n                assertEq(principalOwed_post,                                               0);\n                assertEq(liquidationExcess,              amountRecovered - principalOwed_pre);\n                assertEq(defaultSuffered,                                                  0);\n                assertEq(\n                    amountRecovered,\n                    (liquidityAssetBorr_post - liquidityAssetBorr_pre) + (liquidityAssetLoan_post - liquidityAssetLoan_pre)\n                );\n            }\n            else {\n                assertEq(principalOwed_post,             principalOwed_pre - amountRecovered);\n                assertEq(defaultSuffered,                                 principalOwed_post);\n                assertEq(liquidationExcess,                                                0);\n                assertEq(amountRecovered,   liquidityAssetLoan_post - liquidityAssetLoan_pre);\n            }\n        }\n    }\n\n    function test_basic_liquidation() public {\n        // Triangular uniswap path\n        Loan wbtcLoan = createAndFundLoan(address(repaymentCalc), WBTC, 2000);\n        performLiquidationAssertions(wbtcLoan);\n\n        // Bilateral uniswap path\n        Loan wethLoan = createAndFundLoan(address(repaymentCalc), WETH, 2000);\n        performLiquidationAssertions(wethLoan);\n\n        // collateralAsset == liquidityAsset\n        Loan usdcLoan = createAndFundLoan(address(repaymentCalc), USDC, 2000);\n        performLiquidationAssertions(usdcLoan);\n\n        // Zero collateralization\n        Loan wethLoan2 = createAndFundLoan(address(repaymentCalc), WETH, 0);\n        performLiquidationAssertions(wethLoan2);\n    }\n}\n"
    },
    "packages/protocol/contracts/test/LoanFactory.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract LoanFactoryTest is TestUtil {\n\n    using SafeMath for uint256;\n\n\n    function setUp() public {\n        setUpGlobals();\n        setUpCalcs();\n        setUpTokens();\n        createBorrower();\n        setUpFactories();\n    }\n\n    function test_setGlobals() public {\n        Governor fakeGov = new Governor();\n\n        MapleGlobals globals2 = fakeGov.createGlobals(address(mpl));  // Create upgraded MapleGlobals\n\n        assertEq(address(loanFactory.globals()), address(globals));\n\n        assertTrue(!fakeGov.try_setGlobals(address(loanFactory), address(globals2)));  // Non-governor cannot set new globals\n\n        globals2 = gov.createGlobals(address(mpl));      // Create upgraded MapleGlobals\n\n        assertTrue(gov.try_setGlobals(address(loanFactory), address(globals2)));       // Governor can set new globals\n        assertEq(address(loanFactory.globals()), address(globals2));                   // Globals is updated\n    }\n\n    function test_createLoan_invalid_locker_factories() public {\n        gov.setValidSubFactory(address(loanFactory), address(flFactory), false);\n        gov.setValidSubFactory(address(loanFactory), address(clFactory), false);\n        gov.setValidLoanFactory(address(loanFactory),                    false);\n\n        uint256[5] memory specs = [10, 10, 2, 10_000_000 * USD, 30];\n\n        assertTrue(!bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(loanFactory.loansCreated(), 0, \"Colluded state\");  // Should be 0.\n\n        // Add flFactory in valid list\n        gov.setValidLoanFactory(address(loanFactory), true);\n        gov.setValidSubFactory(address(loanFactory), address(flFactory), true);\n\n        // Still fails as clFactory isn't a valid factory.\n        assertTrue(!bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(loanFactory.loansCreated(), 0, \"Colluded state\");  // Should be 0.\n        gov.setValidSubFactory(address(loanFactory), address(clFactory), true);  // Add clFactory in the valid list.\n\n        // Should successfully created\n        assertTrue(bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(loanFactory.loansCreated(), 1, \"Incorrect loan instantiation\");  // Should be incremented by 1.\n    }\n\n    function test_createLoan_invalid_calc_types() public {\n        uint256[5] memory specs = [10, 10, 2, 10_000_000 * USD, 30];\n\n        assertTrue(!bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, [calcs[1], calcs[1], calcs[2]]));\n        assertEq(loanFactory.loansCreated(), 0, \"Colluded state\");  // Should be 0.\n\n        // Incorrect type for second calculator contract.\n        assertTrue(!bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, [calcs[0], calcs[2], calcs[2]]));\n        assertEq(loanFactory.loansCreated(), 0, \"Colluded state\");  // Should be 0.\n\n        // Incorrect type for third calculator contract.\n        assertTrue(!bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, [calcs[0], calcs[1], calcs[0]]));\n        assertEq(loanFactory.loansCreated(), 0, \"Colluded state\");  // Should be 0.\n\n        // Should successfully created\n        assertTrue(bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(loanFactory.loansCreated(), 1, \"Incorrect loan instantiation\");  // Should be incremented by 1.\n    }\n\n    function test_createLoan_invalid_assets_and_specs() public {\n        uint256[5] memory specs = [10, 10, 2, 10_000_000 * USD, 30];\n\n        gov.setLiquidityAsset(USDC,  false);\n        gov.setCollateralAsset(WETH, false);\n\n        assertTrue(!bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(loanFactory.loansCreated(), 0, \"Colluded state\");  // Should be 0.\n\n        gov.setLiquidityAsset(USDC, true);  // Allow loan asset\n        // Still fails as collateral asset is not a valid collateral asset\n        assertTrue(!bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(loanFactory.loansCreated(), 0, \"Colluded state\");  // Should be 0.\n\n        gov.setCollateralAsset(WETH, true);  // Set collateral asset.\n        // Still fails as loan asset can't be 0x0\n        assertTrue(!bob.try_createLoan(address(loanFactory), address(0), WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(loanFactory.loansCreated(), 0, \"Colluded state\");  // Should be 0.\n\n        // Fails because of error - ERR_PAYMENT_INTERVAL_DAYS_EQUALS_ZERO\n        assertTrue(!bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), [10, 10, 0, 10_000_000 * USD, 30], calcs));\n        assertEq(loanFactory.loansCreated(), 0, \"Colluded state\");  // Should be 0.\n\n        // Fails because of error - ERR_INVALID_TERM_AND_PAYMENT_INTERVAL_DIVISION\n        assertTrue(!bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), [10, 19, 2, 10_000_000 * USD, 30], calcs));\n        assertEq(loanFactory.loansCreated(), 0, \"Colluded state\");  // Should be 0.\n\n        // Fails because of error - ERR_REQUEST_AMT_EQUALS_ZERO\n        assertTrue(!bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), [uint256(10), 10, 2, uint256(0), 30], calcs));\n        assertEq(loanFactory.loansCreated(), 0, \"Colluded state\");  // Should be 0.\n\n        // Should successfully created\n        assertTrue(bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(loanFactory.loansCreated(), 1, \"Incorrect loan instantiation\");  // Should be incremented by 1.\n    }\n\n    function test_createLoan_paused() public {\n        uint256[5] memory specs = [10, 10, 2, 10_000_000 * USD, 30];\n\n        // Pause LoanFactory and attempt createLoan()\n        assertTrue(      gov.try_pause(address(loanFactory)));\n        assertTrue(!bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(   loanFactory.loansCreated(), 0);\n\n        // Unpause LoanFactory and createLoan()\n        assertTrue(     gov.try_unpause(address(loanFactory)));\n        assertTrue(bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(  loanFactory.loansCreated(), 1);\n\n        // Pause protocol and attempt createLoan()\n        assertTrue(      emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(   loanFactory.loansCreated(), 1);\n\n        // Unpause protocol and createLoan()\n        assertTrue(     emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(  loanFactory.loansCreated(), 2);\n    }\n\n    function test_createLoan_successfully() public {\n        uint256[5] memory specs = [10, 10, 2, 10_000_000 * USD, 30];\n\n        // Verify the loan gets created successfully.\n        assertTrue(bob.try_createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs));\n        assertEq(loanFactory.loansCreated(), 1, \"Incorrect loan instantiation\");  // Should be incremented by 1.\n        ILoan loan = ILoan(loanFactory.loans(0));                                 // Initial value of loansCreated.\n        assertTrue(loanFactory.isLoan(address(loan)));                            // Should be considered as a loan.\n\n        // Verify the storage of loan contract\n        assertEq(loan.borrower(),                  address(bob), \"Incorrect borrower\");\n        assertEq(address(loan.liquidityAsset()),   USDC, \"Incorrect loan asset\");\n        assertEq(address(loan.collateralAsset()),  WETH, \"Incorrect collateral asset\");\n        assertEq(loan.flFactory(),                 address(flFactory), \"Incorrect FLF\");\n        assertEq(loan.clFactory(),                 address(clFactory), \"Incorrect CLF\");\n        assertEq(loan.createdAt(),                 block.timestamp, \"Incorrect created at timestamp\");\n        assertEq(loan.apr(),                       specs[0], \"Incorrect APR\");\n        assertEq(loan.termDays(),                  specs[1], \"Incorrect term days\");\n        assertEq(loan.paymentsRemaining(),         specs[1].div(specs[2]), \"Incorrect payments remaining\");\n        assertEq(loan.paymentIntervalSeconds(),    specs[2].mul(1 days), \"Incorrect payment interval in seconds\");\n        assertEq(loan.requestAmount(),             specs[3], \"Incorrect request amount value\");\n        assertEq(loan.collateralRatio(),           specs[4], \"Incorrect collateral ratio\");\n        assertEq(loan.fundingPeriod(),             globals.fundingPeriod(), \"Incorrect funding period in seconds\");\n        assertEq(loan.defaultGracePeriod(),        globals.defaultGracePeriod(), \"Incorrect default grace period in seconds\");\n        assertEq(loan.repaymentCalc(),             calcs[0], \"Incorrect repayment calculator\");\n        assertEq(loan.lateFeeCalc(),               calcs[1], \"Incorrect late fee calculator\");\n        assertEq(loan.premiumCalc(),               calcs[2], \"Incorrect premium calculator\");\n        assertEq(loan.superFactory(),              address(loanFactory), \"Incorrect super factory address\");\n    }\n}\n"
    },
    "packages/protocol/contracts/test/Loan.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract LoanTest is TestUtil {\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpActors();\n        setUpBalancerPool();\n        setUpLiquidityPool();\n        createLoan();\n    }\n\n    function assertLoanState(\n        Loan loan,\n        uint256 loanState,\n        uint256 principalOwed,\n        uint256 principalPaid,\n        uint256 interestPaid,\n        uint256 loanBalance,\n        uint256 paymentsRemaining,\n        uint256 nextPaymentDue\n    )\n        internal\n    {\n        assertEq(uint256(loan.loanState()),             loanState);\n        assertEq(loan.principalOwed(),              principalOwed);\n        assertEq(loan.principalPaid(),              principalPaid);\n        assertEq(loan.interestPaid(),                interestPaid);\n        assertEq(usdc.balanceOf(address(loan)),       loanBalance);\n        assertEq(loan.paymentsRemaining(),      paymentsRemaining);\n        assertEq(loan.nextPaymentDue(),            nextPaymentDue);\n    }\n\n    function drawdown(Loan loan, uint256 drawdownAmount) internal returns (uint256 reqCollateral) {\n        reqCollateral = loan.collateralRequiredForDrawdown(drawdownAmount);\n        mint(\"WETH\", address(bob), reqCollateral);\n        bob.approve(WETH, address(loan), reqCollateral);\n        assertTrue(bob.try_drawdown(address(loan), drawdownAmount));  // Borrow draws down on loan\n    }\n\n    function test_createLoan(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio\n    )\n        public\n    {\n        uint256[5] memory specs = getFuzzedSpecs(apr, index, numPayments, requestAmount, collateralRatio);\n        address[3] memory calcs = [address(repaymentCalc), address(lateFeeCalc), address(premiumCalc)];\n\n        Loan loan = bob.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs);\n\n        assertEq(address(loan.liquidityAsset()),   USDC);\n        assertEq(address(loan.collateralAsset()),  WETH);\n        assertEq(loan.flFactory(),                 address(flFactory));\n        assertEq(loan.clFactory(),                 address(clFactory));\n        assertEq(loan.borrower(),                  address(bob));\n        assertEq(loan.createdAt(),                 block.timestamp);\n        assertEq(loan.apr(),                       specs[0]);\n        assertEq(loan.termDays(),                  specs[1]);\n        assertEq(loan.paymentsRemaining(),         specs[1] / specs[2]);\n        assertEq(loan.paymentIntervalSeconds(),    specs[2] * 1 days);\n        assertEq(loan.requestAmount(),             specs[3]);\n        assertEq(loan.collateralRatio(),           specs[4]);\n        assertEq(loan.fundingPeriod(),             globals.fundingPeriod());\n        assertEq(loan.defaultGracePeriod(),        globals.defaultGracePeriod());\n        assertEq(loan.repaymentCalc(),             address(repaymentCalc));\n        assertEq(loan.lateFeeCalc(),               address(lateFeeCalc));\n        assertEq(loan.premiumCalc(),               address(premiumCalc));\n    }\n\n    function test_fundLoan(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio,\n        uint256 fundAmount,\n        uint256 fundAmount2\n    )\n        public\n    {\n        uint256[5] memory specs = getFuzzedSpecs(apr, index, numPayments, requestAmount, collateralRatio);\n        address[3] memory calcs = [address(repaymentCalc), address(lateFeeCalc), address(premiumCalc)];\n\n        Loan loan = bob.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs);\n\n        address fundingLocker   = loan.fundingLocker();\n        address liquidityLocker = pool.liquidityLocker();\n\n        fundAmount = constrictToRange(fundAmount, 1 * USD, 1E10 * USD);\n        uint256 wadAmount = fundAmount * WAD / USD;\n\n        fundAmount2 = constrictToRange(fundAmount, 1 * USD, 1E10 * USD);\n        uint256 wadAmount2 = fundAmount2 * WAD / USD;\n\n        mint(\"USDC\", address(leo),       (fundAmount + fundAmount2));\n        leo.approve(USDC, address(pool), (fundAmount + fundAmount2));\n        leo.deposit(address(pool),       (fundAmount + fundAmount2));\n\n        // Note: Cannot do pre-state check for LoanFDT balance of debtLocker since it is not instantiated\n        assertEq(usdc.balanceOf(address(fundingLocker)),                            0);\n        assertEq(usdc.balanceOf(address(liquidityLocker)), (fundAmount + fundAmount2));\n\n        // Loan-specific pause by Borrower\n        assertTrue(!loan.paused());\n        assertTrue(!cam.try_pause(address(loan)));\n        assertTrue( bob.try_pause(address(loan)));\n        assertTrue(loan.paused());\n        assertTrue(!pat.try_fundLoan(address(pool), address(loan), address(dlFactory), fundAmount));  // Allow for two fundings\n\n        assertTrue(!cam.try_unpause(address(loan)));\n        assertTrue( bob.try_unpause(address(loan)));\n        assertTrue(!loan.paused());\n\n        uint256 start = block.timestamp;\n\n        hevm.warp(start + globals.fundingPeriod() + 1);  // Warp to past fundingPeriod, loan cannot be funded\n        assertTrue(!pat.try_fundLoan(address(pool), address(loan), address(dlFactory), fundAmount));\n\n        hevm.warp(start + globals.fundingPeriod());  // Warp to fundingPeriod, loan can be funded\n        assertTrue(pat.try_fundLoan(address(pool), address(loan), address(dlFactory), fundAmount));\n\n        address debtLocker = pool.debtLockers(address(loan), address(dlFactory));\n\n        assertEq(loan.balanceOf(address(debtLocker)),        wadAmount);\n        assertEq(usdc.balanceOf(address(fundingLocker)),    fundAmount);\n        assertEq(usdc.balanceOf(address(liquidityLocker)), fundAmount2);\n\n        // Protocol-wide pause by Emergency Admin\n        assertTrue(!cam.try_setProtocolPause(address(globals), true));\n        assertTrue( emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(globals.protocolPaused());\n        assertTrue(!pat.try_fundLoan(address(pool), address(loan), address(dlFactory), fundAmount2));\n\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(!globals.protocolPaused());\n        assertTrue(pat.try_fundLoan(address(pool), address(loan), address(dlFactory), fundAmount2));\n\n        assertEq(loan.balanceOf(address(debtLocker)),        wadAmount + wadAmount2);\n        assertEq(usdc.balanceOf(address(fundingLocker)),   fundAmount + fundAmount2);\n        assertEq(usdc.balanceOf(address(liquidityLocker)),                        0);\n    }\n\n    function createAndFundLoan(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio,\n        uint256 fundAmount\n    )\n        internal returns (Loan loan)\n    {\n        uint256[5] memory specs = getFuzzedSpecs(apr, index, numPayments, requestAmount, collateralRatio);\n        address[3] memory calcs = [address(repaymentCalc), address(lateFeeCalc), address(premiumCalc)];\n\n        loan = bob.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory), specs, calcs);\n\n        fundAmount = constrictToRange(fundAmount, specs[3], 1E10 * USD, true);  // Fund between requestAmount and 10b USD\n        uint256 wadAmount = fundAmount * WAD / USD;\n\n        mint(\"USDC\", address(leo),       fundAmount);\n        leo.approve(USDC, address(pool), fundAmount);\n        leo.deposit(address(pool),       fundAmount);\n\n        pat.fundLoan(address(pool), address(loan), address(dlFactory), fundAmount);\n    }\n\n    function test_collateralRequiredForDrawdown(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio,\n        uint256 fundAmount,\n        uint256 drawdownAmount\n    )\n        public\n    {\n        Loan loan = createAndFundLoan(apr, index, numPayments, requestAmount, collateralRatio, fundAmount);\n\n        address fundingLocker = loan.fundingLocker();\n\n        drawdownAmount = constrictToRange(drawdownAmount, 1 * USD, usdc.balanceOf(fundingLocker));\n        uint256 collateralValue = drawdownAmount * loan.collateralRatio() / 10_000;\n\n        uint256 reqCollateral = loan.collateralRequiredForDrawdown(drawdownAmount);\n        withinDiff(reqCollateral * globals.getLatestPrice(WETH) * USD / WAD / 10 ** 8, collateralValue, 1);\n    }\n\n    function test_drawdown(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio,\n        uint256 fundAmount,\n        uint256 drawdownAmount\n    )\n        public\n    {\n        Loan loan = createAndFundLoan(apr, index, numPayments, requestAmount, collateralRatio, fundAmount);\n        address fundingLocker = loan.fundingLocker();\n        fundAmount = usdc.balanceOf(fundingLocker);\n\n        drawdownAmount = constrictToRange(drawdownAmount, loan.requestAmount(), fundAmount, true);\n\n        assertTrue(!ben.try_drawdown(address(loan), drawdownAmount));                                  // Non-borrower can't drawdown\n        if (loan.collateralRatio() > 0) assertTrue(!bob.try_drawdown(address(loan), drawdownAmount));  // Can't drawdown without approving collateral\n\n        uint256 reqCollateral = loan.collateralRequiredForDrawdown(drawdownAmount);\n        mint(\"WETH\", address(bob),       reqCollateral);\n        bob.approve(WETH, address(loan), reqCollateral);\n\n        assertTrue(!bob.try_drawdown(address(loan), loan.requestAmount() - 1));  // Can't drawdown less than requestAmount\n        assertTrue(!bob.try_drawdown(address(loan),           fundAmount + 1));  // Can't drawdown more than fundingLocker balance\n\n        uint256 pre = usdc.balanceOf(address(bob));\n\n        assertEq(weth.balanceOf(address(bob)),  reqCollateral);  // Borrower collateral balance\n        assertEq(usdc.balanceOf(fundingLocker),    fundAmount);  // FundingLocker liquidityAsset balance\n        assertEq(usdc.balanceOf(address(loan)),             0);  // Loan liquidityAsset balance\n        assertEq(loan.principalOwed(),                      0);  // Principal owed\n        assertEq(uint256(loan.loanState()),                 0);  // Loan state: Ready\n\n        // Fee related variables pre-check.\n        assertEq(loan.feePaid(),                            0);  // feePaid amount\n        assertEq(loan.excessReturned(),                     0);  // excessReturned amount\n        assertEq(usdc.balanceOf(address(treasury)),         0);  // Treasury liquidityAsset balance\n\n        // Pause protocol and attempt drawdown()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!bob.try_drawdown(address(loan), drawdownAmount));\n\n        // Unpause protocol and drawdown()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(bob.try_drawdown(address(loan), drawdownAmount));\n\n        assertEq(weth.balanceOf(address(bob)),                                 0);  // Borrower collateral balance\n        assertEq(weth.balanceOf(address(loan.collateralLocker())), reqCollateral);  // CollateralLocker collateral balance\n\n        uint256 investorFee = drawdownAmount * globals.investorFee() / 10_000;\n        uint256 treasuryFee = drawdownAmount * globals.treasuryFee() / 10_000;\n\n        assertEq(usdc.balanceOf(fundingLocker),                                         0);  // FundingLocker liquidityAsset balance\n        assertEq(usdc.balanceOf(address(loan)), fundAmount - drawdownAmount + investorFee);  // Loan liquidityAsset balance\n        assertEq(loan.principalOwed(),                                     drawdownAmount);  // Principal owed\n        assertEq(uint256(loan.loanState()),                                             1);  // Loan state: Active\n\n        withinDiff(usdc.balanceOf(address(bob)), drawdownAmount - (investorFee + treasuryFee), 1); // Borrower liquidityAsset balance\n\n        assertEq(loan.nextPaymentDue(), block.timestamp + loan.paymentIntervalSeconds());  // Next payment due timestamp calculated from time of drawdown\n\n        // Fee related variables post-check.\n        assertEq(loan.feePaid(),                                    investorFee);  // Drawdown amount\n        assertEq(loan.excessReturned(),             fundAmount - drawdownAmount);  // Principal owed\n        assertEq(usdc.balanceOf(address(treasury)),                 treasuryFee);  // Treasury loanAsset balance\n\n        // Test FDT accounting\n        address debtLocker = pool.debtLockers(address(loan), address(dlFactory));\n        assertEq(loan.balanceOf(debtLocker), fundAmount * WAD / USD);\n        withinDiff(loan.withdrawableFundsOf(address(debtLocker)), fundAmount - drawdownAmount + investorFee, 1);\n\n        // Can't drawdown() loan after it has already been called.\n        assertTrue(!bob.try_drawdown(address(loan), drawdownAmount));\n    }\n\n    function test_makePayment(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio,\n        uint256 fundAmount,\n        uint256 drawdownAmount\n    )\n        public\n    {\n        Loan loan = createAndFundLoan(apr, index, numPayments, requestAmount, collateralRatio, fundAmount);  // Const three payments used for this test\n        address fundingLocker = loan.fundingLocker();\n        fundAmount = usdc.balanceOf(fundingLocker);\n\n        drawdownAmount = constrictToRange(drawdownAmount, loan.requestAmount(), fundAmount, true);\n\n        assertEq(uint256(loan.loanState()), 0);  // Loan state: Ready\n\n        assertTrue(!bob.try_makePayment(address(loan)));  // Can't makePayment when State != Active\n\n        // Approve collateral and drawdown loan.\n        uint256 reqCollateral = drawdown(loan, drawdownAmount);\n        uint256 loanPreBal    = usdc.balanceOf(address(loan));  // Accounts for excess and fees from drawdown\n\n        // NOTE: Do not need to hevm.warp in this test because payments can be made whenever as long as they are before the nextPaymentDue\n\n        uint256 numPayments = loan.paymentsRemaining();\n        // Approve 1st of 3 payments.\n        (uint256 total, uint256 principal, uint256 interest, uint256 due,) = loan.getNextPayment();\n        if(total == 0 && interest == 0) return;  // If fuzz params cause payments to be so small they round to zero, skip fuzz iteration\n\n        assertTrue(!bob.try_makePayment(address(loan)));  // Can't makePayment with lack of approval\n\n        mint(\"USDC\", address(bob),       total);\n        bob.approve(USDC, address(loan), total);\n\n        // Before state\n        assertLoanState({\n            loan:              loan,\n            loanState:         1,\n            principalOwed:     drawdownAmount,\n            principalPaid:     0,\n            interestPaid:      0,\n            loanBalance:       loanPreBal,\n            paymentsRemaining: numPayments,\n            nextPaymentDue:    due\n        });\n\n        // Pause protocol and attempt makePayment()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!bob.try_makePayment(address(loan)));\n\n        // Unpause protocol and makePayment()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(bob.try_makePayment(address(loan)));  // Make payment.\n\n        due += loan.paymentIntervalSeconds();  // Increment next payment due by interval\n\n        // After state\n        assertLoanState({\n            loan:              loan,\n            loanState:         1,\n            principalOwed:     drawdownAmount,\n            principalPaid:     0,\n            interestPaid:      interest,\n            loanBalance:       loanPreBal + interest,\n            paymentsRemaining: numPayments - 1,\n            nextPaymentDue:    due\n        });\n\n        // Approve numPayments - 1.\n        for (uint256 i = 2; i <= numPayments - 1; i++) {\n            repetitivePayment(loan, numPayments, i, drawdownAmount, loanPreBal, uint256(0));\n        }\n        \n        // Approve last payment.\n        (total, principal, interest, due,) = loan.getNextPayment();\n        mint(\"USDC\", address(bob),       total);\n        bob.approve(USDC, address(loan), total);\n\n        // Check CollateralLocker balance.\n        assertEq(weth.balanceOf(loan.collateralLocker()), reqCollateral);\n\n        // Make last payment.\n        assertTrue(bob.try_makePayment(address(loan)));\n\n        due += loan.paymentIntervalSeconds();  // Increment next payment due by interval\n\n        // After state, state variables.\n        assertLoanState({\n            loan:              loan,\n            loanState:         2,\n            principalOwed:     0,\n            principalPaid:     principal,\n            interestPaid:      interest * numPayments,\n            loanBalance:       loanPreBal + interest * numPayments + principal,\n            paymentsRemaining: 0,\n            nextPaymentDue:    0\n        });\n\n        // CollateralLocker after state.\n        assertEq(weth.balanceOf(loan.collateralLocker()),             0);\n        assertEq(weth.balanceOf(address(bob)),            reqCollateral);\n    }\n\n    function test_makePayment_late(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio,\n        uint256 fundAmount,\n        uint256 drawdownAmount\n    )\n        public\n    {\n        Loan loan = createAndFundLoan(apr, index, numPayments, requestAmount, collateralRatio, fundAmount);  // Const three payments used for this test\n        address fundingLocker = loan.fundingLocker();\n        fundAmount = usdc.balanceOf(fundingLocker);\n\n        drawdownAmount = constrictToRange(drawdownAmount, loan.requestAmount(), fundAmount, true);\n\n        assertEq(uint256(loan.loanState()), 0);  // Loan state: Ready\n\n        assertTrue(!bob.try_makePayment(address(loan)));  // Can't makePayment when State != Active\n\n        // Approve collateral and drawdown loan.\n        uint256 reqCollateral = drawdown(loan, drawdownAmount);\n        uint256 loanPreBal    = usdc.balanceOf(address(loan));  // Accounts for excess and fees from drawdown\n        uint256 numPayments   = loan.paymentsRemaining();\n\n        // Approve 1st of 3 payments.\n        (uint256 total, uint256 principal, uint256 interest, uint256 due,) = loan.getNextPayment();\n        if(total == 0 && interest == 0) return;  // If fuzz params cause payments to be so small they round to zero, skip fuzz iteration\n\n        assertTrue(!bob.try_makePayment(address(loan)));  // Can't makePayment with lack of approval\n\n        mint(\"USDC\", address(bob),       total);\n        bob.approve(USDC, address(loan), total);\n\n        // Before state\n        assertLoanState({\n            loan:              loan,\n            loanState:         1,\n            principalOwed:     drawdownAmount,\n            principalPaid:     0,\n            interestPaid:      0,\n            loanBalance:       loanPreBal,\n            paymentsRemaining: numPayments,\n            nextPaymentDue:    due\n        });\n\n        // Make first payment on time.\n        assertTrue(bob.try_makePayment(address(loan)));\n\n        due += loan.paymentIntervalSeconds();  // Increment next payment due by interval\n\n        // After state\n        assertLoanState({\n            loan:              loan,\n            loanState:         1,\n            principalOwed:     drawdownAmount,\n            principalPaid:     0,\n            interestPaid:      interest,\n            loanBalance:       loanPreBal + interest,\n            paymentsRemaining: numPayments - 1,\n            nextPaymentDue:    due\n        });\n\n        // Approve numPayments - 1.\n        for (uint256 i = 1; i < numPayments - 1; i++) {\n            // Warp to 1 second after next payment is due (payment is late)\n            hevm.warp(loan.nextPaymentDue() + 1);\n            repetitivePayment(loan, numPayments, i, drawdownAmount, loanPreBal, interest);\n        }\n\n        uint256 interest_late;\n\n        // Warp to 1 second after next payment is due (payment is late)\n        hevm.warp(loan.nextPaymentDue() + 1);\n\n        // Approve 3nd of 3 payments.\n        (total, principal, interest_late, due,) = loan.getNextPayment();\n        mint(\"USDC\", address(bob),       total);\n        bob.approve(USDC, address(loan), total);\n\n        // Check CollateralLocker balance.\n        assertEq(weth.balanceOf(loan.collateralLocker()), reqCollateral);\n\n        // Make payment.\n        assertTrue(bob.try_makePayment(address(loan)));\n\n        due += loan.paymentIntervalSeconds();  // Increment next payment due by interval\n\n        // After state, state variables.\n        assertLoanState({\n            loan:              loan,\n            loanState:         2,\n            principalOwed:     0,\n            principalPaid:     principal,\n            interestPaid:      interest + interest_late * (numPayments - 1),\n            loanBalance:       loanPreBal + interest + interest_late * (numPayments - 1) + principal,\n            paymentsRemaining: 0,\n            nextPaymentDue:    0\n        });\n\n        // CollateralLocker after state.\n        assertEq(weth.balanceOf(loan.collateralLocker()),             0);\n        assertEq(weth.balanceOf(address(bob)),            reqCollateral);\n    }\n\n    function test_unwind_loan(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio,\n        uint256 fundAmount,\n        uint256 drawdownAmount\n    )\n        public\n    {\n\n        TestObj memory flBalance;\n        TestObj memory loanBalance;\n        TestObj memory loanState;\n\n        Loan loan = createAndFundLoan(apr, index, numPayments, requestAmount, collateralRatio, fundAmount);  // Const three payments used for this test\n        address fundingLocker = loan.fundingLocker();\n        fundAmount = usdc.balanceOf(fundingLocker);\n\n        // Warp to the fundingPeriod, can't call unwind() yet\n        hevm.warp(loan.createdAt() + globals.fundingPeriod());\n        assertTrue(!pat.try_unwind(address(loan)));\n\n        flBalance.pre   = usdc.balanceOf(fundingLocker);\n        loanBalance.pre = usdc.balanceOf(address(loan));\n        loanState.pre   = uint256(loan.loanState());\n\n        // Warp 1 more second, can call unwind()\n        hevm.warp(loan.createdAt() + globals.fundingPeriod() + 1);\n\n        // Pause protocol and attempt unwind()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_unwind(address(loan)));\n\n        // Unpause protocol and unwind()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pat.try_unwind(address(loan)));\n\n        flBalance.post   = usdc.balanceOf(fundingLocker);\n        loanBalance.post = usdc.balanceOf(address(loan));\n        loanState.post   = uint256(loan.loanState());\n\n        assertEq(loanBalance.pre, 0);\n        assertEq(loanState.pre,   0);\n\n        assertEq(flBalance.post, 0);\n        assertEq(loanState.post, 3);\n\n        assertEq(flBalance.pre,    fundAmount);\n        assertEq(loanBalance.post, fundAmount);\n\n        assertEq(loan.excessReturned(), loanBalance.post);\n\n        // Pause protocol and attempt withdrawFunds() (through claim)\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!pat.try_claim(address(pool), address(loan), address(dlFactory)));\n\n        // Unpause protocol and withdrawFunds() (through claim)\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(pat.try_claim(address(pool), address(loan), address(dlFactory)));\n\n        withinDiff(usdc.balanceOf(address(pool.liquidityLocker())), fundAmount, 1);\n        withinDiff(usdc.balanceOf(address(loan)),                            0, 1);\n\n        // Can't unwind() loan after it has already been called.\n        assertTrue(!pat.try_unwind(address(loan)));\n    }\n\n    function test_trigger_default(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio,\n        uint256 fundAmount,\n        uint256 drawdownAmount\n    )\n        public\n    {\n        gov.setMaxSwapSlippage(10_000);  // Set 100% slippage to account for very large liquidations from fuzzing\n\n        Loan loan = createAndFundLoan(apr, index, numPayments, requestAmount, collateralRatio, fundAmount);\n        address fundingLocker = loan.fundingLocker();\n        fundAmount = IERC20(USDC).balanceOf(fundingLocker);\n        uint256 wadAmount = fundAmount * WAD / USD;\n\n        drawdownAmount = constrictToRange(drawdownAmount, loan.requestAmount(), fundAmount, true);\n\n        address debtLocker = pool.debtLockers(address(loan), address(dlFactory));\n\n        assertEq(uint256(loan.loanState()), 0);  // `Ready` state\n\n        uint256 reqCollateral = drawdown(loan, drawdownAmount);\n\n        assertEq(uint256(loan.loanState()), 1);  // `Active` state\n\n        assertTrue(!pat.try_triggerDefault(address(pool), address(loan), address(dlFactory)));  // Should fail to trigger default because current time is still less than the `nextPaymentDue`.\n        assertTrue(!cam.try_triggerDefault(address(loan)));                                     // Failed because commoner in not allowed to default the loan because they do not own any LoanFDTs.\n\n        hevm.warp(loan.nextPaymentDue() + 1);\n\n        assertTrue(!pat.try_triggerDefault(address(pool), address(loan), address(dlFactory)));  // Failed because still loan has defaultGracePeriod to repay the dues.\n        assertTrue(!cam.try_triggerDefault(address(loan)));                                     // Failed because still commoner is not allowed to default the loan.\n\n        hevm.warp(loan.nextPaymentDue() + globals.defaultGracePeriod());\n\n        assertTrue(!pat.try_triggerDefault(address(pool), address(loan), address(dlFactory)));  // Failed because still loan has defaultGracePeriod to repay the dues.\n        assertTrue(!cam.try_triggerDefault(address(loan)));                                     // Failed because still commoner is not allowed to default the loan.\n\n        hevm.warp(loan.nextPaymentDue() + globals.defaultGracePeriod() + 1);\n\n        assertTrue(!cam.try_triggerDefault(address(loan)));  // Failed because still commoner is not allowed to default the loan.\n\n        // Sid's Pool currently has 100% of LoanFDTs, so he can trigger the loan default.\n        // For this test, minLoanEquity is transferred to the commoner to test the minimum loan equity condition.\n        assertEq(loan.totalSupply(),       wadAmount);\n        assertEq(globals.minLoanEquity(),       2000);  // 20%\n\n        uint256 minEquity = loan.totalSupply() * globals.minLoanEquity() / 10_000;\n\n        // Simulate transfer of LoanFDTs from DebtLocker to commoner (<20% of total supply)\n        hevm.store(\n            address(loan),\n            keccak256(abi.encode(address(cam), 0)), // Mint tokens\n            bytes32(uint256(minEquity - 1))\n        );\n        hevm.store(\n            address(loan),\n            keccak256(abi.encode(address(debtLocker), 0)), // Overwrite balance\n            bytes32(uint256(wadAmount - minEquity + 1))\n        );\n\n        assertTrue(!cam.try_triggerDefault(address(loan)));  // Failed because still commoner is not allowed to default the loan.\n\n        // \"Transfer\" 1 more wei to meet 20% minimum equity requirement\n        hevm.store(\n            address(loan),\n            keccak256(abi.encode(address(cam), 0)), // Mint tokens\n            bytes32(uint256(minEquity))\n        );\n        hevm.store(\n            address(loan),\n            keccak256(abi.encode(address(debtLocker), 0)), // Overwrite balance\n            bytes32(uint256(wadAmount - minEquity))\n        );\n\n        assertTrue(cam.try_triggerDefault(address(loan)));  // Now with 20% of loan equity, a loan can be defaulted\n        assertEq(uint256(loan.loanState()), 4);\n    }\n\n    function test_calc_min_amount(\n        uint256 apr,\n        uint256 index,\n        uint256 requestAmount,\n        uint256 collateralRatio,\n        uint256 fundAmount,\n        uint256 drawdownAmount\n    )\n        public\n    {\n        Loan loan = createAndFundLoan(apr, index, 3, requestAmount, collateralRatio, fundAmount);  // Const three payments used for this test\n        address fundingLocker = loan.fundingLocker();\n        fundAmount = IERC20(USDC).balanceOf(fundingLocker);\n\n        drawdownAmount = constrictToRange(drawdownAmount, loan.requestAmount(), fundAmount, true);\n\n        uint256 reqCollateral = drawdown(loan, drawdownAmount);\n\n        uint256 expectedAmount = (reqCollateral * globals.getLatestPrice(WETH)) / globals.getLatestPrice(USDC);\n\n        assertEq((expectedAmount * USD) / WAD, loan.getExpectedAmountRecovered());\n    }\n\n    function test_makeFullPayment(\n        uint256 apr,\n        uint256 index,\n        uint256 numPayments,\n        uint256 requestAmount,\n        uint256 collateralRatio,\n        uint256 fundAmount,\n        uint256 drawdownAmount\n    )\n        public\n    {\n        Loan loan = createAndFundLoan(apr, index, numPayments, requestAmount, collateralRatio, fundAmount);\n        fundAmount = usdc.balanceOf(loan.fundingLocker());\n\n        drawdownAmount = constrictToRange(drawdownAmount, loan.requestAmount(), fundAmount, true);\n\n        assertEq(uint256(loan.loanState()), 0);  // Loan state: Ready\n\n        assertTrue(!bob.try_makeFullPayment(address(loan)));  // Can't makePayment when State != Active\n\n        // Approve collateral and drawdown loan.\n        uint256 reqCollateral = drawdown(loan, drawdownAmount);\n        uint256 loanPreBal    = usdc.balanceOf(address(loan));\n\n        assertTrue(!bob.try_makeFullPayment(address(loan)));  // Can't makePayment with lack of approval\n\n        // Approve full payment.\n        (uint256 total, uint256 principal, uint256 interest) = loan.getFullPayment();\n        mint(\"USDC\", address(bob), total);\n        bob.approve(USDC, address(loan), total);\n\n        // Before state\n        assertLoanState({\n            loan:              loan,\n            loanState:         1,\n            principalOwed:     drawdownAmount,\n            principalPaid:     0,\n            interestPaid:      0,\n            loanBalance:       loanPreBal,\n            paymentsRemaining: loan.paymentsRemaining(),\n            nextPaymentDue:    block.timestamp + loan.paymentIntervalSeconds()  // Not relevant to full payment\n        });\n\n        // CollateralLocker before state.\n        assertEq(weth.balanceOf(loan.collateralLocker()), reqCollateral);\n        assertEq(weth.balanceOf(address(bob)),                 0);\n\n        // Pause protocol and attempt makeFullPayment()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!bob.try_makeFullPayment(address(loan)));\n\n        // Unpause protocol and makeFullPayment()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(bob.try_makeFullPayment(address(loan)));  // Make full payment.\n\n        // After state\n        assertEq(usdc.balanceOf(address(loan)), loanPreBal + total);\n\n        assertLoanState({\n            loan:              loan,\n            loanState:         2,\n            principalOwed:     0,\n            principalPaid:     principal,\n            interestPaid:      interest,\n            loanBalance:       loanPreBal + interest + principal,\n            paymentsRemaining: 0,\n            nextPaymentDue:    0\n        });\n\n        // CollateralLocker after state.\n        assertEq(weth.balanceOf(loan.collateralLocker()),             0);\n        assertEq(weth.balanceOf(address(bob)),     reqCollateral);\n    }\n\n    function test_reclaim_erc20() external {\n        // Add different kinds of assets to the loan.\n        mint(\"USDC\", address(loan), 1000 * USD);\n        mint(\"DAI\",  address(loan), 1000 * WAD);\n        mint(\"WETH\", address(loan),  100 * WAD);\n\n        Governor fakeGov = new Governor();\n\n        uint256 beforeBalanceDAI  =  dai.balanceOf(address(gov));\n        uint256 beforeBalanceWETH = weth.balanceOf(address(gov));\n\n        assertTrue(!fakeGov.try_reclaimERC20(address(loan), DAI));\n        assertTrue(    !gov.try_reclaimERC20(address(loan), USDC));  // Governor cannot remove liquidityAsset from loans\n        assertTrue(    !gov.try_reclaimERC20(address(loan), address(0)));\n        assertTrue(     gov.try_reclaimERC20(address(loan), WETH));\n        assertTrue(     gov.try_reclaimERC20(address(loan), DAI));\n\n        uint256 afterBalanceDAI  =  dai.balanceOf(address(gov));\n        uint256 afterBalanceWETH = weth.balanceOf(address(gov));\n\n        assertEq(afterBalanceDAI  - beforeBalanceDAI,  1000 * WAD);\n        assertEq(afterBalanceWETH - beforeBalanceWETH,  100 * WAD);\n    }\n\n    function test_setLoanAdmin() public {\n        // Pause protocol and attempt setLoanAdmin()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), true));\n        assertTrue(!bob.try_setLoanAdmin(address(loan), address(securityAdmin), true));\n        assertTrue(!loan.loanAdmins(address(securityAdmin)));\n\n        // Unpause protocol and setLoanAdmin()\n        assertTrue(emergencyAdmin.try_setProtocolPause(address(globals), false));\n        assertTrue(bob.try_setLoanAdmin(address(loan), address(securityAdmin), true));\n        assertTrue(loan.loanAdmins(address(securityAdmin)));\n    }\n\n    function repetitivePayment(Loan loan, uint256 numPayments, uint256 paymentCount, uint256 drawdownAmount, uint256 loanPreBal, uint256 oldInterest) internal {\n        (uint256 total,, uint256 interest, uint256 due,) = loan.getNextPayment();\n        mint(\"USDC\", address(bob),       total);\n        bob.approve(USDC, address(loan), total);\n\n        // Below is the way of catering two scenarios\n        // 1. When there is no late payment so interest paid will be a multiple of `numPayments`.\n        // 2. If there is a late payment then needs to handle the situation where interest paid is `interest (without late fee) + interest (late fee) * numPayments`.\n        numPayments = oldInterest == uint256(0) ? numPayments - paymentCount : numPayments - paymentCount - 1;\n        // Make payment.\n        assertTrue(bob.try_makePayment(address(loan)));\n\n        due += loan.paymentIntervalSeconds();  // Increment next payment due by interval\n\n        // After state\n        assertLoanState({\n            loan:              loan,\n            loanState:         1,\n            principalOwed:     drawdownAmount,\n            principalPaid:     0,\n            interestPaid:      oldInterest + (interest * paymentCount),\n            loanBalance:       loanPreBal  + oldInterest + (interest * paymentCount),\n            paymentsRemaining: numPayments,\n            nextPaymentDue:    due\n        });\n    }\n}\n"
    },
    "packages/protocol/contracts/test/Gulp.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract GulpTest is TestUtil {\n\n    using SafeMath for uint256;\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        setUpOracles();\n        setUpFactories();\n        setUpCalcs();\n        setUpActors();\n        setUpBalancerPoolForStakers();\n        setUpLiquidityPool();\n        createLoan();\n    }\n\n    function setUpLoanAndDrawdown() public {\n        mint(\"USDC\", address(leo), 10_000_000 * USD);  // Mint USDC to LP\n        leo.approve(USDC, address(pool), MAX_UINT);    // LP approves USDC\n\n        leo.deposit(address(pool), 10_000_000 * USD);                                      // LP deposits 10m USDC to Pool\n        pat.fundLoan(address(pool), address(loan), address(dlFactory), 10_000_000 * USD);  // PD funds loan for 10m USDC\n\n        uint256 cReq = loan.collateralRequiredForDrawdown(10_000_000 * USD);  // WETH required for 100_000_000 USDC drawdown on loan\n        mint(\"WETH\", address(bob), cReq);                                  // Mint WETH to borrower\n        bob.approve(WETH, address(loan), MAX_UINT);                        // Borrower approves WETH\n        bob.drawdown(address(loan), 10_000_000 * USD);                     // Borrower draws down 10m USDC\n    }\n\n    function test_gulp() public {\n\n        Governor fakeGov = new Governor();\n        fakeGov.setGovGlobals(globals);  // Point to globals created by gov\n\n        gov.setGovTreasury(treasury);\n        fakeGov.setGovTreasury(treasury);\n\n        // Drawdown on loan will transfer fee to MPL token contract.\n        setUpLoanAndDrawdown();\n\n        // Treasury processes fees, sends to MPL token holders.\n        // treasury.distributeToHolders();\n        assertTrue(!fakeGov.try_distributeToHolders());\n        assertTrue(     gov.try_distributeToHolders());\n\n        uint256 totalFundsToken = usdc.balanceOf(address(mpl));\n        uint256 mplBal          = mpl.balanceOf(address(bPool));\n        uint256 earnings        = mpl.withdrawableFundsOf(address(bPool));\n\n        assertEq(totalFundsToken, loan.principalOwed() * globals.treasuryFee() / 10_000);\n        assertEq(mplBal,          155_000 * WAD);\n        withinDiff(earnings, totalFundsToken * mplBal / mpl.totalSupply(), 1);\n\n        // MPL is held by Balancer Pool, claim on behalf of BPool.\n        mpl.withdrawFundsOnBehalf(address(bPool));\n\n        uint256 usdcBal_preGulp = bPool.getBalance(USDC);\n\n        bPool.gulp(USDC); // Update BPool with gulp(token).\n\n        uint256 usdcBal_postGulp = bPool.getBalance(USDC);\n\n        assertEq(usdcBal_preGulp,  1_550_000 * USD);\n        assertEq(usdcBal_postGulp, usdcBal_preGulp + earnings); // USDC is transferred into Balancer pool, increasing value of MPL\n    }\n\n    function test_uniswap_pool_skim() public {\n        setUpUniswapMplUsdcPool(75_000 * WAD, 1_500_000 * USD);\n\n        gov.setGovTreasury(treasury);\n        // Drawdown on loan will transfer fee to MPL token contract.\n        setUpLoanAndDrawdown();\n\n        assertTrue(gov.try_distributeToHolders());\n\n        uint256 totalFundsToken = IERC20(USDC).balanceOf(address(mpl));\n        uint256 mplBal          = mpl.balanceOf(address(uniswapPair));\n        uint256 earnings        = mpl.withdrawableFundsOf(address(uniswapPair));\n\n        assertEq(totalFundsToken, loan.principalOwed() * globals.treasuryFee() / 10_000);\n        assertEq(mplBal,          75_000 * WAD);\n        withinDiff(earnings, totalFundsToken * mplBal / mpl.totalSupply(), 1);\n\n        (uint256 before_reserve0, uint256 before_reserve1, ) = uniswapPair.getReserves();\n\n        // MPL is held by Balancer Pool, claim on behalf of BPool.\n        mpl.withdrawFundsOnBehalf(address(uniswapPair));\n\n        (uint256 after_reserve0, uint256 after_reserve1, ) = uniswapPair.getReserves();\n\n        assertEq(before_reserve0, after_reserve0, \"Should not be any change in reserve0\");\n        assertEq(before_reserve1, after_reserve1, \"Should not be any change in reserve1\");\n\n        uint256 usdcBal_preSkim     = usdc.balanceOf(address(uniswapPair));\n        uint256 lex_usdcBal_preSkim = usdc.balanceOf(address(lex));\n        \n        uniswapPair.skim(address(lex)); // Get the extra fund out of it.\n\n        uint256 usdcBal_postSkim     = usdc.balanceOf(address(uniswapPair));\n        uint256 lex_usdcBal_postSkim = usdc.balanceOf(address(lex));\n\n        (uint256 reserve0_afterSkim, uint256 reserve1_afterSkim, ) = uniswapPair.getReserves();\n\n        assertEq(usdcBal_preSkim - usdcBal_postSkim,         earnings,       \"Should only transfer earnings amount\");\n        assertEq(lex_usdcBal_postSkim - lex_usdcBal_preSkim, earnings,       \"Should lex's USDC balance increase by earnings\");\n        assertEq(reserve0_afterSkim,                         after_reserve0, \"Should not be a change\");\n        assertEq(reserve1_afterSkim,                         after_reserve1, \"Should not be a change\");\n    }\n}\n"
    },
    "packages/protocol/contracts/test/FundingLockerFactory.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract FundingLockerFactoryTest is TestUtil {\n\n    function setUp() public {\n        setUpGlobals();\n        createFundingLockerFactory();\n    }\n\n    function test_newLocker() public {\n        FundingLocker fl  = FundingLocker(flFactory.newLocker(USDC));\n\n        // Validate the storage of flfactory.\n        assertEq(flFactory.owner(address(fl)), address(this));\n        assertTrue(flFactory.isLocker(address(fl)));\n\n        // Validate the storage of fl.\n        assertEq(fl.loan(), address(this), \"Incorrect loan address\");\n        assertEq(address(fl.liquidityAsset()), USDC, \"Incorrect address of loan asset\");\n    }\n}\n"
    },
    "packages/protocol/contracts/test/DebtLockerFactory.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract DebtLockerFactoryTest is TestUtil {\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        createBorrower();\n        setUpFactories();\n        setUpCalcs();\n        createLoan();\n    }\n\n    function test_newLocker() public {\n        DebtLocker dl  = DebtLocker(dlFactory.newLocker(address(loan)));\n        // Validate the storage of dlfactory.\n        assertEq(  dlFactory.owner(address(dl)), address(this));\n        assertTrue(dlFactory.isLocker(address(dl)));\n\n        // Validate the storage of dl.\n        assertEq(address(dl.loan()),       address(loan), \"Incorrect loan address\");\n        assertEq(dl.pool(),                address(this), \"Incorrect owner of the DebtLocker\");\n        assertEq(address(dl.liquidityAsset()),  USDC,     \"Incorrect address of loan asset\");\n    }\n}\n"
    },
    "packages/protocol/contracts/test/CollateralLockerFactory.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract CollateralLockerFactoryTest is TestUtil {\n\n    function setUp() public {\n        setUpGlobals();\n        setUpTokens();\n        createCollateralLockerFactory();\n        createBorrower();\n    }\n\n    function test_newLocker() public {\n        CollateralLocker cl  = CollateralLocker(clFactory.newLocker(USDC));\n\n        // Validate the storage of clfactory.\n        assertEq(clFactory.owner(address(cl)), address(this), \"Invalid owner\");\n        assertTrue(clFactory.isLocker(address(cl)));\n\n        // Validate the storage of cl.\n        assertEq(cl.loan(), address(this), \"Incorrect loan address\");\n        assertEq(address(cl.collateralAsset()), USDC, \"Incorrect address of collateral asset\");\n\n        // Assert that no one can access CollateralLocker funds\n        mint(\"USDC\", address(cl),  500 * USD);\n        assertTrue(!bob.try_pull(address(cl), address(bob), 10));\n    }\n}\n"
    },
    "packages/protocol/contracts/test/ChainLinkOracle.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract ChainlinkOracleTest is TestUtil {\n\n    function setUp() public {\n        setUpGlobals();\n        createCommoner();\n        setUpTokens();\n        setUpOracles();\n    }\n\n    function test_getLatestPrice() public {\n        // Assert initial state\n        assertTrue( wethOracle.getLatestPrice() > int256(1));\n        assertTrue(!wethOracle.manualOverride());\n        assertEq(   wethOracle.manualPrice(), int256(0));\n\n        // Try to set manual price before setting the manual override.\n        assertTrue(!securityAdmin.try_setManualPrice(address(wethOracle), int256(45000)));\n\n        // Enable oracle manual override\n        assertTrue(         !cam.try_setManualOverride(address(wethOracle), true));\n        assertTrue(securityAdmin.try_setManualOverride(address(wethOracle), true));\n        assertTrue(   wethOracle.manualOverride());\n\n        // Set price manually\n        assertTrue(         !cam.try_setManualPrice(address(wethOracle), int256(45000)));\n        assertTrue(securityAdmin.try_setManualPrice(address(wethOracle), int256(45000)));\n        assertEq(     wethOracle.manualPrice(),    int256(45000));\n        assertEq(     wethOracle.getLatestPrice(), int256(45000));\n\n        // Change aggregator\n        assertTrue(         !cam.try_changeAggregator(address(wethOracle), 0xb022E2970b3501d8d83eD07912330d178543C1eB));\n        assertTrue(securityAdmin.try_changeAggregator(address(wethOracle), 0xb022E2970b3501d8d83eD07912330d178543C1eB));\n        assertEq(address(wethOracle.priceFeed()),                          0xb022E2970b3501d8d83eD07912330d178543C1eB);\n    }\n}\n"
    },
    "packages/protocol/contracts/test/Calcs.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TestUtil.sol\";\n\ncontract CalcsTest is TestUtil {\n\n    using SafeMath for uint256;\n\n    function setUp() public {\n        setUpGlobals();\n        setUpPoolDelegate();\n        createBorrower();\n        setUpFactories();\n        setUpCalcs();\n        setUpTokens();\n        setUpOracles();\n        setUpBalancerPool();\n        setUpLiquidityPool();\n    }\n\n    function setUpRepayments(uint256 loanAmt, uint256 apr, uint16 index, uint16 numPayments, uint256 lateFee, uint256 premiumFee) public {\n        uint16[10] memory paymentIntervalArray = [1, 2, 5, 7, 10, 15, 30, 60, 90, 360];\n\n        uint256 paymentInterval = paymentIntervalArray[index % 10];\n        uint256 termDays        = paymentInterval * (numPayments % 100);\n\n        {\n            // Mint \"infinite\" amount of USDC and deposit into pool\n            mint(\"USDC\", address(this), loanAmt);\n            IERC20(USDC).approve(address(pool), uint256(-1));\n            pool.deposit(loanAmt);\n\n            // Create loan, fund loan, draw down on loan\n            address[3] memory calcs = [address(repaymentCalc), address(lateFeeCalc), address(premiumCalc)];\n            uint256[5] memory specs = [apr, termDays, paymentInterval, loanAmt, 2000];\n            loan = bob.createLoan(address(loanFactory), USDC, WETH, address(flFactory), address(clFactory),  specs, calcs);\n        }\n\n        assertTrue(pat.try_fundLoan(address(pool), address(loan),  address(dlFactory), loanAmt));\n\n        {\n            uint256 cReq = loan.collateralRequiredForDrawdown(loanAmt); // wETH required for 1_000 USDC drawdown on loan\n            mint(\"WETH\", address(bob), cReq);\n            bob.approve(WETH, address(loan), cReq);\n            bob.drawdown(address(loan), loanAmt);\n        }\n    }\n\n    function test_repayments(uint256 _loanAmt, uint16 apr, uint16 index, uint16 numPayments) public {\n        uint256 loanAmt = constrictToRange(_loanAmt, 10_000 * USD, 100 * 1E9 * USD, true);  // $10k to $100b, non zero\n\n        apr = apr % 10_000;\n\n        setUpRepayments(loanAmt, uint256(apr), index, numPayments, 100, 100);\n\n        // Calculate theoretical values and sum up actual values\n        uint256 totalPaid;\n        uint256 sumTotal;\n        {\n            uint256 paymentIntervalDays = loan.paymentIntervalSeconds().div(1 days);\n            uint256 totalInterest       = loanAmt * apr / 10_000 * paymentIntervalDays / 365 * loan.paymentsRemaining();\n                    totalPaid           = loanAmt + totalInterest;\n        }\n\n        (uint256 lastTotal,, uint256 lastInterest,,) = loan.getNextPayment();\n\n        mint(\"USDC\",      address(bob),  loanAmt * 1000); // Mint enough to pay interest\n        bob.approve(USDC, address(loan), loanAmt * 1000);\n\n        uint256 beforeBal = IERC20(USDC).balanceOf(address(bob));\n\n        while (loan.paymentsRemaining() > 0) {\n\n            (uint256 total,      uint256 principal,      uint256 interest,,)    = loan.getNextPayment();                       // USDC required for payment on loan\n            (uint256 total_calc, uint256 principal_calc, uint256 interest_calc) = repaymentCalc.getNextPayment(address(loan)); // USDC required for payment on loan\n\n            assertEq(total,         total_calc);\n            assertEq(principal, principal_calc);\n            assertEq(interest,   interest_calc);\n\n            sumTotal += total;\n\n            bob.makePayment(address(loan));\n\n            if (loan.paymentsRemaining() > 0) {\n                assertEq(total,        lastTotal);\n                assertEq(interest,  lastInterest);\n                assertEq(total,         interest);\n                assertEq(principal,            0);\n            } else {\n                assertEq(total,     principal + interest);\n                assertEq(principal,              loanAmt);\n                withinPrecision(totalPaid, sumTotal, 8);\n                assertEq(beforeBal - IERC20(USDC).balanceOf(address(bob)), sumTotal); // Pays back all principal, plus interest\n            }\n\n            lastTotal    = total;\n            lastInterest = interest;\n        }\n    }\n\n    function test_late_fee(uint56 _loanAmt, uint256 apr, uint16 index, uint16 numPayments, uint256 lateFee) public {\n        uint256 loanAmt = constrictToRange(_loanAmt, 10_000 * USD, 100 * 1E9 * USD, true);  // $10k to $100b, non zero\n\n        apr     = apr     % 10_000;\n        lateFee = lateFee % 10_000;\n\n        setUpRepayments(loanAmt, apr, index, numPayments, lateFee, 100);\n\n        // Calculate theoretical values and sum up actual values\n        uint256 totalPaid;\n        uint256 sumTotal;\n        {\n            uint256 paymentIntervalDays = loan.paymentIntervalSeconds().div(1 days);\n            uint256 totalInterest       = loanAmt * apr / 10_000 * paymentIntervalDays / 365 * loan.paymentsRemaining();\n                    totalPaid           = loanAmt + totalInterest + totalInterest * lateFeeCalc.lateFee() / 10_000;\n        }\n\n        hevm.warp(loan.nextPaymentDue() + 1);  // Payment is late\n        (uint256 lastTotal,,,,) =  loan.getNextPayment();\n\n        mint(\"USDC\",      address(bob),  loanAmt * 1000); // Mint enough to pay interest\n        bob.approve(USDC, address(loan), loanAmt * 1000);\n\n        uint256 beforeBal = IERC20(USDC).balanceOf(address(bob));\n\n        while (loan.paymentsRemaining() > 0) {\n            hevm.warp(loan.nextPaymentDue() + 1);  // Payment is late\n\n            (uint256 total,      uint256 principal,      uint256 interest,,)    = loan.getNextPayment();                       // USDC required for payment on loan\n            (uint256 total_calc, uint256 principal_calc, uint256 interest_calc) = repaymentCalc.getNextPayment(address(loan)); // USDC required for payment on loan\n\n            uint256 interest_late = lateFeeCalc.getLateFee(interest_calc);  // USDC required for payment on loan\n\n            assertEq(total,        total_calc + interest_late);  // Late fee is added to total\n            assertEq(principal,                principal_calc);\n            assertEq(interest,  interest_calc + interest_late);\n\n            sumTotal += total;\n\n            bob.makePayment(address(loan));\n\n            if (loan.paymentsRemaining() > 0) {\n                assertEq(total,     lastTotal);\n                assertEq(total,      interest);\n                assertEq(principal,         0);\n\n                assertEq(interest_late, total_calc * lateFeeCalc.lateFee() / 10_000);\n            } else {\n                assertEq(total,     principal + interest);\n                assertEq(principal,              loanAmt);\n                withinPrecision(totalPaid, sumTotal, 8);\n                assertEq(beforeBal - IERC20(USDC).balanceOf(address(bob)), sumTotal); // Pays back all principal, plus interest\n            }\n\n            lastTotal = total;\n        }\n    }\n\n    function test_premium(uint56 _loanAmt, uint256 premiumFee) public {\n        uint256 loanAmt = uint256(_loanAmt) + 10 ** 6;  // uint56(-1) = ~72b * 10 ** 6\n\n        premiumFee = premiumFee % 10_000;\n\n        setUpRepayments(loanAmt, 100, 1, 1, 100, premiumFee);\n\n        mint(\"USDC\",      address(bob),  loanAmt * 1000); // Mint enough to pay interest\n        bob.approve(USDC, address(loan), loanAmt * 1000);\n\n        uint256 beforeBal = IERC20(USDC).balanceOf(address(bob));\n\n        (uint256 total,         uint256 principal,         uint256 interest)         = loan.getFullPayment();                         // USDC required for payment on loan\n        (uint256 total_premium, uint256 principal_premium, uint256 interest_premium) = premiumCalc.getPremiumPayment(address(loan));  // USDC required for payment on loan\n\n        assertEq(total,         total_premium);\n        assertEq(principal, principal_premium);\n        assertEq(interest,   interest_premium);\n\n        assertEq(interest, principal * premiumCalc.premiumFee() / 10_000);\n\n        bob.makeFullPayment(address(loan));\n\n        uint256 afterBal = IERC20(USDC).balanceOf(address(bob));\n\n        assertEq(beforeBal - afterBal, total);\n    }\n\n    function test_late_premium(uint56 _loanAmt, uint256 apr, uint16 index, uint16 numPayments, uint256 lateFee, uint256 premiumFee) public {\n        uint256 loanAmt = constrictToRange(_loanAmt, 10_000 * USD, 100 * 1E9 * USD, true);  // $10k to $100b, non zero\n\n        apr     = apr     % 10_000;\n        lateFee = lateFee % 10_000;\n\n        setUpRepayments(loanAmt, apr, index, numPayments, lateFee, 100);\n\n        mint(\"USDC\",      address(bob),  loanAmt * 1000); // Mint enough to pay interest\n        bob.approve(USDC, address(loan), loanAmt * 1000);\n\n        uint256 beforeBal = IERC20(USDC).balanceOf(address(bob));\n\n        hevm.warp(loan.nextPaymentDue() + 1);  // Payment is late\n\n        (uint256 total,         uint256 principal,         uint256 interest)         = loan.getFullPayment();                         // USDC required for payment on loan\n        (uint256 total_premium, uint256 principal_premium, uint256 interest_premium) = premiumCalc.getPremiumPayment(address(loan));  // USDC required for payment on loan\n\n        // Get late fee from regular interest payment\n        (,, uint256 interest_calc) = repaymentCalc.getNextPayment(address(loan)); \n        uint256 interest_late = lateFeeCalc.getLateFee(interest_calc);  // USDC required for payment on loan\n\n        assertEq(total,        total_premium + interest_late);\n        assertEq(principal,                principal_premium);\n        assertEq(interest,  interest_premium + interest_late);\n\n        assertEq(interest, principal * premiumCalc.premiumFee() / 10_000 + interest_late);\n\n        bob.makeFullPayment(address(loan));\n\n        uint256 afterBal = IERC20(USDC).balanceOf(address(bob));\n\n        assertEq(beforeBal - afterBal, total);\n    }\n}\n"
    },
    "packages/protocol/contracts/interfaces/IMapleTreasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IMapleTreasury {\n\n    function mpl() external view returns (address);\n\n    function fundsToken() external view returns (address);\n\n    function uniswapRouter() external view returns (address);\n\n    function globals() external view returns (address);\n\n    function setGlobals(address) external;\n\n    function reclaimERC20(address, uint256) external;\n\n    function distributeToHolders() external;\n\n    function convertERC20(address) external;\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IMplRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IMplRewards {\n\n    // Views\n    function rewardsToken() external view returns (address);\n\n    function stakingToken() external view returns (address);\n\n    function periodFinish() external view returns (uint256);\n\n    function rewardRate() external view returns (uint256);\n\n    function rewardsDuration() external view returns (uint256);\n\n    function lastUpdateTime() external view returns (uint256);\n\n    function rewardPerTokenStored() external view returns (uint256);\n\n    function lastPauseTime() external view returns (uint256);\n\n    function paused() external view returns (bool);\n    \n    function userRewardPerTokenPaid(address) external view returns (uint256);\n\n    function rewards(address) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function earned(address) external view returns (uint256);\n\n    function getRewardForDuration() external view returns (uint256);\n\n\n    // Mutative\n    function stake(uint256) external;\n\n    function withdraw(uint256) external;\n\n    function getReward() external;\n\n    function exit() external;\n\n    function notifyRewardAmount(uint256) external;\n\n    function updatePeriodFinish(uint256) external;\n\n    function recoverERC20(address, uint256) external;\n\n    function setRewardsDuration(uint256) external;\n\n    function setPaused(bool) external;\n\n}\n"
    },
    "packages/protocol/contracts/interfaces/IMplRewardsFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.11;\n\ninterface IMplRewardsFactory {\n\n    function globals() external view returns (address);\n\n    function isMplRewards(address) external view returns (bool);\n\n    function setGlobals(address _globals) external;\n\n    function createMplRewards(address rewardsToken, address stakingToken) external returns (address mplRewards);\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}